<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trading Bot Research ‚Äî Feb 2026</title>
<style>
/* ========== RESET & BASE ========== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #0a0a0f;
  --bg-secondary: #12121a;
  --bg-card: #1a1a2e;
  --bg-card-hover: #1f1f35;
  --bg-code: #0d1117;
  --border: #2a2a3e;
  --border-light: #3a3a52;
  --text-primary: #e4e4ef;
  --text-secondary: #9999b0;
  --text-muted: #6b6b80;
  --accent: #7c5cfc;
  --accent-light: #9b7eff;
  --accent-glow: rgba(124, 92, 252, 0.15);
  --green: #22c55e;
  --green-bg: rgba(34, 197, 94, 0.08);
  --green-border: rgba(34, 197, 94, 0.25);
  --yellow: #eab308;
  --yellow-bg: rgba(234, 179, 8, 0.08);
  --yellow-border: rgba(234, 179, 8, 0.25);
  --red: #ef4444;
  --red-bg: rgba(239, 68, 68, 0.08);
  --red-border: rgba(239, 68, 68, 0.25);
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'SF Mono', Consolas, monospace;
  --radius: 12px;
  --radius-sm: 8px;
  --shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
  --transition: 0.2s ease;
}

html { scroll-behavior: smooth; font-size: 16px; }

body {
  font-family: var(--font-sans);
  background: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

::selection { background: var(--accent); color: #fff; }

/* ========== STICKY HEADER ========== */
.header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: rgba(10, 10, 15, 0.85);
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  border-bottom: 1px solid var(--border);
}

.header-inner {
  max-width: 1100px;
  margin: 0 auto;
  padding: 0 24px;
}

.header-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 0 0;
}

.logo {
  display: flex;
  align-items: center;
  gap: 12px;
}

.logo-icon {
  width: 36px;
  height: 36px;
  background: linear-gradient(135deg, var(--accent), #a78bfa);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
}

.logo-text {
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.02em;
  color: var(--text-primary);
}

.logo-badge {
  font-size: 11px;
  padding: 3px 8px;
  border-radius: 6px;
  background: var(--accent-glow);
  color: var(--accent-light);
  font-weight: 600;
  letter-spacing: 0.02em;
}

/* ========== TABS ========== */
.tabs {
  display: flex;
  gap: 0;
  padding-top: 12px;
}

.tab {
  padding: 12px 24px;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  border: none;
  background: none;
  border-bottom: 2px solid transparent;
  transition: all var(--transition);
  letter-spacing: 0.01em;
  position: relative;
}

.tab:hover { color: var(--text-secondary); }

.tab.active {
  color: var(--accent-light);
  border-bottom-color: var(--accent);
}

/* ========== MAIN CONTENT ========== */
.main {
  max-width: 1100px;
  margin: 0 auto;
  padding: 40px 24px 80px;
}

.tab-content { display: none; animation: fadeIn 0.3s ease; }
.tab-content.active { display: block; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ========== TLDR SECTION ========== */
.tldr-hero {
  text-align: center;
  padding: 48px 0 40px;
}

.tldr-hero h1 {
  font-size: clamp(28px, 5vw, 42px);
  font-weight: 800;
  letter-spacing: -0.03em;
  line-height: 1.2;
  background: linear-gradient(135deg, #fff, var(--accent-light));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 12px;
}

.tldr-hero p {
  font-size: 16px;
  color: var(--text-secondary);
  max-width: 600px;
  margin: 0 auto;
}

.tldr-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 24px;
  margin-top: 32px;
}

.tldr-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px;
  transition: all var(--transition);
}

.tldr-card:hover {
  border-color: var(--border-light);
  background: var(--bg-card-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow);
}

.tldr-card-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
}

.tldr-card-icon {
  width: 40px;
  height: 40px;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  flex-shrink: 0;
}

.tldr-card-title {
  font-size: 17px;
  font-weight: 700;
  letter-spacing: -0.01em;
}

.tldr-card-subtitle {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* Strategy cards in TLDR */
.strategy-rec {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.strategy-rec-item {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px 20px;
  display: flex;
  align-items: flex-start;
  gap: 14px;
}

.strategy-rec-item .rank {
  width: 28px;
  height: 28px;
  border-radius: 8px;
  background: var(--accent-glow);
  color: var(--accent-light);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 13px;
  flex-shrink: 0;
  margin-top: 2px;
}

.strategy-rec-item .strat-name {
  font-weight: 700;
  font-size: 15px;
  margin-bottom: 4px;
}

.strategy-rec-item .strat-detail {
  font-size: 13px;
  color: var(--text-secondary);
  line-height: 1.6;
}

.strategy-rec-item .strat-returns {
  display: inline-block;
  font-size: 12px;
  font-weight: 600;
  padding: 2px 8px;
  border-radius: 4px;
  background: var(--green-bg);
  color: var(--green);
  border: 1px solid var(--green-border);
  margin-top: 6px;
}

/* Avoid list */
.avoid-list {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.avoid-list li {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.5;
}

.avoid-list li::before {
  content: '‚úï';
  color: var(--red);
  font-weight: 800;
  font-size: 13px;
  flex-shrink: 0;
  margin-top: 2px;
}

/* Capital table in TLDR */
.capital-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
}

.capital-item {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  text-align: center;
}

.capital-item .cap-label {
  font-size: 12px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 6px;
}

.capital-item .cap-value {
  font-size: 22px;
  font-weight: 800;
  color: var(--accent-light);
}

.capital-item .cap-note {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* Tech stack */
.tech-stack {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.tech-tag {
  padding: 8px 14px;
  border-radius: var(--radius-sm);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  font-size: 13px;
  font-weight: 600;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: 6px;
}

.tech-tag .tag-role {
  font-size: 10px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.04em;
}

/* Steps */
.steps {
  display: flex;
  flex-direction: column;
  gap: 16px;
  counter-reset: step-counter;
}

.step {
  display: flex;
  gap: 16px;
  align-items: flex-start;
  counter-increment: step-counter;
}

.step-number {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  background: linear-gradient(135deg, var(--accent), #a78bfa);
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 15px;
  flex-shrink: 0;
}

.step-content h4 {
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 4px;
}

.step-content p {
  font-size: 13px;
  color: var(--text-secondary);
  line-height: 1.6;
}

/* Brutal truth */
.truth-list {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.truth-list li {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  font-size: 14px;
  line-height: 1.6;
  color: var(--text-secondary);
}

.truth-list li strong {
  color: var(--text-primary);
}

.truth-list li .truth-icon {
  flex-shrink: 0;
  margin-top: 2px;
  font-size: 16px;
}

/* ========== FULL RESEARCH ========== */
/* Table of Contents */
.toc {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px 32px;
  margin-bottom: 40px;
}

.toc h2 {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 16px;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

.toc-list {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.toc-list li a {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  border-radius: var(--radius-sm);
  color: var(--text-secondary);
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
  transition: all var(--transition);
}

.toc-list li a:hover {
  background: var(--accent-glow);
  color: var(--accent-light);
}

.toc-list li a .toc-num {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-muted);
  min-width: 24px;
}

/* Section styling */
.section {
  margin-bottom: 48px;
}

.section-header {
  display: flex;
  align-items: center;
  gap: 14px;
  margin-bottom: 24px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}

.section-num {
  font-size: 13px;
  font-weight: 700;
  color: var(--accent-light);
  background: var(--accent-glow);
  padding: 4px 10px;
  border-radius: 6px;
  letter-spacing: 0.02em;
}

.section h2 {
  font-size: clamp(22px, 3.5vw, 28px);
  font-weight: 800;
  letter-spacing: -0.02em;
}

.section h3 {
  font-size: 20px;
  font-weight: 700;
  margin: 32px 0 16px;
  letter-spacing: -0.01em;
  color: var(--text-primary);
}

.section h4 {
  font-size: 16px;
  font-weight: 700;
  margin: 24px 0 12px;
  color: var(--text-primary);
}

.section p, .section li {
  font-size: 15px;
  color: var(--text-secondary);
  line-height: 1.8;
}

.section p { margin-bottom: 12px; }

.section ul, .section ol {
  padding-left: 20px;
  margin-bottom: 16px;
}

.section li { margin-bottom: 6px; }

.section strong { color: var(--text-primary); }

/* ========== COLLAPSIBLE SECTIONS ========== */
.collapsible {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 16px;
  overflow: hidden;
  transition: border-color var(--transition);
}

.collapsible:hover { border-color: var(--border-light); }

.collapsible-toggle {
  width: 100%;
  padding: 18px 24px;
  background: none;
  border: none;
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-size: 16px;
  font-weight: 700;
  text-align: left;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  transition: background var(--transition);
}

.collapsible-toggle:hover { background: var(--bg-card-hover); }

.collapsible-toggle .chevron {
  font-size: 12px;
  transition: transform 0.3s ease;
  color: var(--text-muted);
}

.collapsible.open .collapsible-toggle .chevron { transform: rotate(180deg); }

.collapsible-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s ease;
}

.collapsible.open .collapsible-body { max-height: 5000px; }

.collapsible-content {
  padding: 0 24px 20px;
}

/* ========== STRATEGY TIER CARDS ========== */
.tier-label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 14px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 0.02em;
  margin-bottom: 20px;
}

.tier-label.green { background: var(--green-bg); color: var(--green); border: 1px solid var(--green-border); }
.tier-label.yellow { background: var(--yellow-bg); color: var(--yellow); border: 1px solid var(--yellow-border); }
.tier-label.red { background: var(--red-bg); color: var(--red); border: 1px solid var(--red-border); }

.strategy-card {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 16px;
  transition: all var(--transition);
}

.strategy-card:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow);
}

.strategy-card.green-card { border: 1px solid var(--green-border); border-left: 3px solid var(--green); }
.strategy-card.yellow-card { border: 1px solid var(--yellow-border); border-left: 3px solid var(--yellow); }
.strategy-card.red-card { border: 1px solid var(--red-border); border-left: 3px solid var(--red); }

.strategy-card h4 {
  font-size: 17px;
  font-weight: 700;
  margin: 0 0 12px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.strategy-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 14px;
}

.meta-tag {
  font-size: 11px;
  font-weight: 600;
  padding: 3px 10px;
  border-radius: 5px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
}

.meta-tag.returns { background: var(--green-bg); color: var(--green); border-color: var(--green-border); }
.meta-tag.capital { background: var(--accent-glow); color: var(--accent-light); border-color: rgba(124, 92, 252, 0.25); }
.meta-tag.complexity-low { background: var(--green-bg); color: var(--green); border-color: var(--green-border); }
.meta-tag.complexity-med { background: var(--yellow-bg); color: var(--yellow); border-color: var(--yellow-border); }
.meta-tag.complexity-high { background: var(--red-bg); color: var(--red); border-color: var(--red-border); }

.strategy-card p {
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.7;
  margin-bottom: 8px;
}

.strategy-card .insight {
  background: var(--accent-glow);
  border: 1px solid rgba(124, 92, 252, 0.2);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  font-size: 13px;
  color: var(--accent-light);
  margin-top: 12px;
}

.strategy-card .warning {
  background: var(--red-bg);
  border: 1px solid var(--red-border);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  font-size: 13px;
  color: #fca5a5;
  margin-top: 12px;
}

/* ========== TABLES ========== */
.table-wrapper {
  overflow-x: auto;
  margin: 16px 0 24px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

thead { background: var(--bg-card); }

th {
  padding: 14px 18px;
  text-align: left;
  font-weight: 700;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-muted);
  border-bottom: 1px solid var(--border);
}

td {
  padding: 12px 18px;
  border-bottom: 1px solid var(--border);
  color: var(--text-secondary);
}

tr:last-child td { border-bottom: none; }

tbody tr:hover { background: var(--bg-card); }

td code {
  font-family: var(--font-mono);
  font-size: 13px;
  background: var(--bg-code);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--accent-light);
}

/* ========== CODE BLOCKS ========== */
pre {
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 20px 24px;
  overflow-x: auto;
  margin: 16px 0 24px;
  position: relative;
}

pre code {
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: 1.6;
  color: #c9d1d9;
}

code {
  font-family: var(--font-mono);
  font-size: 0.9em;
  background: var(--bg-code);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--accent-light);
}

/* Syntax highlighting (dark theme) */
.kw { color: #ff7b72; }
.fn { color: #d2a8ff; }
.str { color: #a5d6ff; }
.cm { color: #8b949e; font-style: italic; }
.num { color: #79c0ff; }
.op { color: #ff7b72; }
.var { color: #ffa657; }
.cls { color: #7ee787; }
.dec { color: #d2a8ff; }

.code-label {
  position: absolute;
  top: 8px;
  right: 12px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* ========== TOOLTIPS ========== */
.abbr {
  border-bottom: 1px dotted var(--text-muted);
  cursor: help;
  position: relative;
  white-space: nowrap;
}

.abbr:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #2a2a40;
  color: var(--text-primary);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  white-space: nowrap;
  z-index: 200;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  border: 1px solid var(--border-light);
  pointer-events: none;
}

.abbr:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: #2a2a40;
  z-index: 200;
}

/* ========== CALLOUT BOXES ========== */
.callout {
  border-radius: var(--radius-sm);
  padding: 16px 20px;
  margin: 16px 0;
  font-size: 14px;
  line-height: 1.6;
}

.callout.info {
  background: var(--accent-glow);
  border: 1px solid rgba(124, 92, 252, 0.2);
  color: var(--accent-light);
}

.callout.warning {
  background: var(--yellow-bg);
  border: 1px solid var(--yellow-border);
  color: #fde68a;
}

.callout.danger {
  background: var(--red-bg);
  border: 1px solid var(--red-border);
  color: #fca5a5;
}

.callout.success {
  background: var(--green-bg);
  border: 1px solid var(--green-border);
  color: #86efac;
}

.callout strong { color: inherit; filter: brightness(1.2); }

/* ========== RESPONSIVE ========== */
@media (min-width: 768px) {
  .tldr-grid { grid-template-columns: repeat(2, 1fr); }
  .tldr-card.full-width { grid-column: 1 / -1; }
}

@media (max-width: 767px) {
  .header-top { flex-wrap: wrap; gap: 8px; }
  .tab { padding: 10px 16px; font-size: 13px; }
  .main { padding: 24px 16px 60px; }
  .tldr-hero { padding: 32px 0 24px; }
  .collapsible-toggle { padding: 14px 16px; font-size: 15px; }
  .collapsible-content { padding: 0 16px 16px; }
  .strategy-card { padding: 18px; }
  .toc { padding: 20px; }
  pre { padding: 14px 16px; }
  .capital-grid { grid-template-columns: 1fr 1fr; }
  th, td { padding: 10px 12px; }
}

@media (max-width: 480px) {
  .capital-grid { grid-template-columns: 1fr; }
  .strategy-meta { gap: 6px; }
  .meta-tag { font-size: 10px; }
}

/* ========== MISC ========== */
.divider {
  height: 1px;
  background: var(--border);
  margin: 40px 0;
}

.highlight { color: var(--accent-light); font-weight: 600; }

a { color: var(--accent-light); text-decoration: none; transition: color var(--transition); }
a:hover { color: var(--accent); text-decoration: underline; }

.footnote {
  margin-top: 48px;
  padding-top: 24px;
  border-top: 1px solid var(--border);
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.6;
}

/* Progress indicator */
.scroll-progress {
  position: fixed;
  top: 0;
  left: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--accent), #a78bfa);
  z-index: 200;
  transition: width 0.1s linear;
}

/* Back to top */
.back-to-top {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0;
  transform: translateY(10px);
  transition: all 0.3s ease;
  z-index: 50;
  font-size: 18px;
}

.back-to-top.visible {
  opacity: 1;
  transform: translateY(0);
}

.back-to-top:hover {
  background: var(--accent-glow);
  border-color: var(--accent);
  color: var(--accent-light);
}

/* Formula display */
.formula {
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 20px;
  font-family: var(--font-mono);
  font-size: 14px;
  color: var(--accent-light);
  margin: 12px 0;
  overflow-x: auto;
}

/* ========== COPY TO CLIPBOARD BUTTON ========== */
.code-block {
  position: relative;
}

.copy-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  padding: 4px 10px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 6px;
  cursor: pointer;
  transition: all var(--transition);
  font-family: var(--font-sans);
  z-index: 10;
  letter-spacing: 0.02em;
}

.copy-btn:hover {
  color: var(--accent-light);
  border-color: var(--accent);
  background: var(--accent-glow);
}

.copy-btn.copied {
  color: var(--green);
  border-color: var(--green-border);
  background: var(--green-bg);
}

/* ========== DIFFICULTY & TIME BADGES ========== */
.difficulty-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 0.02em;
  margin-right: 8px;
  margin-bottom: 8px;
}

.difficulty-badge.beginner {
  background: var(--green-bg);
  color: var(--green);
  border: 1px solid var(--green-border);
}

.difficulty-badge.intermediate {
  background: var(--yellow-bg);
  color: var(--yellow);
  border: 1px solid var(--yellow-border);
}

.difficulty-badge.advanced {
  background: var(--red-bg);
  color: var(--red);
  border: 1px solid var(--red-border);
}

.time-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  background: var(--accent-glow);
  color: var(--accent-light);
  border: 1px solid rgba(124, 92, 252, 0.25);
  margin-bottom: 8px;
}

/* ========== SECTION MEGA HEADERS ========== */
.mega-section-header {
  background: linear-gradient(135deg, var(--bg-card), var(--bg-card-hover));
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 32px;
  margin: 48px 0 32px;
  text-align: center;
}

.mega-section-header h2 {
  font-size: clamp(24px, 4vw, 32px);
  font-weight: 800;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, #fff, var(--accent-light));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}

.mega-section-header p {
  color: var(--text-secondary);
  font-size: 15px;
  max-width: 600px;
  margin: 0 auto;
}

.mega-section-header .section-num {
  font-size: 14px;
  display: inline-block;
  margin-bottom: 12px;
}

/* ========== FILE TREE ========== */
.file-tree {
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px 20px;
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: 1.8;
  color: #8b949e;
  margin: 16px 0 24px;
  overflow-x: auto;
}

.file-tree .dir { color: var(--accent-light); font-weight: 600; }
.file-tree .file { color: #c9d1d9; }
.file-tree .comment { color: #6b6b80; font-style: italic; }

/* ========== PROGRESS BAR ========== */
.progress-container {
  display: flex;
  align-items: center;
  gap: 12px;
  margin: 12px 0;
}

.progress-bar {
  flex: 1;
  height: 8px;
  background: var(--bg-secondary);
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.5s ease;
}

.progress-fill.green { background: var(--green); }
.progress-fill.yellow { background: var(--yellow); }
.progress-fill.red { background: var(--red); }
.progress-fill.accent { background: var(--accent); }

.progress-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  min-width: 40px;
}

/* ========== INTERACTIVE CALCULATOR ========== */
.calculator {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px;
  margin: 16px 0 24px;
}

.calc-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.calc-label {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
  min-width: 160px;
}

.calc-input {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 8px 14px;
  font-family: var(--font-mono);
  font-size: 14px;
  color: var(--text-primary);
  width: 150px;
  outline: none;
  transition: border-color var(--transition);
}

.calc-input:focus {
  border-color: var(--accent);
}

.calc-result {
  background: var(--green-bg);
  border: 1px solid var(--green-border);
  border-radius: var(--radius-sm);
  padding: 16px 20px;
  margin-top: 16px;
  text-align: center;
}

.calc-result .result-value {
  font-size: 28px;
  font-weight: 800;
  color: var(--green);
}

.calc-result .result-label {
  font-size: 12px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-top: 4px;
}

/* Increase max-height for large sections */
.collapsible.open .collapsible-body { max-height: 100000px; }

/* ========== SUBSECTION DIVIDER ========== */
.subsection-divider {
  display: flex;
  align-items: center;
  gap: 16px;
  margin: 32px 0 24px;
}

.subsection-divider::before,
.subsection-divider::after {
  content: '';
  flex: 1;
  height: 1px;
  background: var(--border);
}

.subsection-divider span {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  white-space: nowrap;
}
</style>
</head>
<body>

<!-- Scroll Progress -->
<div class="scroll-progress" id="scrollProgress"></div>

<!-- Header -->
<header class="header">
  <div class="header-inner">
    <div class="header-top">
      <div class="logo">
        <div class="logo-icon">ü§ñ</div>
        <div>
          <div class="logo-text">Trading Bot Research</div>
        </div>
        <span class="logo-badge">FEB 2026</span>
      </div>
    </div>
    <div class="tabs">
      <button class="tab active" data-tab="tldr">‚ö° TL;DR</button>
      <button class="tab" data-tab="ftmo">üè¶ FTMO / Prop Trading</button>
      <button class="tab" data-tab="full">üìÑ Full Research</button>
    </div>
  </div>
</header>

<!-- Main -->
<main class="main">

<!-- ==================== TL;DR TAB ==================== -->
<div class="tab-content active" id="tab-tldr">
  <div class="tldr-hero">
    <h1>Crypto Trading Bot<br>Cheat Sheet</h1>
    <p>1,400 lines of research distilled into what you actually need to know. No fluff. No hype. Just signal.</p>
  </div>

  <div class="tldr-grid">

    <!-- TOP 3 STRATEGIES -->
    <div class="tldr-card full-width">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: var(--green-bg); border: 1px solid var(--green-border);">üèÜ</div>
        <div>
          <div class="tldr-card-title">Top 3 Strategies for Retail</div>
          <div class="tldr-card-subtitle">Ranked by risk-adjusted viability for a solo developer</div>
        </div>
      </div>
      <div class="strategy-rec">
        <div class="strategy-rec-item">
          <div class="rank">1</div>
          <div>
            <div class="strat-name">Funding Rate Arbitrage</div>
            <div class="strat-detail">
              Go long spot + short perps on the same asset. Collect funding payments every 8 hours. Delta-neutral = minimal directional risk. <span class="abbr" data-tooltip="Centralized Exchange">CEX</span>es like Binance and OKX now have built-in tools for this.
            </div>
            <span class="strat-returns">15‚Äì25% APY ¬∑ Lowest risk</span>
          </div>
        </div>
        <div class="strategy-rec-item">
          <div class="rank">2</div>
          <div>
            <div class="strat-name">Grid Trading</div>
            <div class="strat-detail">
              Place buy/sell orders at fixed intervals around a price range. Prints money in sideways markets (which is ~60% of the time). Simple to set up, no ML needed.
            </div>
            <span class="strat-returns">2‚Äì5% monthly ¬∑ Medium risk</span>
          </div>
        </div>
        <div class="strategy-rec-item">
          <div class="rank">3</div>
          <div>
            <div class="strat-name"><span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> Bot + Momentum Filter</div>
            <div class="strat-detail">
              Automated <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> with safety orders to lower your average entry. Add a momentum filter (200 <span class="abbr" data-tooltip="Simple Moving Average">SMA</span>) to avoid buying in downtrends. Works brilliantly in bull & ranging markets.
            </div>
            <span class="strat-returns">2‚Äì4% monthly ¬∑ Medium risk</span>
          </div>
        </div>
      </div>
    </div>

    <!-- WHAT TO AVOID -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: var(--red-bg); border: 1px solid var(--red-border);">üö´</div>
        <div>
          <div class="tldr-card-title">What to Avoid</div>
          <div class="tldr-card-subtitle">Don't waste time or money here</div>
        </div>
      </div>
      <ul class="avoid-list">
        <li><span class="abbr" data-tooltip="Maximal Extractable Value ‚Äî profit extracted by reordering transactions">MEV</span> / Sandwich attacks ‚Äî avg profit dropped to $3/tx on Ethereum. Saturated.</li>
        <li>Flash loan arb ‚Äî requires $100K+ infra, dominated by pros. Tutorials are scams.</li>
        <li><span class="abbr" data-tooltip="High-Frequency Trading">HFT</span> on major pairs ‚Äî you're competing with co-located servers running at &lt;1ms. You'll lose.</li>
        <li>YouTube strategies ‚Äî if it's public, it's already crowded and decaying.</li>
        <li><span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> bots on altcoins without stop losses ‚Äî Luna went from $80 to $0.0001.</li>
        <li>High leverage (&gt;3x) on any automated strategy</li>
      </ul>
    </div>

    <!-- MINIMUM CAPITAL -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: var(--accent-glow); border: 1px solid rgba(124,92,252,0.25);">üí∞</div>
        <div>
          <div class="tldr-card-title">Minimum Capital</div>
          <div class="tldr-card-subtitle">What you actually need to start</div>
        </div>
      </div>
      <div class="capital-grid">
        <div class="capital-item">
          <div class="cap-label">Absolute Minimum</div>
          <div class="cap-value">$1K</div>
          <div class="cap-note">Grid / DCA only</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Recommended Start</div>
          <div class="cap-value">$5K</div>
          <div class="cap-note">Funding arb viable</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Multi-Strategy</div>
          <div class="cap-value">$10K+</div>
          <div class="cap-note">Run 2-3 strategies</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Tuition Budget</div>
          <div class="cap-value">$1-2K</div>
          <div class="cap-note">Expect to lose this learning</div>
        </div>
      </div>
    </div>

    <!-- TECH STACK -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: rgba(34,211,238,0.1); border: 1px solid rgba(34,211,238,0.25);">üõ†Ô∏è</div>
        <div>
          <div class="tldr-card-title">Recommended Tech Stack</div>
          <div class="tldr-card-subtitle">For a frontend developer going into trading</div>
        </div>
      </div>
      <div class="tech-stack">
        <div class="tech-tag"><span class="tag-role">Research</span> Python + VectorBT</div>
        <div class="tech-tag"><span class="tag-role">Bot</span> TypeScript + CCXT</div>
        <div class="tech-tag"><span class="tag-role">DeFi</span> ethers.js</div>
        <div class="tech-tag"><span class="tag-role">ML</span> LightGBM / scikit-learn</div>
        <div class="tech-tag"><span class="tag-role">Framework</span> Freqtrade</div>
        <div class="tech-tag"><span class="tag-role">Infra</span> AWS Tokyo VPS</div>
        <div class="tech-tag"><span class="tag-role">Monitor</span> Telegram Bot</div>
        <div class="tech-tag"><span class="tag-role">Data</span> CoinGlass API</div>
      </div>
    </div>

    <!-- STEPS -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: rgba(251,191,36,0.1); border: 1px solid rgba(251,191,36,0.25);">üöÄ</div>
        <div>
          <div class="tldr-card-title">Step 1-2-3 to Get Started</div>
          <div class="tldr-card-subtitle">Your first 30 days</div>
        </div>
      </div>
      <div class="steps">
        <div class="step">
          <div class="step-number">1</div>
          <div class="step-content">
            <h4>Set Up & Learn (Week 1‚Äì2)</h4>
            <p>Create exchange accounts (Binance/Bybit), complete KYC, generate API keys (read-only first). Install Python + CCXT. Download 2 years of BTC/USDT candle data. Build your first SMA crossover strategy ‚Äî it won't be profitable, but it teaches the mechanics.</p>
          </div>
        </div>
        <div class="step">
          <div class="step-number">2</div>
          <div class="step-content">
            <h4>Backtest & Paper Trade (Week 3‚Äì6)</h4>
            <p>Pick one Tier 1 strategy (funding arb or grid). Backtest with VectorBT across multiple market regimes. Run walk-forward analysis ‚Äî if out-of-sample is within 50% of in-sample, you have a real edge. Paper trade for 2‚Äì4 weeks minimum.</p>
          </div>
        </div>
        <div class="step">
          <div class="step-number">3</div>
          <div class="step-content">
            <h4>Go Live Small (Week 7+)</h4>
            <p>Deploy to AWS Tokyo VPS. Start with 10% of intended capital. Set Telegram alerts for every trade. Implement circuit breakers: 3% daily drawdown = auto-stop. Monitor obsessively for 2 weeks. Scale only after 4+ profitable weeks.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- FTMO RECOMMENDATION -->
    <div class="tldr-card full-width">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: var(--green-bg); border: 1px solid var(--green-border);">üè¶</div>
        <div>
          <div class="tldr-card-title">Recommended: FTMO / Prop Firm Trading</div>
          <div class="tldr-card-subtitle">Best ROI path with minimal capital ‚Äî see the dedicated FTMO tab for full details</div>
        </div>
      </div>
      <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.7; margin-bottom: 12px;">
        Instead of risking $5K‚Äì$100K of your own money, <strong style="color: var(--text-primary);">trade with prop firm capital for just ~‚Ç¨345‚Äì600 per attempt</strong>. 
        Pass FTMO's challenge with a bot (eliminates emotional trading, the #1 failure reason), get a <strong style="color: var(--text-primary);">$100K funded account</strong>, and keep <strong style="color: var(--accent-light);">80‚Äì90% of profits</strong>.
      </p>
      <div class="capital-grid">
        <div class="capital-item">
          <div class="cap-label">Investment</div>
          <div class="cap-value" style="color: var(--green);">~‚Ç¨600</div>
          <div class="cap-note">Challenge fee (refunded on pass)</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Funded Capital</div>
          <div class="cap-value">$100K</div>
          <div class="cap-note">Up to $2M with scaling</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Monthly Income</div>
          <div class="cap-value" style="color: var(--green);">$1.6‚Äì9K</div>
          <div class="cap-note">2‚Äì10% returns √ó 80-90% split</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Bot Pass Rate</div>
          <div class="cap-value">20‚Äì40%</div>
          <div class="cap-note">vs 8% for manual traders</div>
        </div>
      </div>
      <div class="callout success" style="margin-top: 16px; margin-bottom: 0;">
        üí° <strong>Bottom line:</strong> FTMO is astronomically better ROI than trading your own capital. ~‚Ç¨600 risk for $4,000+/month potential. Check the <strong>FTMO / Prop Trading</strong> tab for the complete deep dive ‚Äî rules, strategies, math, and step-by-step roadmap.
      </div>
    </div>

    <!-- BRUTAL TRUTH -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.25);">üíÄ</div>
        <div>
          <div class="tldr-card-title">The Brutal Truth</div>
          <div class="tldr-card-subtitle">What nobody puts in their YouTube thumbnail</div>
        </div>
      </div>
      <ul class="truth-list">
        <li><span class="truth-icon">‚ö†Ô∏è</span> <span><strong>Most trading bots lose money.</strong> The bot doesn't create the edge ‚Äî it executes yours. No edge = faster money burning.</span></li>
        <li><span class="truth-icon">üí∏</span> <span><strong>Fees are the silent killer.</strong> A bot trading 30x/day at 0.1% = 90% monthly in fees. You must beat that just to break even.</span></li>
        <li><span class="truth-icon">üè¢</span> <span><strong>Your competition spends billions.</strong> Jump Trading, Wintermute, Citadel ‚Äî co-located FPGA servers. Your edge: small markets they ignore, DeFi complexity, speed of adaptation.</span></li>
        <li><span class="truth-icon">üìâ</span> <span><strong>Strategies decay.</strong> Average lifespan: 18‚Äì24 months. The process of finding edges IS the edge, not any single strategy.</span></li>
        <li><span class="truth-icon">üï∞Ô∏è</span> <span><strong>6‚Äì12 months of serious work</strong> before profitability. It's not a weekend project. Year 1 goal: don't lose money.</span></li>
        <li><span class="truth-icon">üìä</span> <span><strong>Simple holding often wins.</strong> Most wealth in crypto was created by HODLing BTC, not trading. If your edge isn't proven, <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> into BTC outperforms most bots over 5+ years.</span></li>
      </ul>
    </div>

  </div>
</div>

<!-- ==================== FTMO / PROP TRADING TAB ==================== -->
<div class="tab-content" id="tab-ftmo">

  <!-- FTMO TL;DR HERO -->
  <div class="tldr-hero">
    <h1>FTMO / Prop Trading<br>Bot Strategy</h1>
    <p>Trade $100K+ of someone else's capital for just ~‚Ç¨600 entry. Build a bot, pass the challenge, keep 80‚Äì90% of profits. Here's every detail you need.</p>
  </div>

  <!-- KEY NUMBERS TLDR -->
  <div class="tldr-grid">

    <div class="tldr-card full-width">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: var(--green-bg); border: 1px solid var(--green-border);">‚ö°</div>
        <div>
          <div class="tldr-card-title">Key Numbers at a Glance</div>
          <div class="tldr-card-subtitle">The TL;DR of the TL;DR</div>
        </div>
      </div>
      <div class="capital-grid" style="grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));">
        <div class="capital-item">
          <div class="cap-label">Challenge Fee</div>
          <div class="cap-value" style="font-size: 20px;">‚Ç¨540</div>
          <div class="cap-note">$100K account (refunded on pass)</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Potential Monthly</div>
          <div class="cap-value" style="font-size: 20px; color: var(--green);">$4,000+</div>
          <div class="cap-note">5% return √ó 80% split</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">General Pass Rate</div>
          <div class="cap-value" style="font-size: 20px; color: var(--red);">~8%</div>
          <div class="cap-note">Manual traders</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Bot Pass Rate</div>
          <div class="cap-value" style="font-size: 20px; color: var(--green);">20‚Äì40%</div>
          <div class="cap-note">Well-tested strategy</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Time to Funded</div>
          <div class="cap-value" style="font-size: 20px;">3‚Äì5 mo</div>
          <div class="cap-note">Learning + challenge + verification</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Best Strategy</div>
          <div class="cap-value" style="font-size: 16px;">London Breakout</div>
          <div class="cap-note">Session open + 0.5-1% risk</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Best Platform</div>
          <div class="cap-value" style="font-size: 16px;">MT5 (MQL5)</div>
          <div class="cap-note">Largest community, best backtester</div>
        </div>
        <div class="capital-item">
          <div class="cap-label">Tax in Romania</div>
          <div class="cap-value" style="font-size: 20px; color: var(--yellow);">35‚Äì45%</div>
          <div class="cap-note">PFA or SRL structure</div>
        </div>
      </div>
      <div class="callout success" style="margin-top: 16px; margin-bottom: 0;">
        üí° <strong>The pitch:</strong> Invest ~‚Ç¨1,000‚Äì2,000 in challenge fees ‚Üí get a $100K funded account ‚Üí earn $1,600‚Äì9,000/month ‚Üí scale to $400K‚Äì$2M. Worst case: you lose ‚Ç¨1‚Äì2K and gain serious trading knowledge.
      </div>
    </div>

    <!-- ROI COMPARISON MINI -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: var(--accent-glow); border: 1px solid rgba(124,92,252,0.25);">üìä</div>
        <div>
          <div class="tldr-card-title">FTMO vs Own Capital</div>
          <div class="tldr-card-subtitle">Why this is a no-brainer</div>
        </div>
      </div>
      <div class="table-wrapper" style="margin: 0;">
        <table>
          <thead><tr><th>Metric</th><th>FTMO Bot</th><th>Own Capital</th></tr></thead>
          <tbody>
            <tr><td>Capital needed</td><td style="color: var(--green); font-weight: 700;">~‚Ç¨600</td><td style="color: var(--red);">$100,000</td></tr>
            <tr><td>Risk to personal funds</td><td style="color: var(--green); font-weight: 700;">Challenge fee only</td><td style="color: var(--red);">Entire $100K</td></tr>
            <tr><td>Monthly profit (5%)</td><td>$4,000‚Äì4,500</td><td>$5,000</td></tr>
            <tr><td>ROI on invested capital</td><td style="color: var(--green); font-weight: 700;">267‚Äì750%</td><td>5%</td></tr>
            <tr><td>Leverage</td><td>1:100</td><td>1:30 (EU retail)</td></tr>
            <tr><td>Downside risk</td><td style="color: var(--green);">Lose ‚Ç¨600</td><td style="color: var(--red);">Lose $100K</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- WHY BOT WINS -->
    <div class="tldr-card">
      <div class="tldr-card-header">
        <div class="tldr-card-icon" style="background: rgba(34,211,238,0.1); border: 1px solid rgba(34,211,238,0.25);">ü§ñ</div>
        <div>
          <div class="tldr-card-title">Why a Bot Crushes Manual Trading</div>
          <div class="tldr-card-subtitle">92% fail manually ‚Äî bots fix the top 3 reasons</div>
        </div>
      </div>
      <div class="table-wrapper" style="margin: 0;">
        <table>
          <thead><tr><th>Failure Reason</th><th>% of Failures</th><th>Bot Fix</th></tr></thead>
          <tbody>
            <tr><td>Excessive risk (3‚Äì5%+ per trade)</td><td>45%</td><td style="color: var(--green);">‚úÖ Hard-coded 1% max</td></tr>
            <tr><td>Revenge trading after losses</td><td>30%</td><td style="color: var(--green);">‚úÖ No emotions</td></tr>
            <tr><td>Strategy hopping</td><td>15%</td><td style="color: var(--green);">‚úÖ Follows one strategy</td></tr>
            <tr><td>Over-trading</td><td>10%</td><td style="color: var(--green);">‚úÖ Hard trade limits</td></tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>

  <div class="divider"></div>

  <!-- ===== FTMO RULES & CONSTRAINTS ===== -->
  <section class="section" id="ftmo-s1">
    <div class="section-header">
      <span class="section-num">01</span>
      <h2>FTMO Rules &amp; Constraints</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Evaluation Structure (2-Step vs 1-Step)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>FTMO Challenge: 2-Step (Classic) ‚Äî Recommended for Bots</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Phase</th><th>Profit Target</th><th>Max Daily Loss</th><th>Max Total Loss</th><th>Min Trading Days</th><th>Time Limit</th></tr></thead>
              <tbody>
                <tr><td><strong>Phase 1</strong> (Challenge)</td><td style="color: var(--green); font-weight: 700;">10%</td><td style="color: var(--red);">5%</td><td style="color: var(--red);">10%</td><td>4 days</td><td>Unlimited</td></tr>
                <tr><td><strong>Phase 2</strong> (Verification)</td><td style="color: var(--green); font-weight: 700;">5%</td><td style="color: var(--red);">5%</td><td style="color: var(--red);">10%</td><td>4 days</td><td>Unlimited</td></tr>
                <tr><td><strong>Funded</strong></td><td>None</td><td style="color: var(--red);">5%</td><td style="color: var(--red);">10%</td><td>None</td><td>Ongoing</td></tr>
              </tbody>
            </table>
          </div>

          <h4>FTMO Challenge: 1-Step (NEW ‚Äî Feb 2026)</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Phase</th><th>Profit Target</th><th>Max Daily Loss</th><th>Max Total Loss</th><th>Min Days</th><th>Time Limit</th></tr></thead>
              <tbody>
                <tr><td><strong>Single Phase</strong></td><td style="color: var(--green); font-weight: 700;">10%</td><td style="color: var(--red);">3% (stricter!)</td><td style="color: var(--red);">10% (trailing)</td><td>2 days</td><td>Unlimited</td></tr>
                <tr><td><strong>Funded</strong></td><td>None</td><td style="color: var(--red);">3%</td><td style="color: var(--red);">10% (trailing)</td><td>None</td><td>Ongoing</td></tr>
              </tbody>
            </table>
          </div>

          <div class="callout warning">
            ‚ö†Ô∏è <strong>1-Step differences:</strong> Tighter daily loss (3% vs 5%), trailing max loss (follows highest balance upward), Best Day Rule (no single day &gt;50% of total profits), 90% profit split from day one. <strong>2-Step is easier for bots due to the 5% daily loss buffer.</strong>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Account Sizes &amp; Fees
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Account Size</th><th>Standard Fee</th><th>Aggressive Fee</th><th>Monthly Income (5% √ó 80%)</th></tr></thead>
              <tbody>
                <tr><td>$10,000</td><td>‚Ç¨155</td><td>‚Ç¨250</td><td style="color: var(--green);">$400</td></tr>
                <tr><td>$25,000</td><td>‚Ç¨250</td><td>‚Ç¨345</td><td style="color: var(--green);">$1,000</td></tr>
                <tr><td>$50,000</td><td>‚Ç¨345</td><td>‚Ç¨540</td><td style="color: var(--green);">$2,000</td></tr>
                <tr><td style="font-weight: 700;">$100,000</td><td style="font-weight: 700;">‚Ç¨540</td><td>‚Ç¨1,080</td><td style="color: var(--green); font-weight: 700;">$4,000</td></tr>
                <tr><td>$200,000</td><td>‚Ç¨1,080</td><td>N/A</td><td style="color: var(--green);">$8,000</td></tr>
              </tbody>
            </table>
          </div>
          <div class="callout info">üí° <strong>Fee is refunded</strong> with your first payout after passing. FTMO also offers 10‚Äì20% discounts regularly. <strong>Best value: $100K Standard at ‚Ç¨540.</strong></div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Leverage &amp; Tradeable Instruments
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Asset Class</th><th>Normal Account</th><th>Swing Account</th></tr></thead>
              <tbody>
                <tr><td><strong>Forex Pairs</strong></td><td style="color: var(--green); font-weight: 700;">1:100</td><td>1:30</td></tr>
                <tr><td>Major Indices</td><td>1:50</td><td>1:15</td></tr>
                <tr><td>Metals (Gold, Silver)</td><td>1:30</td><td>1:10</td></tr>
                <tr><td>Commodities</td><td>~1:3.3</td><td>~1:3.3</td></tr>
                <tr><td>Crypto</td><td>1:5</td><td>1:5</td></tr>
              </tbody>
            </table>
          </div>
          <p style="font-size: 14px; color: var(--text-secondary);">
            <strong>Tradeable:</strong> All major/minor/exotic forex pairs, indices (US30, US100, GER40, UK100), commodities (Gold, Silver, Oil), stock CFDs, and crypto (BTC, ETH).
          </p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        EA/Bot Rules ‚Äî What's Allowed &amp; Forbidden
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4 style="color: var(--green);">‚úÖ Allowed</h4>
          <ul>
            <li>Custom-built Expert Advisors (EAs)</li>
            <li>Algorithmic / automated trading</li>
            <li>Any legitimate strategy with proper risk management</li>
            <li>Discretionary + EA hybrid approaches</li>
          </ul>

          <h4 style="color: var(--red);">‚ùå Forbidden Practices</h4>
          <ul>
            <li><strong>Martingale / Grid Trading</strong> ‚Äî increasing position sizes after losses</li>
            <li><strong>Latency / Tick Arbitrage</strong> ‚Äî exploiting price feed delays</li>
            <li><strong>HFT</strong> ‚Äî more than ~2,000 server requests per day</li>
            <li><strong>Gap Trading</strong> ‚Äî trading around market close/open gaps</li>
            <li><strong>News Scalping</strong> ‚Äî trading during high-impact news (2-min rule on funded)</li>
            <li><strong>Copy Trading across accounts</strong> ‚Äî with other people/accounts</li>
            <li><strong>Hedging across accounts</strong> ‚Äî opposite positions on different accounts</li>
            <li><strong>Account Rolling</strong> ‚Äî resetting challenges with high-risk tactics</li>
          </ul>

          <div class="callout danger">
            ‚ö†Ô∏è <strong>Critical (2025‚Äì2026):</strong> FTMO now flags traders risking &gt;1‚Äì1.5% per trade. Multiple Reddit reports of payout delays when risk exceeds these levels. <strong>Keep risk at 0.5‚Äì1% per trade.</strong> Also, if many traders use the same third-party EA, FTMO may deny your account ‚Äî <strong>build your own.</strong>
          </div>

          <h4>Weekend &amp; Overnight Rules</h4>
          <ul>
            <li><strong>Normal Account:</strong> Must close all positions before weekend (Friday close)</li>
            <li><strong>Swing Account:</strong> Can hold over weekends</li>
            <li><strong>Funded:</strong> News trading restricted within 2 minutes of high-impact events</li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== STRATEGY RECOMMENDATIONS ===== -->
  <section class="section" id="ftmo-s2">
    <div class="section-header">
      <span class="section-num">02</span>
      <h2>Strategy Recommendations</h2>
    </div>

    <div class="callout info" style="margin-bottom: 24px;">
      üí° <strong>Core principle:</strong> The bot's #1 job is <strong>NOT breaching drawdown limits</strong> ‚Äî not hitting the profit target. Survive first, profit second. Optimal risk: 0.5‚Äì1% per trade.
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        üèÜ Strategy #1: London/NY Session Breakout (BEST for FTMO)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="strategy-card green-card">
            <h4>Session Breakout ‚Äî The Go-To FTMO Bot Strategy</h4>
            <div class="strategy-meta">
              <span class="meta-tag returns">Proven for FTMO</span>
              <span class="meta-tag complexity-low">Medium Complexity</span>
              <span class="meta-tag capital">0.5‚Äì1% risk/trade</span>
            </div>
            <p><strong>How it works:</strong></p>
            <ol>
              <li>Calculate the Asian session range (00:00‚Äì07:00 GMT)</li>
              <li>Place pending buy stop above the range high, sell stop below the range low</li>
              <li>Use tight stop-loss (opposite end of range or <span class="abbr" data-tooltip="Average True Range ‚Äî measure of price volatility">ATR</span>-based)</li>
              <li>Target 1:2 or 1:3 risk:reward</li>
              <li>Close all trades before session end</li>
            </ol>
            <p><strong>Why it's perfect for FTMO:</strong></p>
            <ul>
              <li>Predictable timing ‚Üí easy to automate</li>
              <li>High win rate during session opens</li>
              <li>Natural stop loss from range ‚Üí controlled risk</li>
              <li>Trades during liquid hours ‚Üí tight spreads</li>
            </ul>
            <div class="insight">
              üí° <strong>Bot parameters:</strong> Pairs: EURUSD, GBPUSD, USDJPY ¬∑ Timeframe: M15 or M30 ¬∑ Sessions: London (07:00‚Äì09:00 GMT), NY (13:00‚Äì15:00 GMT) ¬∑ Risk: 0.5‚Äì1% ¬∑ R:R min 1:2 ¬∑ Max 2 trades/day
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Strategy #2: Institutional Order Block / Supply &amp; Demand
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="strategy-card yellow-card">
            <h4>Supply &amp; Demand Zones</h4>
            <div class="strategy-meta">
              <span class="meta-tag returns">3‚Äì5 setups/week</span>
              <span class="meta-tag complexity-med">Higher Complexity</span>
              <span class="meta-tag capital">1% risk/trade</span>
            </div>
            <p><strong>How it works:</strong> Identify H4/D1 supply/demand zones ‚Üí wait for price to return ‚Üí enter on confirmation (engulfing candle, pin bar) ‚Üí SL beyond the zone ‚Üí target next zone (1:2‚Äì1:3 R:R).</p>
            <p><strong>Pairs:</strong> EUR/USD, GBP/USD, USD/JPY. <strong>Frequency:</strong> 3‚Äì5 setups per week.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Strategy #3: Trend Continuation with Pullback Entry
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="strategy-card yellow-card">
            <h4>EMA Pullback Trend Following</h4>
            <div class="strategy-meta">
              <span class="meta-tag returns">Trend markets</span>
              <span class="meta-tag complexity-low">Medium Complexity</span>
              <span class="meta-tag capital">0.5‚Äì1% risk/trade</span>
            </div>
            <p><strong>How it works:</strong> Determine trend on H4 (above/below 50 EMA) ‚Üí wait for pullback to 20 EMA on M15/M30 ‚Üí enter when price bounces with a candle pattern ‚Üí SL below pullback low ‚Üí TP at next structure level or 2√ó SL distance.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Position Sizing &amp; Daily Risk Management
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Position Sizing Formula</h4>
          <div class="formula">Lot Size = (Account Balance √ó Risk %) / (Stop Loss in Pips √ó Pip Value per Lot)</div>
          <p><strong>Example ($100K, 1% risk, 50-pip SL on EURUSD):</strong> Lot Size = ($100,000 √ó 0.01) / (50 √ó $10) = <strong>2.0 standard lots</strong></p>

          <h4>Quick Reference ‚Äî $100K Account (EURUSD)</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Risk %</th><th>30-pip SL</th><th>50-pip SL</th><th>100-pip SL</th></tr></thead>
              <tbody>
                <tr><td>0.5%</td><td>1.67 lots</td><td>1.0 lots</td><td>0.5 lots</td></tr>
                <tr><td style="font-weight: 700;">1.0%</td><td style="font-weight: 700;">3.33 lots</td><td style="font-weight: 700;">2.0 lots</td><td style="font-weight: 700;">1.0 lots</td></tr>
                <tr><td>1.5%</td><td>5.0 lots</td><td>3.0 lots</td><td>1.5 lots</td></tr>
              </tbody>
            </table>
          </div>

          <h4>CRITICAL Bot Risk Rules</h4>
          <ol>
            <li><strong>Daily loss limit:</strong> Stop trading at -3% daily (2% buffer before 5% limit)</li>
            <li><strong>Overall drawdown:</strong> Reduce risk when account drops below -5%</li>
            <li><strong>Max trades/day:</strong> Cap at 3‚Äì5 trades</li>
            <li><strong>Time filter:</strong> Only trade London/NY sessions</li>
            <li><strong>Friday close:</strong> Close all positions before weekend</li>
            <li><strong>News filter:</strong> Avoid 30min before/after high-impact news</li>
            <li><strong>Spread filter:</strong> Don't trade if spread &gt; threshold</li>
            <li><strong>Trailing stop / break-even:</strong> After 1R profit</li>
          </ol>

          <h4>Week-by-Week Approach (4‚Äì6 weeks)</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Week</th><th>Cumulative Target</th><th>Risk Level</th><th>Trades/Day</th></tr></thead>
              <tbody>
                <tr><td>Week 1</td><td>+2‚Äì3%</td><td>0.5‚Äì1%</td><td>1‚Äì2</td></tr>
                <tr><td>Week 2</td><td>+4‚Äì6%</td><td>0.5‚Äì1%</td><td>1‚Äì3</td></tr>
                <tr><td>Week 3</td><td>+7‚Äì9%</td><td style="color: var(--yellow);">Reduce to 0.5%</td><td>1‚Äì2</td></tr>
                <tr><td>Week 4+</td><td style="color: var(--green); font-weight: 700;">Hit 10%+ ‚Üí STOP</td><td>0.5% only</td><td>1</td></tr>
              </tbody>
            </table>
          </div>

          <div class="callout danger">
            ‚ö†Ô∏è <strong>"Week 3 Death Spiral":</strong> When at 8‚Äì9% profit, the urge to take big risks to finish fast is the #1 killer. The bot MUST reduce risk near the target, not increase it.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== PLATFORM COMPARISON ===== -->
  <section class="section" id="ftmo-s3">
    <div class="section-header">
      <span class="section-num">03</span>
      <h2>Platform Comparison ‚Äî MT5 vs cTrader</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Supported Platforms &amp; Recommendation
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Platform</th><th>Language</th><th>EA Support</th><th>Best For</th></tr></thead>
              <tbody>
                <tr><td><strong>MetaTrader 4</strong></td><td>MQL4</td><td>Full EA support</td><td>Classic forex EAs</td></tr>
                <tr style="background: var(--green-bg);">
                  <td><strong>MetaTrader 5</strong> ‚≠ê</td><td>MQL5</td><td>Full EA support</td><td style="color: var(--green); font-weight: 700;">Best overall for FTMO bots</td>
                </tr>
                <tr><td><strong>cTrader</strong></td><td>C# (cAlgo)</td><td>Full cBot support</td><td>Modern API, programmers</td></tr>
                <tr><td><strong>DXtrade</strong></td><td>Limited API</td><td>Limited</td><td>US clients only</td></tr>
              </tbody>
            </table>
          </div>

          <h4>MT5 (MQL5) ‚Äî Recommended Choice</h4>
          <ul>
            <li>‚úÖ Largest community &amp; code base</li>
            <li>‚úÖ Excellent built-in Strategy Tester for backtesting</li>
            <li>‚úÖ Massive MQL5 marketplace with examples</li>
            <li>‚úÖ Official Python package (<code>MetaTrader5</code>) for integration</li>
            <li>‚úÖ Works directly on FTMO servers</li>
          </ul>

          <h4>cTrader (C#) ‚Äî Strong Alternative</h4>
          <ul>
            <li>‚úÖ Modern C# language (cleaner than MQL)</li>
            <li>‚úÖ Open API for external connections (Python, REST, FIX)</li>
            <li>‚úÖ Free cBots on cTrader Store (including FTMO-specific ones)</li>
            <li>‚ö†Ô∏è Smaller community than MT5</li>
          </ul>

          <h4>Python Integration</h4>
          <p>Python can't trade directly, but works via bridges:</p>
          <ol>
            <li><strong>MT5 Python API</strong> ‚Äî Official package, reads data + places orders (requires MT5 desktop on VPS)</li>
            <li><strong>cTrader Open API</strong> ‚Äî Connect Python via REST/FIX to cTrader</li>
            <li><strong>Bridge approach:</strong> Python generates signals ‚Üí EA/cBot executes trades</li>
          </ol>

          <pre><code><span class="cm"># Architecture for Python-powered FTMO bot</span>
Python Strategy Engine (signals)
    ‚Üí MT5 Python API / cTrader Open API
        ‚Üí FTMO Trading Server<span class="code-label">Architecture</span></code></pre>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        VPS Requirements
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="callout info">üí° A VPS is <strong>essential</strong> for 24/7 bot operation. Location matters ‚Äî get close to FTMO servers.</div>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Provider</th><th>Price/mo</th><th>Location</th><th>Latency to FTMO</th></tr></thead>
              <tbody>
                <tr><td><strong>TradingFXVPS</strong></td><td>$20‚Äì50</td><td>London</td><td style="color: var(--green);">&lt;1ms</td></tr>
                <tr><td><strong>ForexVPS365</strong></td><td>$25‚Äì50</td><td>London</td><td style="color: var(--green);">~1ms</td></tr>
                <tr><td><strong>QuantVPS</strong></td><td>$30‚Äì50</td><td>London/Chicago</td><td style="color: var(--green);">&lt;1ms</td></tr>
                <tr><td><strong>Vultr/DigitalOcean</strong></td><td style="color: var(--green);">$12‚Äì24</td><td>London</td><td>5‚Äì15ms</td></tr>
              </tbody>
            </table>
          </div>
          <p><strong>Specs needed:</strong> 2‚Äì4 GB RAM, 2+ CPU cores, 40‚Äì80 GB SSD, Windows Server (for MT5). <strong>Budget option:</strong> Vultr London at $12/mo ‚Äî good enough for non-<span class="abbr" data-tooltip="High-Frequency Trading">HFT</span> strategies.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Recommended Development Stack
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="tech-stack">
            <div class="tech-tag"><span class="tag-role">Primary</span> MQL5 Expert Advisor on MT5</div>
            <div class="tech-tag"><span class="tag-role">Backtest</span> MT5 Strategy Tester</div>
            <div class="tech-tag"><span class="tag-role">Analysis</span> Python + pandas + numpy</div>
            <div class="tech-tag"><span class="tag-role">Alt Backtest</span> Backtrader / Zipline</div>
            <div class="tech-tag"><span class="tag-role">Charts</span> TradingView</div>
            <div class="tech-tag"><span class="tag-role">Infra</span> London VPS ($12‚Äì50/mo)</div>
            <div class="tech-tag"><span class="tag-role">Monitor</span> Telegram Bot Alerts</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== COMPETITOR COMPARISON ===== -->
  <section class="section" id="ftmo-s4">
    <div class="section-header">
      <span class="section-num">04</span>
      <h2>Competitor Comparison</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Prop Firm Status (Feb 2026) ‚Äî Who's Still Standing
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Firm</th><th>Status</th><th>Notes</th></tr></thead>
              <tbody>
                <tr><td><strong>FTMO</strong></td><td style="color: var(--green); font-weight: 700;">‚úÖ Active</td><td>Industry leader, Czech Republic, $500M+ paid</td></tr>
                <tr><td><strong>FundedNext</strong></td><td style="color: var(--green);">‚úÖ Active</td><td>UAE-based, strong competitor, relaxed rules</td></tr>
                <tr><td><strong>E8 Markets</strong></td><td style="color: var(--green);">‚úÖ Active</td><td>Up to $500K accounts, no min trading days</td></tr>
                <tr><td><strong>FTUK</strong></td><td style="color: var(--green);">‚úÖ Active</td><td>UK-based, scaling to $6.4M</td></tr>
                <tr><td><strong>The 5%ers</strong></td><td style="color: var(--green);">‚úÖ Active</td><td>Israel-based, instant funding option</td></tr>
                <tr><td><strong>Funded Trading Plus</strong></td><td style="color: var(--green);">‚úÖ Active</td><td>UK, up to 100% profit split</td></tr>
                <tr><td><strong>Alpha Capital Group</strong></td><td style="color: var(--green);">‚úÖ Active</td><td>UK, cTrader focus</td></tr>
                <tr><td>MyForexFunds</td><td style="color: var(--red); font-weight: 700;">‚ùå SHUT DOWN</td><td>CFTC closed it ($300M fraud, Sept 2023)</td></tr>
                <tr><td>True Forex Funds</td><td style="color: var(--red); font-weight: 700;">‚ùå SHUT DOWN</td><td>Insolvency, MetaQuotes pulled licenses</td></tr>
                <tr><td>SurgeTrader</td><td style="color: var(--red); font-weight: 700;">‚ùå SHUT DOWN</td><td>Ceased operations 2024</td></tr>
                <tr><td>The Funded Trader</td><td style="color: var(--yellow);">‚ö†Ô∏è Troubled</td><td>Multiple complaints, reputation damaged</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Top EA-Friendly Firms ‚Äî Feature Comparison
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Feature</th><th>FTMO</th><th>FundedNext</th><th>E8 Markets</th><th>FTUK</th><th>The 5%ers</th></tr></thead>
              <tbody>
                <tr><td><strong>Max Account</strong></td><td>$200K ($2M)</td><td>$200K ($4M)</td><td>$500K</td><td>$200K ($6.4M)</td><td>$128K ($4M)</td></tr>
                <tr><td><strong>EAs Allowed</strong></td><td style="color: var(--green);">‚úÖ</td><td style="color: var(--green);">‚úÖ</td><td style="color: var(--green);">‚úÖ</td><td style="color: var(--green);">‚úÖ</td><td style="color: var(--green);">‚úÖ</td></tr>
                <tr><td><strong>Profit Split</strong></td><td>80‚Äì90%</td><td>Up to 90%</td><td style="color: var(--green); font-weight: 700;">Up to 100%</td><td>Up to 80%</td><td>Up to 80%</td></tr>
                <tr><td><strong>Challenge Fee ($100K)</strong></td><td>~‚Ç¨540</td><td>~$549</td><td style="color: var(--green);">~$488</td><td>~$549</td><td>~$450</td></tr>
                <tr><td><strong>Min Trading Days</strong></td><td>4</td><td>5</td><td style="color: var(--green); font-weight: 700;">0 (none!)</td><td>0</td><td>0</td></tr>
                <tr><td><strong>Time Limit</strong></td><td>Unlimited</td><td>30‚Äì60 days</td><td>Unlimited</td><td>Unlimited</td><td>Unlimited</td></tr>
                <tr><td><strong>Profit Target P1</strong></td><td>10%</td><td>10%</td><td style="color: var(--green);">8%</td><td>10%</td><td>8%</td></tr>
                <tr><td><strong>News Trading</strong></td><td style="color: var(--yellow);">Restricted</td><td style="color: var(--green);">Allowed</td><td style="color: var(--green);">Allowed</td><td style="color: var(--green);">Allowed</td><td style="color: var(--green);">Allowed</td></tr>
                <tr><td><strong>Payouts</strong></td><td>Bi-weekly</td><td>Bi-weekly</td><td style="color: var(--green); font-weight: 700;">On demand</td><td>Monthly</td><td>Bi-weekly</td></tr>
              </tbody>
            </table>
          </div>

          <h4>Ranking for Bot Trading (Best ‚Üí Hardest)</h4>
          <div class="strategy-rec">
            <div class="strategy-rec-item">
              <div class="rank">1</div>
              <div>
                <div class="strat-name">E8 Markets</div>
                <div class="strat-detail">No min trading days, 8% target, unlimited time, on-demand payouts, up to 100% split</div>
              </div>
            </div>
            <div class="strategy-rec-item">
              <div class="rank">2</div>
              <div>
                <div class="strat-name">FundedNext</div>
                <div class="strat-detail">Allows everything (news, weekends, EAs), cheaper entry, scales to $4M</div>
              </div>
            </div>
            <div class="strategy-rec-item">
              <div class="rank">3</div>
              <div>
                <div class="strat-name">FTMO</div>
                <div class="strat-detail">Industry standard, most reliable payouts ($500M+ paid), but stricter risk monitoring recently</div>
              </div>
            </div>
          </div>

          <div class="callout info" style="margin-top: 16px;">
            üí° <strong>Recommendation:</strong> Start with <strong>FTMO</strong> (reputation + reliability) or <strong>FundedNext</strong> (more relaxed rules + cheaper). E8 Markets is easiest to pass but newer.
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Known FTMO Bot Strategies (Community)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Commercial EAs (Paid)</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>EA Name</th><th>Price</th><th>Platform</th><th>Notes</th></tr></thead>
              <tbody>
                <tr><td><strong>Forex Flex EA</strong> (FTMO mode)</td><td>$330+</td><td>MT4/MT5</td><td>Has specific prop firm mode</td></tr>
                <tr><td><strong>Phantom EA</strong></td><td>$200‚Äì500</td><td>MT4/MT5</td><td>Claims 80%+ backtest pass rate</td></tr>
                <tr><td><strong>ADAM for FTMO</strong></td><td>$300+</td><td>MT5</td><td>AI/ML based, 17 years development</td></tr>
                <tr><td><strong>WallStreet Forex Robot</strong></td><td>$270+</td><td>MT4/MT5</td><td>Long-established, scalping/trend</td></tr>
              </tbody>
            </table>
          </div>

          <h4>Free / Open Source</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Name</th><th>Source</th><th>Platform</th><th>Notes</th></tr></thead>
              <tbody>
                <tr><td><strong>PROPFIRM BOT</strong></td><td>cTrader Store</td><td>cTrader</td><td style="color: var(--green);">Free, 3,386 installs, preset for US100 on FTMO</td></tr>
                <tr><td><strong>Prop Firm Passing EA</strong></td><td>Forex Factory</td><td>MT5</td><td>Neural network based, free</td></tr>
                <tr><td><strong>FxChartAI Trading EA</strong></td><td>GitHub</td><td>MT5/MQL5</td><td>Open source, AI signals</td></tr>
              </tbody>
            </table>
          </div>

          <div class="callout warning">
            ‚ö†Ô∏è <strong>Don't use widely-shared EAs.</strong> If FTMO detects identical trading patterns from the same EA across many traders, they may deny your account. <strong>Build your own or significantly modify existing ones.</strong>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== THE MATH / ROI ===== -->
  <section class="section" id="ftmo-s5">
    <div class="section-header">
      <span class="section-num">05</span>
      <h2>The Math ‚Äî ROI Analysis</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Investment Required &amp; Expected Attempts
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Upfront Costs ($100K Account)</h4>
          <div class="capital-grid">
            <div class="capital-item">
              <div class="cap-label">Challenge Fee</div>
              <div class="cap-value" style="font-size: 20px;">‚Ç¨540</div>
              <div class="cap-note">~$600 (refunded on pass)</div>
            </div>
            <div class="capital-item">
              <div class="cap-label">VPS Monthly</div>
              <div class="cap-value" style="font-size: 20px;">$20‚Äì50</div>
              <div class="cap-note">London server</div>
            </div>
            <div class="capital-item">
              <div class="cap-label">EA (if buying)</div>
              <div class="cap-value" style="font-size: 20px;">$0‚Äì500</div>
              <div class="cap-note">One-time, or build your own</div>
            </div>
            <div class="capital-item">
              <div class="cap-label">Total Upfront</div>
              <div class="cap-value" style="font-size: 20px; color: var(--accent-light);">~$600‚Äì1,100</div>
              <div class="cap-note">Per attempt</div>
            </div>
          </div>

          <h4 style="margin-top: 24px;">Expected Attempts Before Passing</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Pass Rate</th><th>Expected Attempts</th><th>Total Challenge Cost</th></tr></thead>
              <tbody>
                <tr><td style="color: var(--green);">40% (optimistic bot)</td><td>2‚Äì3</td><td>$1,200‚Äì$1,800</td></tr>
                <tr><td style="color: var(--yellow); font-weight: 700;">25% (realistic bot)</td><td>3‚Äì5</td><td style="font-weight: 700;">$1,800‚Äì$3,000</td></tr>
                <tr><td style="color: var(--red);">10% (average trader)</td><td>8‚Äì12</td><td>$4,800‚Äì$7,200</td></tr>
              </tbody>
            </table>
          </div>
          <p style="font-size: 13px; color: var(--text-muted);">FTMO offers 10‚Äì20% discounts regularly. Failed challenges sometimes get a free retry if you didn't breach drawdown (ended in profit but under target).</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Monthly Income Once Funded
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>$100K Funded Account ‚Äî Monthly Projections</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Monthly Return</th><th>Gross Profit</th><th>Your Share (80%)</th><th>Your Share (90% scaled)</th></tr></thead>
              <tbody>
                <tr><td>2% (conservative)</td><td>$2,000</td><td style="color: var(--green);">$1,600</td><td style="color: var(--green);">$1,800</td></tr>
                <tr style="background: var(--green-bg);">
                  <td style="font-weight: 700;">5% (moderate)</td><td>$5,000</td><td style="color: var(--green); font-weight: 700;">$4,000</td><td style="color: var(--green); font-weight: 700;">$4,500</td>
                </tr>
                <tr><td>8% (aggressive)</td><td>$8,000</td><td style="color: var(--green);">$6,400</td><td style="color: var(--green);">$7,200</td></tr>
                <tr><td>10% (very good)</td><td>$10,000</td><td style="color: var(--green);">$8,000</td><td style="color: var(--green);">$9,000</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Scaling Potential ‚Äî The Big Picture
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Timeline</th><th>Capital</th><th>Monthly Income (5%, 90% split)</th></tr></thead>
              <tbody>
                <tr><td>Start</td><td>$100K</td><td style="color: var(--green);">$4,500/mo</td></tr>
                <tr><td>4 months</td><td>$200K</td><td style="color: var(--green);">$9,000/mo</td></tr>
                <tr><td>8 months</td><td>$400K</td><td style="color: var(--green); font-weight: 700;">$18,000/mo</td></tr>
                <tr><td>12 months</td><td>$500K</td><td style="color: var(--green); font-weight: 700;">$22,500/mo</td></tr>
                <tr style="background: var(--green-bg);">
                  <td style="font-weight: 700;">24 months</td><td style="font-weight: 700;">$800K‚Äì$2M</td><td style="color: var(--green); font-weight: 700;">$36,000‚Äì$90,000/mo</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p><strong>Max allocation:</strong> $400K per trader initially, scalable to <strong>$2,000,000</strong> via Scaling Plan. Strategy: Run 4√ó $100K accounts simultaneously = $400K funded capital.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Break-Even Analysis
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="steps">
            <div class="step">
              <div class="step-number">üí∞</div>
              <div class="step-content">
                <h4>Total invested (3 attempts + VPS)</h4>
                <p>~‚Ç¨1,890 ($600 √ó 3 + $30/mo √ó 3)</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">üìà</div>
              <div class="step-content">
                <h4>First payout (5% profit in first cycle)</h4>
                <p>~$4,000 (80% of $5,000)</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">‚úÖ</div>
              <div class="step-content">
                <h4>Break-even: First payout cycle</h4>
                <p>2‚Äì4 weeks after getting funded. You're profitable from day one of payouts.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== RISK & LEGAL ===== -->
  <section class="section" id="ftmo-s6">
    <div class="section-header">
      <span class="section-num">06</span>
      <h2>Risk &amp; Legal Considerations</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Can FTMO Deny Payouts?
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="callout danger" style="margin-bottom: 16px;">
            ‚ö†Ô∏è <strong>YES ‚Äî and it happens.</strong> FTMO has gotten stricter in 2025‚Äì2026. Here are the real risks:
          </div>
          <ul>
            <li><strong>The 1% Risk Rule (Aug 2025):</strong> FTMO now monitors risk per trade. Traders risking &gt;1‚Äì1.5% report payout delays and warnings. Not in the ToS but enforced via email.</li>
            <li><strong>Trade Holding Duration:</strong> A trader had a $3,800 payout denied for holding 11 days ‚Äî flagged as "inconsistent with sustainable trading."</li>
            <li><strong>Strategy Changes:</strong> Dramatically changing your style between challenge and funded account gets you flagged.</li>
            <li><strong>Duplicate EA Detection:</strong> Identical patterns from third-party EAs across multiple traders ‚Üí account denial.</li>
          </ul>

          <h4>Mitigation Strategies</h4>
          <ol>
            <li>Keep risk at <strong>0.5‚Äì1% per trade</strong> (never exceed 1.5%)</li>
            <li>Be consistent between challenge and funded account</li>
            <li><strong>Build your own EA</strong> (don't use widely-distributed ones)</li>
            <li>Trade regularly (don't go silent for weeks)</li>
            <li>Don't hold trades excessively long</li>
          </ol>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Account Termination &amp; Multiple Accounts
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4 style="color: var(--red);">Instant Termination Triggers</h4>
          <ul>
            <li>Breaching max daily loss (5%)</li>
            <li>Breaching max total loss (10%)</li>
            <li>Using forbidden strategies (martingale, arbitrage, HFT)</li>
            <li>Account inactivity (30+ days)</li>
            <li>Third-party account management</li>
            <li>Running identical strategy detected across many traders</li>
          </ul>

          <h4 style="color: var(--green);">Multiple Accounts ‚Äî Allowed!</h4>
          <ul>
            <li>Unlimited accounts during Challenge/Verification</li>
            <li>Max <strong>$400,000 combined</strong> once funded (Standard)</li>
            <li>Aggressive accounts: max $200K combined</li>
            <li>With Scaling Plan: up to <strong>$2,000,000</strong> total</li>
          </ul>
          <div class="callout info">üí° <strong>Strategy:</strong> Run 4√ó $100K accounts simultaneously = $400K funded. Each can use the same strategy or different ones.</div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Tax Implications in Romania üá∑üá¥
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="callout warning" style="margin-bottom: 16px;">
            ‚ö†Ô∏è FTMO profits are <strong>taxable in Romania</strong>. Payouts are classified as <strong>income from independent activities</strong> (not capital gains ‚Äî you're not trading your own money).
          </div>

          <h4>Tax Structure for Individuals (PersoanƒÉ FizicƒÉ)</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Tax Type</th><th>Rate</th><th>Notes</th></tr></thead>
              <tbody>
                <tr><td><strong>Income Tax</strong></td><td>10%</td><td>On net income</td></tr>
                <tr><td><strong>CAS (Pension)</strong></td><td>25%</td><td>If annual income &gt; 12 min wages (~58,320 RON)</td></tr>
                <tr><td><strong>CASS (Health)</strong></td><td>10%</td><td>Tiered based on income brackets</td></tr>
                <tr style="background: var(--yellow-bg);">
                  <td style="font-weight: 700;">Effective Total</td><td style="font-weight: 700; color: var(--yellow);">~35‚Äì45%</td><td>Combined effective rate</td>
                </tr>
              </tbody>
            </table>
          </div>

          <h4>PFA vs SRL</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Structure</th><th>Tax</th><th>Best For</th></tr></thead>
              <tbody>
                <tr>
                  <td><strong>PFA</strong> (PersoanƒÉ FizicƒÉ AutorizatƒÉ)</td>
                  <td>10% income + CAS + CASS</td>
                  <td>Small amounts (&lt;‚Ç¨2‚Äì3K/month)</td>
                </tr>
                <tr>
                  <td><strong>SRL</strong> (Company)</td>
                  <td>1% micro-enterprise or 16% corp + 8% dividend</td>
                  <td>Larger amounts (&gt;‚Ç¨5K/month)</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="callout danger">
            ‚ö†Ô∏è <strong>ALWAYS declare FTMO income.</strong> FTMO is a Czech company ‚Äî cross-border payments are trackable. File via Declara»õia UnicƒÉ (Form 212) at ANAF. Deadline: May 25 of the following year. For &gt;‚Ç¨5K/month, consult a Romanian tax advisor about SRL structure.
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        FTMO Success Statistics ‚Äî Real Numbers
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Metric</th><th>Value</th><th>Source</th></tr></thead>
              <tbody>
                <tr><td>Challenge Pass Rate (P1)</td><td style="color: var(--yellow);">~8‚Äì10%</td><td>FTMO official</td></tr>
                <tr><td>Verification Pass Rate (P2)</td><td>~40% of P1 passers</td><td>Community estimates</td></tr>
                <tr><td>Overall Pass Rate (both phases)</td><td style="color: var(--red);">~3‚Äì5%</td><td>Calculated</td></tr>
                <tr><td>Funded ‚Üí Actually Paid</td><td>~20% of funded</td><td>TradeLikeMaster</td></tr>
                <tr><td style="font-weight: 700;">True Success Rate</td><td style="color: var(--red); font-weight: 700;">~1.6‚Äì2%</td><td>Calculated</td></tr>
              </tbody>
            </table>
          </div>

          <h4>FTMO Revenue &amp; Legitimacy</h4>
          <ul>
            <li><strong>$500M+</strong> paid in rewards worldwide (as of 2026)</li>
            <li><strong>$300,000+/day</strong> paid out</li>
            <li><strong>3.5M+ customers</strong> worldwide</li>
            <li>Average payout: <strong>~$3,386</strong></li>
            <li>Average payout processing: <strong>8 hours</strong></li>
            <li>Trustpilot: <strong>4.8/5</strong></li>
          </ul>

          <div class="callout success">
            ‚úÖ <strong>FTMO is legitimate.</strong> Operating since 2015, Czech Republic, regulated, $500M+ paid out. The low pass rate is a feature, not a bug ‚Äî it's how their business model works.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== STEP-BY-STEP ROADMAP ===== -->
  <section class="section" id="ftmo-s7">
    <div class="section-header">
      <span class="section-num">07</span>
      <h2>Step-by-Step Roadmap</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Phase 0: Learning &amp; Preparation (1‚Äì2 weeks)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="steps">
            <div class="step">
              <div class="step-number">1</div>
              <div class="step-content">
                <h4>Sign up for FTMO Free Trial (14 days, unlimited retries)</h4>
                <p>Free, no payment required. Same rules as real challenge. Test your strategy in real conditions. <a href="https://ftmo.com/en/ftmo-free-trial/" target="_blank">ftmo.com/free-trial</a></p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">2</div>
              <div class="step-content">
                <h4>Choose your platform: MetaTrader 5</h4>
                <p>Largest community, best backtester, most EA examples. Alternative: cTrader if you prefer C#/API access.</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">3</div>
              <div class="step-content">
                <h4>Learn MQL5 basics</h4>
                <p>MQL5.com documentation + YouTube tutorials. Focus on: order execution, risk management functions, indicator integration.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 1: Strategy Development (2‚Äì4 weeks)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="steps">
            <div class="step">
              <div class="step-number">4</div>
              <div class="step-content">
                <h4>Choose your strategy: London Session Breakout</h4>
                <p>Simplest to code, proven results. Pairs: EURUSD, GBPUSD. Timeframe: M15. Risk: 0.75% per trade. R:R: 1:2 minimum.</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">5</div>
              <div class="step-content">
                <h4>Code the EA with FTMO-specific features</h4>
                <p>Daily P&L tracker (stop at -3%), overall drawdown monitor, max trades/day limiter (3), session time filter, Friday closing rule, news avoidance, spread filter, trailing stop after 1R profit.</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">6</div>
              <div class="step-content">
                <h4>Backtest extensively</h4>
                <p>MT5 Strategy Tester with tick data. Minimum 2 years (2024‚Äì2025). Test with FTMO constraints (daily drawdown, total drawdown, min 4 days). Target: &gt;50% win rate with 1:2 R:R.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 2: Demo Testing (2‚Äì4 weeks)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="steps">
            <div class="step">
              <div class="step-number">7</div>
              <div class="step-content">
                <h4>Run on FTMO Free Trial</h4>
                <p>Set up VPS (London). Install MT5 + EA. Run 2‚Äì4 weeks. Track: daily P&L, max drawdown, trade count. <strong>Goal: "Pass" 2‚Äì3 free trials in a row.</strong></p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">8</div>
              <div class="step-content">
                <h4>Optimize based on results</h4>
                <p>Adjust SL/TP levels. Fine-tune session timing. Adjust risk per trade. Test on different pairs.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 3: Live Challenge (4‚Äì8 weeks)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="steps">
            <div class="step">
              <div class="step-number">9</div>
              <div class="step-content">
                <h4>Start with $50K or $100K challenge</h4>
                <p>Recommended first: <strong>$50K Standard 2-Step</strong> (‚Ç¨345). Lower fee = less risk while proving the bot. Use 2-Step (easier 5% daily loss limit).</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">10</div>
              <div class="step-content">
                <h4>Let the bot run ‚Äî Phase 1 (4‚Äì6 weeks)</h4>
                <p>Monitor daily but don't intervene unless critical. Be prepared for drawdown periods. Trust the backtested strategy.</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">11</div>
              <div class="step-content">
                <h4>Pass Phase 2 ‚Äî Verification (3‚Äì4 weeks)</h4>
                <p>Same strategy, same risk. Only need 5% now. Reduce risk to 0.5% per trade ‚Äî be extra cautious.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 4: Funded &amp; Scaling (Ongoing)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="steps">
            <div class="step">
              <div class="step-number">12</div>
              <div class="step-content">
                <h4>Funded: Keep consistent, collect payouts</h4>
                <p>Same strategy (consistency matters!). Target 3‚Äì5% per bi-weekly cycle. Keep risk at 0.5‚Äì1%. Withdraw profits bi-weekly.</p>
              </div>
            </div>
            <div class="step">
              <div class="step-number">13</div>
              <div class="step-content">
                <h4>Scale up</h4>
                <p>After 1st payout: start 2nd challenge. Goal: 2√ó $100K ($200K funded). After 4 months: Scaling Plan (+25% balance). Long-term: $400K ‚Üí $2M.</p>
              </div>
            </div>
          </div>

          <h4 style="margin-top: 24px;">Full Timeline Summary</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Week</th><th>Activity</th></tr></thead>
              <tbody>
                <tr><td>1‚Äì2</td><td>Learn MQL5, design strategy, set up Free Trial</td></tr>
                <tr><td>3‚Äì6</td><td>Code EA, backtest, optimize</td></tr>
                <tr><td>7‚Äì10</td><td>Run on FTMO Free Trial (demo)</td></tr>
                <tr style="background: var(--accent-glow);">
                  <td style="font-weight: 700;">11‚Äì16</td><td style="font-weight: 700;">First real challenge (Phase 1)</td>
                </tr>
                <tr style="background: var(--accent-glow);">
                  <td style="font-weight: 700;">17‚Äì20</td><td style="font-weight: 700;">Phase 2 (Verification)</td>
                </tr>
                <tr style="background: var(--green-bg);">
                  <td style="font-weight: 700; color: var(--green);">21+</td><td style="font-weight: 700; color: var(--green);">Funded account ‚Äî earning money üí∞</td>
                </tr>
                <tr><td>25+</td><td>Start 2nd challenge to scale</td></tr>
                <tr style="background: var(--green-bg);">
                  <td style="font-weight: 700; color: var(--green);">35+</td><td style="color: var(--green);">$200‚Äì400K funded, $9‚Äì18K/month</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Pre-Launch Checklist ‚úÖ
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p style="color: var(--text-secondary); margin-bottom: 16px;">Before going live with real money, your bot must pass ALL of these on demo:</p>
          <ul>
            <li>‚úÖ Achieves 10%+ profit in simulated challenge</li>
            <li>‚úÖ Never breaches 5% daily loss limit</li>
            <li>‚úÖ Never breaches 10% total loss limit</li>
            <li>‚úÖ Trades on minimum 4 different days</li>
            <li>‚úÖ Risk per trade never exceeds 1%</li>
            <li>‚úÖ Maximum 3‚Äì5 trades per day</li>
            <li>‚úÖ Does not trade during high-impact news</li>
            <li>‚úÖ Closes all positions before weekend</li>
            <li>‚úÖ Handles spread widening gracefully</li>
            <li>‚úÖ Works on FTMO's specific spread/commission structure</li>
            <li>‚úÖ Successfully passed 3+ consecutive simulated challenges</li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <!-- FTMO FOOTNOTE -->
  <div class="footnote">
    <p>FTMO research compiled February 2026. Prop firm rules change frequently ‚Äî always verify current rules on <a href="https://ftmo.com" target="_blank">ftmo.com</a> before starting a challenge.</p>
    <p style="margin-top: 6px;">Sources: FTMO official documentation, Forex Factory, Reddit (r/Forex, r/FTMO_Forex_Trading), cTrader Store, MQL5 community, TradeLikeMaster data, ArbitrageScanner.io, Trustpilot reviews.</p>
  </div>

</div><!-- end FTMO tab -->

<!-- ==================== FULL RESEARCH TAB ==================== -->
<div class="tab-content" id="tab-full">

  <!-- TABLE OF CONTENTS -->
  <nav class="toc">
    <h2>üìë Table of Contents</h2>
    <ol class="toc-list">
      <li><a href="#s1"><span class="toc-num">01</span> Trading Strategies That Actually Work</a></li>
      <li><a href="#s2"><span class="toc-num">02</span> Technical Infrastructure</a></li>
      <li><a href="#s3"><span class="toc-num">03</span> Data &amp; Signals</a></li>
      <li><a href="#s4"><span class="toc-num">04</span> Risk Management (Critical)</a></li>
      <li><a href="#s5"><span class="toc-num">05</span> Backtesting &amp; Validation</a></li>
      <li><a href="#s6"><span class="toc-num">06</span> Real Numbers</a></li>
      <li><a href="#s7"><span class="toc-num">07</span> What Actually Makes Money in 2025‚Äì2026</a></li>
      <li><a href="#s8"><span class="toc-num">08</span> Specific Tools &amp; APIs</a></li>
      <li><a href="#s9"><span class="toc-num">09</span> Case Studies</a></li>
      <li><a href="#s10"><span class="toc-num">10</span> Step-by-Step Roadmap</a></li>
      <li><a href="#appendix"><span class="toc-num">A‚ÄìC</span> Appendices (Original)</a></li>
    </ol>
    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
      <h2 style="color: var(--accent-light);">üöÄ Deep Dive Modules</h2>
      <ol class="toc-list">
        <li><a href="#mod-a"><span class="toc-num">A</span> üêç Complete Python Trading Bot Tutorial</a></li>
        <li><a href="#mod-b"><span class="toc-num">B</span> üìä MetaTrader 5 Bot Development (FTMO)</a></li>
        <li><a href="#mod-c"><span class="toc-num">C</span> üß† Advanced Strategies ‚Äî Deep Dive with Code</a></li>
        <li><a href="#mod-d"><span class="toc-num">D</span> üè¶ FTMO Deep Dive ‚Äî Expanded</a></li>
        <li><a href="#mod-e"><span class="toc-num">E</span> ‚öôÔ∏è Real-World Operations</a></li>
        <li><a href="#mod-f"><span class="toc-num">F</span> üìö Resources &amp; Links</a></li>
      </ol>
    </div>
    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
      <h2 style="color: var(--green);">üìö Implementation Guides</h2>
      <ol class="toc-list">
        <li><a href="#a1"><span class="toc-num">A.1</span> Environment Setup</a></li>
        <li><a href="#a2"><span class="toc-num">A.2</span> Exchange Connector (CCXT)</a></li>
        <li><a href="#a3"><span class="toc-num">A.3</span> Strategy Implementations</a></li>
        <li><a href="#a4"><span class="toc-num">A.4</span> Risk Manager</a></li>
        <li><a href="#a5"><span class="toc-num">A.5</span> Data Collection &amp; Storage</a></li>
        <li><a href="#a6"><span class="toc-num">A.6</span> Backtesting Framework</a></li>
        <li><a href="#a7"><span class="toc-num">A.7</span> Telegram Notification Bot</a></li>
        <li><a href="#a8"><span class="toc-num">A.8</span> Deployment Guide (Docker, VPS, Monitoring)</a></li>
        <li><a href="#b1"><span class="toc-num">B.1</span> London Breakout EA (MQL5)</a></li>
        <li><a href="#b2"><span class="toc-num">B.2</span> Python-to-MT5 Bridge</a></li>
      </ol>
    </div>
  </nav>

  <!-- ===== SECTION 1: STRATEGIES ===== -->
  <section class="section" id="s1">
    <div class="section-header">
      <span class="section-num">01</span>
      <h2>Trading Strategies That Actually Work</h2>
    </div>

    <h3>Strategy Tier List ‚Äî Retail Viability</h3>

    <!-- TIER 1 -->
    <div class="tier-label green">üü¢ TIER 1 ‚Äî Realistic for Retail Traders</div>

    <div class="strategy-card green-card">
      <h4>Grid Trading</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">1‚Äì5% monthly</span>
        <span class="meta-tag capital">Min $1K‚Äì$5K</span>
        <span class="meta-tag complexity-low">Low Complexity</span>
      </div>
      <p><strong>How it works:</strong> Places buy/sell orders at fixed intervals around a price range. Profits from oscillation within a range.</p>
      <p><strong>Best for:</strong> Sideways/ranging markets (which is most of the time).</p>
      <p><strong>Risk:</strong> If the asset trends strongly downward, you're left holding bags. If it trends up, you miss the full move.</p>
      <div class="insight">üí° <strong>Real data:</strong> Bitsgap reports average 11% 30-day return (Nov 2025), but likely cherry-picked. Realistic long-term: 2‚Äì5% monthly during ranging, with losing months during trends.</div>
    </div>

    <div class="strategy-card green-card">
      <h4><span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> (Dollar Cost Averaging) Bots</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">2‚Äì4% monthly</span>
        <span class="meta-tag capital">Min $1K‚Äì$3K</span>
        <span class="meta-tag complexity-low">Low‚ÄìMed Complexity</span>
      </div>
      <p><strong>How it works:</strong> Buys at regular intervals, uses "safety orders" (buying more as price drops) to lower average entry. Takes profit at small % gains.</p>
      <p><strong>Best for:</strong> Volatile assets with mean-reversion tendency.</p>
      <p><strong>Real data:</strong> 3Commas documented 12.8% net profit over multiple months with 100% deal completion rate.</p>
      <div class="warning">‚ö†Ô∏è <strong>Critical risk:</strong> In a sustained bear market, safety orders keep buying the dip all the way down. This is essentially Martingale-lite. The Luna crash destroyed every <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> bot running on it.</div>
    </div>

    <div class="strategy-card green-card">
      <h4>Funding Rate Arbitrage</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">15‚Äì30% APY</span>
        <span class="meta-tag capital">Min $5K‚Äì$10K</span>
        <span class="meta-tag complexity-med">Medium Complexity</span>
      </div>
      <p><strong>How it works:</strong> Go long spot + short perpetual futures on the same asset. Collect funding payments when rates are positive (most of the time in bull markets).</p>
      <p><strong>Edge:</strong> Genuinely accessible to retail. Binance, OKX, and Crypto.com all have built-in funding rate arb bots.</p>
      <p><strong>Real data:</strong> ArbitrageScanner.io client earned 0.45% daily (funding fees averaging 0.15% every 8 hours) plus convergence profit.</p>
      <div class="insight">üí° <strong>Key insight:</strong> Delta-neutral strategy ‚Äî minimal directional risk. 8‚Äì15% annually from institutions, 15‚Äì30% APY during high-sentiment bull markets.</div>
      <div class="warning">‚ö†Ô∏è Funding rates can flip negative. Exchange risk (your money is on the exchange). Liquidation risk if not properly hedged.</div>
    </div>

    <div class="strategy-card green-card">
      <h4>Momentum / Trend Following</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">20‚Äì50% annually</span>
        <span class="meta-tag capital">Min $2K+</span>
        <span class="meta-tag complexity-med">Medium Complexity</span>
      </div>
      <p><strong>How it works:</strong> Identifies assets trending up (or down) and rides the trend. Uses indicators like moving averages, <span class="abbr" data-tooltip="Relative Strength Index">RSI</span>, <span class="abbr" data-tooltip="Moving Average Convergence Divergence">MACD</span>, or pure price action.</p>
      <p><strong>Best for:</strong> Strong trending markets (crypto bull/bear runs). Works best on higher timeframes (4H, 1D).</p>
      <div class="insight">üí° <strong>Combo edge:</strong> Volatility-filtered momentum (trading only during high-vol regimes) shows more stable equity curves than raw momentum.</div>
    </div>

    <div class="strategy-card green-card">
      <h4>Mean Reversion</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">10‚Äì30% annually</span>
        <span class="meta-tag capital">Min $2K+</span>
        <span class="meta-tag complexity-med">Medium Complexity</span>
      </div>
      <p><strong>How it works:</strong> Buy when price is oversold (below the mean), sell when overbought. Uses Bollinger Bands, <span class="abbr" data-tooltip="Relative Strength Index">RSI</span>, Z-scores.</p>
      <p><strong>Best for:</strong> Ranging markets, pairs trading. Works well for crypto-to-crypto pairs (e.g., ETH/BTC).</p>
      <div class="warning">‚ö†Ô∏è <strong>Critical danger:</strong> In crypto, what looks like "mean reversion" can be a death spiral. Coins can go to zero. Always use stop losses.</div>
    </div>

    <!-- TIER 2 -->
    <div class="tier-label yellow" style="margin-top: 36px;">üü° TIER 2 ‚Äî Possible for Technical Retail Traders</div>

    <div class="strategy-card yellow-card">
      <h4><span class="abbr" data-tooltip="Centralized Exchange">CEX</span>-to-<span class="abbr" data-tooltip="Centralized Exchange">CEX</span> Arbitrage</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">0.5‚Äì2% monthly</span>
        <span class="meta-tag capital">Min $10K+</span>
        <span class="meta-tag complexity-high">High Complexity</span>
      </div>
      <p><strong>How it works:</strong> Buy on exchange A where price is lower, sell on exchange B where price is higher. Requires pre-funded accounts on both sides.</p>
      <p><strong>Current state (2025‚Äì2026):</strong> Most obvious arb opportunities are captured in &lt;100ms by institutional bots. Retail can still find opportunities on smaller/newer exchanges or during high-volatility events.</p>
      <div class="warning">‚ö†Ô∏è Transfer times, withdrawal fees, and speed competition make this increasingly difficult. Margins shrinking rapidly.</div>
    </div>

    <div class="strategy-card yellow-card">
      <h4>Triangular Arbitrage</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">0.01‚Äì0.1% per trade</span>
        <span class="meta-tag capital">Min $5K+</span>
        <span class="meta-tag complexity-high">High Complexity</span>
      </div>
      <p><strong>How it works:</strong> Exploit price discrepancies between three trading pairs on the SAME exchange (e.g., BTC‚ÜíETH‚ÜíUSDT‚ÜíBTC, ending with more BTC).</p>
      <p><strong>Implementation:</strong> Use WebSocket feeds to monitor all pair prices simultaneously. Calculate cross-rates in real-time. Execute only when profit &gt; 3√ó expected fees.</p>
      <div class="warning">‚ö†Ô∏è Requires very fast execution. Opportunities last fractions of a second. After fees, many "profitable" cycles are actually losses.</div>
    </div>

    <div class="strategy-card yellow-card">
      <h4>Sentiment-Based Trading</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">10‚Äì40% annually</span>
        <span class="meta-tag capital">Min $2K+</span>
        <span class="meta-tag complexity-high">High Complexity</span>
      </div>
      <p><strong>How it works:</strong> Scrape Twitter/X, Reddit, news sources. Run <span class="abbr" data-tooltip="Natural Language Processing">NLP</span>/sentiment analysis. Trade based on sentiment shifts.</p>
      <p><strong>Key insight:</strong> Sentiment is a leading indicator for altcoins (especially memecoins) but a lagging indicator for Bitcoin. Best used as a FILTER on top of other strategies.</p>
      <div class="insight">üí° <strong>2025‚Äì2026 edge:</strong> <span class="abbr" data-tooltip="Large Language Model">LLM</span>-powered sentiment analysis (using GPT/Claude to understand nuance) is the cutting edge. Raw keyword counting is obsolete.</div>
    </div>

    <!-- TIER 3 -->
    <div class="tier-label red" style="margin-top: 36px;">üî¥ TIER 3 ‚Äî Mostly Institutional / Very Advanced</div>

    <div class="strategy-card red-card">
      <h4>Market Making</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">~0.2% of volume</span>
        <span class="meta-tag capital">Min $10K‚Äì$50K+</span>
        <span class="meta-tag complexity-high">Very High Complexity</span>
      </div>
      <p><strong>How it works:</strong> Continuously place bid and ask orders, profit from the spread. Provide liquidity.</p>
      <p><strong>Why it's hard for retail:</strong> Institutional market makers (Jump Trading, Wintermute) have co-located servers with &lt;1ms latency. Retail bots operate at 100‚Äì500ms ‚Äî you WILL get picked off.</p>
      <p><strong>Where retail CAN market-make:</strong> Small/illiquid pairs on <span class="abbr" data-tooltip="Decentralized Exchange">DEX</span>es, new token launches, prediction markets (Polymarket).</p>
      <div class="insight">üí° <strong>Tool:</strong> Hummingbot is the go-to open-source market making framework. $2B+ in trade volume generated by users.</div>
    </div>

    <div class="strategy-card red-card">
      <h4><span class="abbr" data-tooltip="Maximal Extractable Value ‚Äî profit extracted by reordering/inserting transactions in a block">MEV</span> / Sandwich Attacks</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">Declining rapidly</span>
        <span class="meta-tag capital">$10K+ infra</span>
        <span class="meta-tag complexity-high">Extreme Complexity</span>
      </div>
      <p><strong>Ethereum:</strong> Average net profit per sandwich attack dropped to <strong>$3</strong> in 2025. Monthly extraction fell from ~$10M (late 2024) to ~$2.5M (Oct 2025).</p>
      <p><strong>Solana:</strong> Sandwich bots made $370‚Äì500M over 16 months. Still more profitable but increasingly competitive.</p>
      <div class="warning">‚ö†Ô∏è Requires deep blockchain knowledge, custom infrastructure, block builder relationships. Ethical and legal gray area. <strong>Not realistic for retail on Ethereum.</strong></div>
    </div>

    <div class="strategy-card red-card">
      <h4>Flash Loan Arbitrage</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">Negligible for retail</span>
        <span class="meta-tag capital">$100K+ infra</span>
        <span class="meta-tag complexity-high">Extreme Complexity</span>
      </div>
      <p><strong>How it works:</strong> Borrow massive amounts (no collateral), execute arbitrage across <span class="abbr" data-tooltip="Decentralized Exchange">DEX</span>es, repay in same transaction.</p>
      <p><strong>Reality:</strong> "Yoink" earned $2.65M across 59 blocks ‚Äî but required infrastructure worth hundreds of thousands. Most flash loan tutorials are scams or produce negligible returns.</p>
      <div class="warning">‚ö†Ô∏è <strong>Not realistic for retail as a primary strategy.</strong> Fun to learn from an educational perspective only.</div>
    </div>

    <div class="strategy-card red-card">
      <h4>Liquidation Sniping</h4>
      <div class="strategy-meta">
        <span class="meta-tag returns">Variable</span>
        <span class="meta-tag capital">Deep DeFi knowledge</span>
        <span class="meta-tag complexity-high">Extreme Complexity</span>
      </div>
      <p><strong>How it works:</strong> Monitor lending protocols (Aave, Compound) for positions about to be liquidated. Buy the discounted collateral.</p>
      <div class="warning">‚ö†Ô∏è Same <span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span> competition. Automated by sophisticated bots. <strong>Not realistic for retail.</strong></div>
    </div>
  </section>

  <!-- ===== SECTION 2: TECHNICAL INFRASTRUCTURE ===== -->
  <section class="section" id="s2">
    <div class="section-header">
      <span class="section-num">02</span>
      <h2>Technical Infrastructure</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Programming Language Comparison
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>üêç Python ‚Äî START HERE</h4>
          <p>Fastest development time. Best ML/AI ecosystem (pandas, numpy, scikit-learn, pytorch). CCXT supports 100+ exchanges. Freqtrade, Jesse, OctoBot all use Python. Good enough performance for 95% of retail strategies.</p>
          <p><strong>When to use:</strong> Everything except <span class="abbr" data-tooltip="High-Frequency Trading">HFT</span>. Strategy development, backtesting, ML signal generation, medium-frequency trading (&gt;1 second).</p>

          <h4>üì¶ TypeScript/JavaScript ‚Äî GOOD FOR FE DEVS</h4>
          <p>Great async/event-driven model (perfect for WebSocket streams). <code>ethers.js</code> and <code>web3.js</code> are the best DeFi libraries. CCXT works in JS too. Within a few ms of Rust for network-bound operations.</p>
          <p><strong>When to use:</strong> DeFi bots, WebSocket-heavy apps, Telegram/Discord integrations, leveraging existing skills.</p>

          <h4>ü¶Ä Rust ‚Äî FOR SERIOUS PERFORMANCE</h4>
          <p>Near C++ performance with memory safety. No garbage collector (deterministic latency). Best choice for Solana development. Growing in trading systems (Databento uses Rust in production).</p>
          <p><strong>When to use:</strong> <span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span> bots, Solana programs, high-frequency strategies where microseconds matter.</p>

          <h4>‚ö° C++ ‚Äî OVERKILL FOR RETAIL</h4>
          <p>Maximum performance, zero overhead. Industry standard for <span class="abbr" data-tooltip="High-Frequency Trading">HFT</span>. For crypto retail trading, the network is your bottleneck, not your code.</p>

          <div class="callout info">
            üí° <strong>The Real Insight:</strong> For crypto trading, network latency is almost always the bottleneck, not code execution speed. A Python bot on an AWS Tokyo VPS will beat a C++ bot running from your laptop. Choose Python or TypeScript for development speed, optimize infrastructure first.
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Latency Requirements by Strategy
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead>
                <tr><th>Strategy</th><th>Acceptable Latency</th><th>Language</th></tr>
              </thead>
              <tbody>
                <tr><td><span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> / Grid</td><td>Seconds to minutes</td><td>Python, TypeScript</td></tr>
                <tr><td>Momentum / Mean Reversion</td><td>100ms ‚Äì 1s</td><td>Python, TypeScript</td></tr>
                <tr><td>Funding Rate Arbitrage</td><td>1‚Äì10 seconds</td><td>Python, TypeScript</td></tr>
                <tr><td><span class="abbr" data-tooltip="Centralized Exchange">CEX</span> Arbitrage</td><td>10‚Äì100ms</td><td>TypeScript, Rust</td></tr>
                <tr><td>Market Making</td><td>1‚Äì50ms</td><td>Rust, C++, Java</td></tr>
                <tr><td><span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span> / Sandwich</td><td>&lt;10ms</td><td>Rust</td></tr>
                <tr><td><span class="abbr" data-tooltip="High-Frequency Trading">HFT</span></td><td>&lt;1ms</td><td>C++</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Best Exchanges &amp; Their APIs
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Tier 1 ‚Äî Primary Exchanges</h4>

          <p><strong>Binance</strong> ‚Äî Largest by volume. Spot: 0.10% maker/taker. Futures: 0.02%/0.05%. Best median latency from AWS Osaka. Restricted in some regions.</p>

          <p><strong>Bybit</strong> ‚Äî Futures maker 0.01%(!)/taker 0.055%. Very competitive for derivatives. Up to 100x leverage.</p>

          <p><strong>OKX</strong> ‚Äî Spot: 0.08%/0.10%. VIP tiers can reach -0.005% maker (they PAY you). Built-in Grid, <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span>, Arb bots.</p>

          <p><strong>dYdX (v4)</strong> ‚Äî Decentralized perpetuals (Cosmos-based). Very competitive fees, often 0% maker. No KYC.</p>

          <h4>Tier 2 ‚Äî Specialized</h4>

          <p><strong>Uniswap / <span class="abbr" data-tooltip="Decentralized Exchange">DEX</span>es</strong> ‚Äî For DeFi strategies, token launches, <span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span>. Gas costs can make strategies unprofitable on Ethereum.</p>

          <p><strong>Hyperliquid</strong> ‚Äî Rising star in 2025‚Äì2026 for perp <span class="abbr" data-tooltip="Decentralized Exchange">DEX</span> trading. No gas fees, order book-based, good API.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        VPS &amp; Server Positioning
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="callout info">üí° <strong>Golden Rule:</strong> Deploy your bot as close to the exchange's servers as possible.</div>

          <h4>Binance Optimal Setup (Hummingbot 2023 Study)</h4>
          <ol>
            <li><strong>Best:</strong> AWS Osaka (ap-northeast-3) ‚Äî lowest median latency</li>
            <li><strong>Second:</strong> AWS Tokyo (ap-northeast-1)</li>
            <li><strong>Third:</strong> AWS Seoul (ap-northeast-2)</li>
            <li><strong>Avoid:</strong> US/EU regions (2‚Äì5x higher latency)</li>
          </ol>

          <h4>Practical Setup</h4>
          <ul>
            <li><strong>AWS t3.small/medium:</strong> ~$15‚Äì30/month ‚Äî sufficient for most bots</li>
            <li><strong>DigitalOcean/Vultr Singapore or Tokyo:</strong> $5‚Äì20/month ‚Äî budget option</li>
          </ul>

          <h4>The Truth About Latency</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Setup</th><th>Round Trip</th></tr></thead>
              <tbody>
                <tr><td>Home (Europe ‚Üí Binance)</td><td>~200‚Äì400ms</td></tr>
                <tr><td>AWS Tokyo</td><td>~40‚Äì80ms</td></tr>
                <tr><td>AWS Osaka</td><td>~30‚Äì60ms</td></tr>
                <tr><td>Co-located institutional</td><td>&lt;1ms</td></tr>
              </tbody>
            </table>
          </div>
          <p>For grid/<span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span>/funding arb, 200ms is fine. Only optimize for latency if doing arbitrage or market making.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        WebSocket vs REST
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Feature</th><th>REST</th><th>WebSocket</th></tr></thead>
              <tbody>
                <tr><td>Data freshness</td><td>Poll-based (stale)</td><td>Real-time push</td></tr>
                <tr><td>Latency</td><td>Higher (HTTP overhead)</td><td>Lower (persistent)</td></tr>
                <tr><td>Rate limits</td><td>Strict per-minute</td><td>More generous</td></tr>
                <tr><td>Use case</td><td>Order placement, queries</td><td>Market data, order book</td></tr>
              </tbody>
            </table>
          </div>
          <div class="callout success">‚úÖ <strong>Best practice:</strong> Use WebSocket for ALL market data feeds. Use REST only for order placement. CCXT Pro supports WebSocket: <code>watchOrderBook()</code>, <code>watchTrades()</code>, <code>watchTicker()</code>.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 3: DATA & SIGNALS ===== -->
  <section class="section" id="s3">
    <div class="section-header">
      <span class="section-num">03</span>
      <h2>Data &amp; Signals</h2>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        On-Chain Data (Whale/Smart Money Tracking)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Key Signals</h4>
          <ul>
            <li><strong>Exchange inflows:</strong> Large deposits ‚Üí potential sell pressure</li>
            <li><strong>Exchange outflows:</strong> Large withdrawals ‚Üí accumulation (bullish)</li>
            <li><strong>Whale wallet tracking:</strong> Follow known smart money wallets</li>
            <li><strong>Stablecoin flows:</strong> Large USDT/USDC movements to exchanges ‚Üí buying incoming</li>
          </ul>

          <h4>Tools</h4>
          <ul>
            <li><strong>Nansen:</strong> Smart Money labels, wallet tracking ($150/month)</li>
            <li><strong>Arkham Intelligence:</strong> Entity labeling, on-chain tracking (free tier)</li>
            <li><strong>Whale Alert:</strong> Free API for large transaction monitoring</li>
            <li><strong>Dune Analytics:</strong> Custom SQL queries on blockchain data (free)</li>
            <li><strong>Glassnode:</strong> On-chain metrics (exchange flows, MVRV, SOPR)</li>
          </ul>

          <h4>Implementation Approach</h4>
          <ol>
            <li>Use Whale Alert API for real-time large transaction alerts</li>
            <li>Cross-reference with Nansen's smart money labels</li>
            <li>Track exchange inflow/outflow trends (Glassnode API)</li>
            <li>Build scoring system: positive signal (outflows) + negative signal (inflows)</li>
            <li>Use as a FILTER on your primary strategy, not standalone</li>
          </ol>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Order Book Analysis
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Key Metrics</h4>
          <ul>
            <li><strong>Order Book Imbalance (<span class="abbr" data-tooltip="Order Book Imbalance ‚Äî ratio of bid to ask volume">OBI</span>):</strong> &gt;1.5 = buying pressure, &lt;0.5 = selling pressure. Short-term predictive power.</li>
            <li><strong>Bid-Ask Spread:</strong> Wider = less liquid, potential for market making</li>
            <li><strong>Large order detection:</strong> Iceberg orders, whale walls</li>
          </ul>

          <h4>Volume Profile / <span class="abbr" data-tooltip="Volume Weighted Average Price">VWAP</span></h4>
          <div class="formula">VWAP = Œ£(Price √ó Volume) / Œ£(Volume)</div>
          <p>Use as dynamic support/resistance and fair value reference. <strong>Strategy:</strong> Buy below <span class="abbr" data-tooltip="Volume Weighted Average Price">VWAP</span>, sell above during ranging markets.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Funding Rates, Open Interest, Liquidation Levels
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Funding Rates</h4>
          <p>Source: CoinGlass. Very high positive funding (&gt;0.1%) = market overheated. Negative funding = fear, potential bottom.</p>

          <h4>Open Interest</h4>
          <ul>
            <li><strong>Rising OI + Rising Price:</strong> Strong trend, new money entering</li>
            <li><strong>Rising OI + Falling Price:</strong> Bearish pressure building</li>
            <li><strong>Falling OI:</strong> Positions closing, trend exhaustion</li>
          </ul>

          <h4>Liquidation Levels</h4>
          <p>Large liquidation clusters act as magnets ‚Äî price tends to sweep liquidations. Anticipate cascades and trade in the direction of the cascade.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        ML/AI Models That Actually Work
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>‚úÖ What Works (Proven)</h4>
          <ol>
            <li><strong>LightGBM / XGBoost:</strong> 54‚Äì59% accuracy on crypto price direction. Features: momentum, volume, volatility, order book imbalance. Even 55% is profitable with proper risk management.</li>
            <li><strong>Deep Reinforcement Learning (<span class="abbr" data-tooltip="Deep Reinforcement Learning">DRL</span>):</strong> Consistent profits even after transaction costs for execution optimization. Frameworks: Stable Baselines3, RLlib.</li>
            <li><strong>Ensemble Methods:</strong> Combine multiple weak signals. Random Forest, Gradient Boosting ensembles reduce false signals.</li>
            <li><strong><span class="abbr" data-tooltip="Natural Language Processing">NLP</span> / Sentiment:</strong> VADER (fast), BART MNLI (better), fine-tuned BERT, or <span class="abbr" data-tooltip="Large Language Model">LLM</span>-based analysis ‚Äî emerging edge in 2025‚Äì2026.</li>
          </ol>

          <h4>‚ùå What DOESN'T Work</h4>
          <ul>
            <li>Pure LSTM/RNN for price prediction ‚Äî easy to overfit</li>
            <li>Complex neural networks on small datasets</li>
            <li>Indicator-based ML (feeding <span class="abbr" data-tooltip="Relative Strength Index">RSI</span>, <span class="abbr" data-tooltip="Moving Average Convergence Divergence">MACD</span> into NNs)</li>
            <li>Any model showing &gt;70% backtest accuracy ‚Äî almost certainly overfit</li>
            <li>Single-feature models</li>
          </ul>

          <div class="callout danger">‚ö†Ô∏è <strong>Avoiding Overfitting (#1 Problem):</strong> Use TimeSeriesSplit (never random split). Walk-forward validation. Limit features to &lt;20. If backtest Sharpe &gt; 3, you're probably overfit.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 4: RISK MANAGEMENT ===== -->
  <section class="section" id="s4">
    <div class="section-header">
      <span class="section-num">04</span>
      <h2>Risk Management <span style="color: var(--red);">(CRITICAL)</span></h2>
    </div>

    <div class="callout danger" style="margin-bottom: 24px;">
      ‚ö†Ô∏è <strong>This section is more important than any strategy.</strong> Every blown account was caused by poor risk management, not a bad strategy.
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Position Sizing
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Fixed Fractional (Best for Beginners)</h4>
          <p>Risk 1‚Äì2% of capital per trade. Example: $10K account, 1% risk = $100 max loss. If stop loss is 5%, position size = $100 / 5% = $2,000.</p>

          <h4>Kelly Criterion (Optimal but Aggressive)</h4>
          <div class="formula">K% = W ‚àí [(1‚àíW) / R]</div>
          <p>W = Win probability, R = Win/loss ratio. Example: 55% win rate, 1.5:1 R:R ‚Üí K% = 25%.</p>
          <div class="callout warning">‚ö†Ô∏è <strong>CRITICAL: Use Quarter Kelly.</strong> Divide result by 4. Full Kelly assumes perfect edge estimation ‚Äî it never is. In the example: 25% / 4 = <strong>6.25%</strong> per trade.</div>

          <h4>For Crypto Specifically</h4>
          <ul>
            <li>Never risk more than 1‚Äì2% per trade</li>
            <li>Total portfolio exposure: Max 20‚Äì30% at any time</li>
            <li>No single strategy gets more than 30% of total capital</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Stop Losses &amp; Exit Management
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <ul>
            <li><strong>Fixed Stop:</strong> 2‚Äì5% from entry. Always use stops. No exceptions.</li>
            <li><strong>Trailing Stop:</strong> Trail at 3√ó <span class="abbr" data-tooltip="Average True Range ‚Äî measure of price volatility">ATR</span> below highest price. Locks in profits during trends.</li>
            <li><strong>Dynamic Risk:</strong> Use <span class="abbr" data-tooltip="Average True Range">ATR</span> to size stops. Higher vol = wider stops + smaller positions.</li>
            <li><strong>Time-Based:</strong> Close dead trades after X hours. Capital is a resource.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Drawdown Protection &amp; Circuit Breakers
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <ul>
            <li><strong>Daily drawdown limit:</strong> 3‚Äì5% of capital ‚Üí STOP TRADING. Resume next day.</li>
            <li><strong>Strategy drawdown:</strong> 10‚Äì15% ‚Üí pause strategy. Review and re-evaluate.</li>
            <li><strong>Portfolio circuit breaker:</strong> 15‚Äì20% total ‚Üí halt ALL bots. Manual intervention required.</li>
          </ul>

          <pre><code><span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">RiskLimits</span>:
    <span class="var">max_position_size_pct</span>: <span class="cls">float</span> = <span class="num">10.0</span>   <span class="cm"># Max % per position</span>
    <span class="var">stop_loss_pct</span>: <span class="cls">float</span> = <span class="num">2.0</span>            <span class="cm"># Default stop loss</span>
    <span class="var">take_profit_pct</span>: <span class="cls">float</span> = <span class="num">5.0</span>         <span class="cm"># Default take profit</span>
    <span class="var">risk_reward_ratio</span>: <span class="cls">float</span> = <span class="num">2.5</span>       <span class="cm"># Minimum R:R ratio</span>
    <span class="var">max_consecutive_losses</span>: <span class="cls">int</span> = <span class="num">3</span>      <span class="cm"># Pause after 3 losses</span>
    <span class="var">max_strategy_drawdown_pct</span>: <span class="cls">float</span> = <span class="num">10.0</span>
    <span class="var">max_daily_loss_pct</span>: <span class="cls">float</span> = <span class="num">5.0</span>
    <span class="var">max_portfolio_drawdown_pct</span>: <span class="cls">float</span> = <span class="num">20.0</span><span class="code-label">Python</span></code></pre>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Black Swan Protection
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <ol>
            <li><strong>Always have stop losses</strong> ‚Äî never remove them</li>
            <li><strong>Keep 50‚Äì70% in stablecoins/cash</strong> ‚Äî dry powder + protection</li>
            <li><strong>Diversify across strategies</strong> ‚Äî momentum + mean reversion + funding arb</li>
            <li><strong>Diversify across exchanges</strong> ‚Äî FTX collapse taught everyone this</li>
            <li><strong>Never use high leverage</strong> ‚Äî 2‚Äì3x maximum</li>
            <li><strong>Hardware kill switch</strong> ‚Äî flatten all positions instantly</li>
            <li><strong>Monitor exchange health</strong> ‚Äî watch for withdrawal delays</li>
          </ol>

          <div class="callout info">üí° <strong>Correlation risk:</strong> Don't run 5 strategies that all go long crypto ‚Äî that's one strategy at 5x. Aim for uncorrelated: long/short mix, different timeframes, different assets.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 5: BACKTESTING ===== -->
  <section class="section" id="s5">
    <div class="section-header">
      <span class="section-num">05</span>
      <h2>Backtesting &amp; Validation</h2>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Framework Comparison
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Framework</th><th>Speed</th><th>Best For</th><th>Stars</th></tr></thead>
              <tbody>
                <tr><td><strong>VectorBT</strong></td><td>‚ö° Blazing fast</td><td>Rapid prototyping, optimization</td><td>Active dev</td></tr>
                <tr><td><strong>Backtrader</strong></td><td>üê¢ Slower</td><td>Realistic backtesting ‚Üí live</td><td>Most popular</td></tr>
                <tr><td><strong>QuantConnect</strong></td><td>‚òÅÔ∏è Cloud-based</td><td>Multi-asset, institutional-grade</td><td>$24/mo</td></tr>
                <tr><td><strong>Jesse</strong></td><td>üîÑ Medium</td><td>Crypto-specific research</td><td>Clean API</td></tr>
                <tr><td><strong>Freqtrade</strong></td><td>üîÑ Medium</td><td>All-in-one crypto bot</td><td>30K+ ‚≠ê</td></tr>
              </tbody>
            </table>
          </div>

          <div class="callout success">‚úÖ <strong>Recommended workflow:</strong> Screen ideas (VectorBT) ‚Üí Validate winners (Backtrader/Freqtrade) ‚Üí Paper trade ‚Üí Live small ‚Üí Scale over 3‚Äì6 months.</div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Walk-Forward Analysis (WFA)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>Standard backtesting = studying answers before the test. <span class="abbr" data-tooltip="Walk-Forward Analysis ‚Äî optimize on in-sample, test on out-of-sample, roll forward">WFA</span> = the actual exam.</p>

          <h4>How It Works</h4>
          <ol>
            <li>Split data: e.g., 12 months optimize, 3 months test</li>
            <li>Optimize on in-sample data (find best parameters)</li>
            <li>Test those parameters on out-of-sample (next 3 months)</li>
            <li>Roll forward, repeat with 8‚Äì10 windows minimum</li>
            <li>Final performance = concatenation of all out-of-sample results</li>
          </ol>

          <div class="callout info">üí° <strong>Golden test:</strong> If walk-forward results are within 50% of in-sample results, the strategy likely has a real edge. If much worse, you're overfit.</div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Avoiding Overfitting ‚Äî Red Flags &amp; Best Practices
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>üö© Red Flags</h4>
          <ul>
            <li>Backtest Sharpe ratio &gt; 3.0</li>
            <li>Win rate &gt; 70%</li>
            <li>Strategy has &gt; 10 parameters</li>
            <li>Only works on one specific asset or time period</li>
          </ul>

          <h4>‚úÖ Best Practices</h4>
          <ol>
            <li>Minimize parameters: 3‚Äì5 tunable max</li>
            <li>Simple strategies that work &gt; complex ones that overfit</li>
            <li>Test across assets AND time periods</li>
            <li>Include realistic fees (0.1%/trade) and slippage</li>
            <li>Paper trade 1‚Äì3 months before going live</li>
          </ol>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 6: REAL NUMBERS ===== -->
  <section class="section" id="s6">
    <div class="section-header">
      <span class="section-num">06</span>
      <h2>Real Numbers</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Minimum Capital by Strategy
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Strategy</th><th>Minimum</th><th>Recommended</th><th>Notes</th></tr></thead>
              <tbody>
                <tr><td><span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> Bot</td><td>$500</td><td>$1K‚Äì3K</td><td>Need room for safety orders</td></tr>
                <tr><td>Grid Trading</td><td>$500</td><td>$2K‚Äì5K</td><td>More levels = more capital</td></tr>
                <tr><td>Momentum/Mean Rev.</td><td>$1K</td><td>$3K‚Äì5K</td><td>Need to handle drawdowns</td></tr>
                <tr><td>Funding Rate Arb</td><td>$5K</td><td>$10K‚Äì20K</td><td>Split spot + futures</td></tr>
                <tr><td><span class="abbr" data-tooltip="Centralized Exchange">CEX</span>‚Äì<span class="abbr" data-tooltip="Centralized Exchange">CEX</span> Arb</td><td>$5K</td><td>$10K‚Äì50K</td><td>Pre-fund multiple exchanges</td></tr>
                <tr><td>Market Making</td><td>$10K</td><td>$50K+</td><td>Significant inventory needed</td></tr>
                <tr><td><span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span>/Flash Loan</td><td>$1K + gas</td><td>$10K+</td><td>Infra costs matter more</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Realistic Monthly Returns
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Strategy</th><th>Bull</th><th>Sideways</th><th>Bear</th><th>Long-term Avg</th></tr></thead>
              <tbody>
                <tr><td>Grid Trading</td><td>5‚Äì15%</td><td>2‚Äì5%</td><td>-5 to -20%</td><td>2‚Äì5%</td></tr>
                <tr><td><span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> Bot</td><td>5‚Äì20%</td><td>1‚Äì4%</td><td>-10 to -30%*</td><td>2‚Äì4%</td></tr>
                <tr><td>Momentum</td><td>10‚Äì30%</td><td>-5 to +5%</td><td>5‚Äì15% (short)</td><td>2‚Äì5%</td></tr>
                <tr><td>Mean Reversion</td><td>3‚Äì8%</td><td>5‚Äì10%</td><td>3‚Äì8%</td><td>3‚Äì6%</td></tr>
                <tr><td>Funding Arb</td><td>3‚Äì5%</td><td>1‚Äì2%</td><td>0.5‚Äì1%</td><td>1‚Äì2.5%</td></tr>
                <tr><td>Market Making</td><td>2‚Äì5%</td><td>2‚Äì5%</td><td>2‚Äì5%</td><td>2‚Äì4%</td></tr>
              </tbody>
            </table>
          </div>
          <p style="font-size: 13px; color: var(--text-muted);">*DCA bots can lock capital in losing positions during bear markets</p>

          <div class="callout danger">
            ‚ö†Ô∏è <strong>Reality check:</strong> Average algo strategy lifespan: 18‚Äì24 months. 38% of retail algo traders have significant losses in year 1. Only top 5% of AI agents exceed 40% annual returns.
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Fee Impact Analysis
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4><span class="abbr" data-tooltip="Centralized Exchange">CEX</span> Fees (Per Round Trip)</h4>
          <ul>
            <li><strong>Binance spot:</strong> 0.20% (0.10% each side)</li>
            <li><strong>Binance futures:</strong> 0.07% (0.02% maker + 0.05% taker)</li>
            <li><strong>Bybit futures:</strong> 0.065% (0.01% maker + 0.055% taker)</li>
          </ul>

          <h4>How Fees Kill Strategies</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Frequency</th><th>Monthly Fee Drag</th></tr></thead>
              <tbody>
                <tr><td>Daily (1 trade/day)</td><td>6%</td></tr>
                <tr><td>Hourly</td><td style="color: var(--red); font-weight: 700;">144% üíÄ</td></tr>
                <tr><td>Grid bot (30/day)</td><td style="color: var(--red); font-weight: 700;">180% üíÄ</td></tr>
              </tbody>
            </table>
          </div>

          <div class="callout warning">‚ö†Ô∏è <strong>You MUST use limit orders (maker fees)</strong> and trade on exchanges with maker rebates. Bybit VIP futures maker at 0% ‚Äî this is why HF traders seek VIP status.</div>

          <h4>DeFi Gas Costs</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Chain</th><th>Swap Cost</th></tr></thead>
              <tbody>
                <tr><td>Ethereum</td><td>$2‚Äì50+</td></tr>
                <tr><td>Solana</td><td>&lt;$0.01</td></tr>
                <tr><td>BSC</td><td>$0.10‚Äì0.50</td></tr>
                <tr><td>Arbitrum/Base</td><td>$0.05‚Äì0.50</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Tax Implications
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>üá∫üá∏ USA</h4>
          <p>Short-term gains (&lt;1 year): 10‚Äì37%. Bot trading = mostly short-term ‚Üí 30%+ effective rate. EVERY trade is a taxable event. 1000 trades/month = 1000 tax events.</p>

          <h4>üá∑üá¥ Romania</h4>
          <p><strong>10% flat tax</strong> on capital gains from crypto. Must declare profits annually. Favorable compared to US/Western EU.</p>

          <h4>Strategy for Bot Traders</h4>
          <ol>
            <li>Track everything ‚Äî use API exports</li>
            <li>Use tax software (Koinly, CoinTracker)</li>
            <li>Consider trading through an entity (SRL)</li>
            <li>Factor tax into returns: 20% annual ‚Üí ~13‚Äì14% after US taxes, ~18% after Romanian taxes</li>
          </ol>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 7: WHAT MAKES MONEY ===== -->
  <section class="section" id="s7">
    <div class="section-header">
      <span class="section-num">07</span>
      <h2>What Actually Makes Money in 2025‚Äì2026</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Strategy Saturation Analysis
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4 style="color: var(--red);">üî¥ Saturated (Declining Edge)</h4>
          <ul>
            <li>Simple <span class="abbr" data-tooltip="Centralized Exchange">CEX</span>-to-<span class="abbr" data-tooltip="Centralized Exchange">CEX</span> arb ‚Äî captured in &lt;100ms by institutions</li>
            <li>Ethereum <span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span>/Sandwich ‚Äî avg profit $3/attack</li>
            <li>Simple indicator strategies (<span class="abbr" data-tooltip="Relative Strength Index">RSI</span> oversold ‚Üí buy) ‚Äî everyone does this</li>
            <li>Public bot strategies (YouTube) ‚Äî already crowded</li>
          </ul>

          <h4 style="color: var(--yellow);">üü° Competitive (Still Profitable, Getting Harder)</h4>
          <ul>
            <li>Funding rate arb ‚Äî exchange-built bots increasing competition</li>
            <li>Grid trading on major pairs ‚Äî margins shrinking</li>
            <li>Solana <span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span> ‚Äî $370‚Äì500M in 16 months, getting competitive</li>
            <li>Market making on mid-cap tokens</li>
          </ul>

          <h4 style="color: var(--green);">üü¢ Still Has Edge</h4>
          <ul>
            <li><strong>Sentiment strategies using <span class="abbr" data-tooltip="Large Language Model">LLM</span>s</strong> ‚Äî cutting edge, not yet commoditized</li>
            <li><strong>Cross-chain arbitrage</strong> ‚Äî bridges create latency ‚Üí opportunities</li>
            <li><strong>New chain/<span class="abbr" data-tooltip="Decentralized Exchange">DEX</span> launch sniping</strong> ‚Äî first-mover advantage</li>
            <li><strong>Prediction market arb</strong> ‚Äî Polymarket, ~$40M extracted (Apr '24‚ÄìApr '25)</li>
            <li><strong>Multi-signal ensembles</strong> ‚Äî on-chain + sentiment + technical</li>
            <li><strong>AI agent-powered trading</strong> ‚Äî <span class="abbr" data-tooltip="Large Language Model">LLM</span>-based reasoning (nascent)</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Retail vs Institutional Edge
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Where Institutions Win (Don't Compete)</h4>
          <ul>
            <li>Speed (co-located, FPGA, custom networking)</li>
            <li>Capital (absorb larger losses, run more strategies)</li>
            <li>Data (proprietary feeds, satellite imagery)</li>
            <li>Latency-sensitive strategies (<span class="abbr" data-tooltip="High-Frequency Trading">HFT</span>, simple arb)</li>
          </ul>

          <h4>Where Retail CAN Win</h4>
          <ul>
            <li><strong>Flexibility:</strong> Trade illiquid tokens too small for institutions</li>
            <li><strong>No bureaucracy:</strong> Deploy new strategies in hours, not months</li>
            <li><strong>DeFi native:</strong> Many institutions struggle with DeFi complexity</li>
            <li><strong>Long-tail markets:</strong> Small-cap tokens, new chains, prediction markets</li>
            <li><strong>Novel signals:</strong> GitHub commits, Discord activity, etc.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Legal Considerations
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>‚úÖ Legal</h4>
          <ul>
            <li>Automated trading on <span class="abbr" data-tooltip="Centralized Exchange">CEX</span>es</li>
            <li>Grid/<span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span>/momentum bots</li>
            <li>Market making (if not manipulative)</li>
            <li>Cross-exchange arbitrage</li>
          </ul>

          <h4>‚ö†Ô∏è Gray Area</h4>
          <ul>
            <li><span class="abbr" data-tooltip="Maximal Extractable Value">MEV</span>/sandwich attacks ‚Äî ethically questionable</li>
            <li>Front-running on <span class="abbr" data-tooltip="Decentralized Exchange">DEX</span>es ‚Äî scrutinized by regulators</li>
            <li>Wash trading (even unintentional via bot loops)</li>
          </ul>

          <h4>üö´ Illegal</h4>
          <ul>
            <li>Market manipulation (spoofing, layering)</li>
            <li>Insider trading (increasingly prosecuted in crypto)</li>
          </ul>

          <div class="callout info">üí° <strong>Regulatory trends (2025‚Äì2026):</strong> MiCA (EU) taking effect, SEBI (India) new framework, SEC (US) increasing scrutiny. Always comply with KYC/AML.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 8: TOOLS & APIs ===== -->
  <section class="section" id="s8">
    <div class="section-header">
      <span class="section-num">08</span>
      <h2>Specific Tools &amp; APIs</h2>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Core Libraries (CCXT, web3, ethers)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>CCXT ‚Äî Unified Exchange Library</h4>
          <p>Supports 100+ exchanges. Python, JS/TS, PHP, C#. REST + WebSocket (CCXT Pro).</p>

          <pre><code><span class="kw">import</span> ccxt

exchange = ccxt.<span class="fn">binance</span>({
    <span class="str">'apiKey'</span>: <span class="str">'YOUR_KEY'</span>,
    <span class="str">'secret'</span>: <span class="str">'YOUR_SECRET'</span>,
    <span class="str">'options'</span>: {<span class="str">'defaultType'</span>: <span class="str">'future'</span>}
})

<span class="cm"># Fetch orderbook</span>
orderbook = exchange.<span class="fn">fetch_order_book</span>(<span class="str">'BTC/USDT'</span>)

<span class="cm"># Place order</span>
order = exchange.<span class="fn">create_limit_buy_order</span>(<span class="str">'BTC/USDT'</span>, <span class="num">0.001</span>, <span class="num">40000</span>)<span class="code-label">Python</span></code></pre>

          <pre><code><span class="cm"># WebSocket (CCXT Pro)</span>
orderbook = <span class="kw">await</span> exchange.<span class="fn">watch_order_book</span>(<span class="str">'BTC/USDT'</span>)
trades = <span class="kw">await</span> exchange.<span class="fn">watch_trades</span>(<span class="str">'BTC/USDT'</span>)<span class="code-label">Python</span></code></pre>

          <div class="callout success">‚úÖ <strong>Performance tip:</strong> Install <code>orjson</code> for 3‚Äì10x faster JSON parsing (critical for WebSocket). THE standard for multi-exchange bots.</div>

          <h4>web3.py / ethers.js</h4>
          <p>For Ethereum/EVM chain interaction. <code>web3.py</code> for Python, <code>ethers.js v6</code> for JS/TS (async-first, cleaner API). Use for Uniswap swaps, Aave interactions, smart contracts.</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Signal &amp; Alert Tools
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <ul>
            <li><strong>TradingView Webhooks:</strong> Alert ‚Üí Webhook ‚Üí Your server ‚Üí Execute trade. Pro required ($14.95/month).</li>
            <li><strong>Telegram Bot Alerts:</strong> Send notifications, portfolio updates, error alerts. Receive commands (pause, resume, status). Essential.</li>
            <li><strong>LunarCrush API:</strong> Social/sentiment data for 4000+ crypto assets. Galaxy Score, AltRank.</li>
            <li><strong>CoinGlass API:</strong> Funding rates, open interest, liquidation data. Essential for funding arb.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Cloud Infrastructure &amp; Key APIs
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Cloud</h4>
          <ul>
            <li><strong>AWS:</strong> ap-northeast-3 (Osaka) for Binance. t3.small $15/mo, t3.medium $30/mo.</li>
            <li><strong>Budget:</strong> DigitalOcean/Vultr Singapore/Tokyo, $5‚Äì20/mo.</li>
            <li><strong>Low Latency:</strong> QuantVPS ($20‚Äì100/mo).</li>
          </ul>

          <h4>Key APIs</h4>
          <pre><code><span class="cm">Exchange APIs (via CCXT):</span>
  Binance, Bybit, OKX, dYdX ‚Äî REST + WebSocket

<span class="cm">On-Chain:</span>
  Alchemy/Infura ‚Äî Ethereum RPC
  Helius ‚Äî Solana RPC
  The Graph ‚Äî Indexed blockchain data

<span class="cm">Data:</span>
  CoinGlass API ‚Äî Derivatives data
  Whale Alert API ‚Äî Large transactions
  LunarCrush API ‚Äî Social metrics
  CryptoPanic API ‚Äî News aggregation

<span class="cm">Execution:</span>
  Flashbots ‚Äî MEV protection / private txs
  Jito ‚Äî Solana MEV / tips<span class="code-label">Reference</span></code></pre>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 9: CASE STUDIES ===== -->
  <section class="section" id="s9">
    <div class="section-header">
      <span class="section-num">09</span>
      <h2>Case Studies</h2>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Open Source Bots Worth Studying
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Bot</th><th>Language</th><th>Focus</th><th>Stars</th><th>Best For</th></tr></thead>
              <tbody>
                <tr><td><strong>Freqtrade</strong></td><td>Python</td><td>Full bot framework</td><td>30K+ ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td><td>Beginners ‚Üí intermediate, all-in-one</td></tr>
                <tr><td><strong>Hummingbot</strong></td><td>Python</td><td>Market making + arb</td><td>8K+ ‚≠ê‚≠ê‚≠ê‚≠ê</td><td>Market making, providing liquidity</td></tr>
                <tr><td><strong>Jesse</strong></td><td>Python</td><td>Research-focused</td><td>‚≠ê‚≠ê‚≠ê</td><td>Strategy research &amp; development</td></tr>
                <tr><td><strong>OctoBot</strong></td><td>Python</td><td>Multi-strategy</td><td>‚≠ê‚≠ê‚≠ê</td><td>GUI-based, non-coders</td></tr>
                <tr><td><strong>hftbacktest</strong></td><td>Rust+Py</td><td>HFT backtesting</td><td>‚≠ê‚≠ê‚≠ê‚≠ê</td><td>Serious market making / HFT</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Documented Successes
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <ul>
            <li><strong>Alpha Arena (Nov 2025):</strong> AI trading bots competed with real money. GPT-5 and Claude Sonnet 4.5 finished profitable. Proved <span class="abbr" data-tooltip="Large Language Model">LLM</span>-powered trading agents can generate real returns.</li>
            <li><strong>3Commas <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> Bot:</strong> 12.8% net profit, 100% deal completion across 36 deals. BTC/USDT pair.</li>
            <li><strong>Hummingbot User:</strong> One user generated $2B in cumulative volume. Profit from spread capture and exchange rebates.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Famous Bot Failures (Lessons Learned)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="callout danger" style="margin-bottom: 12px;">
            <strong>FTX Collapse (Nov 2022):</strong> Thousands of bots lost ALL funds on FTX. <strong>Lesson:</strong> NEVER keep all funds on one exchange. Counterparty risk is real.
          </div>
          <div class="callout warning" style="margin-bottom: 12px;">
            <strong>Flash Crash Bots:</strong> Bots amplifying crashes via cascading sell orders. <strong>Lesson:</strong> Circuit breakers and position limits are essential.
          </div>
          <div class="callout danger" style="margin-bottom: 12px;">
            <strong>Luna/UST Crash (May 2022):</strong> <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> bots bought Luna from $80 to $0.0001. <strong>Lesson:</strong> <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> without stop losses on altcoins is suicidal. Always have a max drawdown cutoff.
          </div>
          <div class="callout warning">
            <strong>Overfit Bot Syndrome:</strong> Most common failure ‚Äî perfect backtest, loses money live. <strong>Lesson:</strong> Walk-forward analysis, paper trading, gradual scaling.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== SECTION 10: ROADMAP ===== -->
  <section class="section" id="s10">
    <div class="section-header">
      <span class="section-num">10</span>
      <h2>Step-by-Step Roadmap</h2>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Phase 1: Foundation (Weeks 1‚Äì4)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Week 1‚Äì2: Education &amp; Setup</h4>
          <ol>
            <li>Learn market microstructure: order books, maker/taker, spread, slippage</li>
            <li>Set up development environment</li>
            <li>Create exchange accounts + API keys (read-only first!)</li>
            <li>Fund with small amount ($500‚Äì1000)</li>
          </ol>

          <pre><code><span class="cm"># Create virtual environment</span>
python -m venv trading_bot
<span class="kw">source</span> trading_bot/bin/activate

<span class="cm"># Install core libraries</span>
pip install ccxt pandas numpy vectorbt freqtrade
pip install python-telegram-bot aiohttp orjson<span class="code-label">Bash</span></code></pre>

          <h4>Week 3‚Äì4: Data Collection &amp; First Strategy</h4>
          <ol>
            <li>Download historical data (CCXT ‚Üí SQLite/CSV, 2+ years)</li>
            <li>Implement SMA Crossover (learning the mechanics)</li>
            <li>Backtest with VectorBT</li>
          </ol>

          <pre><code><span class="kw">import</span> vectorbt <span class="kw">as</span> vbt
<span class="kw">import</span> pandas <span class="kw">as</span> pd

<span class="cm"># Download data</span>
data = vbt.YFData.<span class="fn">download</span>(<span class="str">'BTC-USD'</span>, period=<span class="str">'2y'</span>, interval=<span class="str">'1h'</span>)
price = data.<span class="fn">get</span>(<span class="str">'Close'</span>)

<span class="cm"># Define entries/exits</span>
fast_ma = vbt.MA.<span class="fn">run</span>(price, <span class="num">20</span>)
slow_ma = vbt.MA.<span class="fn">run</span>(price, <span class="num">50</span>)
entries = fast_ma.ma_crossed_above(slow_ma)
exits = fast_ma.ma_crossed_below(slow_ma)

<span class="cm"># Backtest</span>
pf = vbt.Portfolio.<span class="fn">from_signals</span>(price, entries, exits, fees=<span class="num">0.001</span>)
<span class="fn">print</span>(pf.<span class="fn">stats</span>())<span class="code-label">Python</span></code></pre>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 2: Strategy Development (Weeks 5‚Äì12)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Week 5‚Äì6: Pick Your Strategy</h4>
          <ul>
            <li><strong>$1K‚Äì3K:</strong> Start with <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span> bot on Freqtrade</li>
            <li><strong>$5K‚Äì10K:</strong> Funding rate arb OR grid trading</li>
            <li><strong>$10K+:</strong> Multi-strategy (funding arb + grid + momentum)</li>
          </ul>

          <h4>Week 7‚Äì8: Build &amp; Backtest</h4>
          <ol>
            <li>Code strategy logic with proper risk management</li>
            <li>Add logging and Telegram alerts</li>
            <li>Test across 2020‚Äì2025, include fees/slippage</li>
            <li>Calculate: Sharpe ratio, max drawdown, win rate, profit factor</li>
          </ol>

          <h4>Week 9‚Äì10: Walk-Forward Validation</h4>
          <p>Split 70/30. Optimize on in-sample, test out-of-sample. Repeat with rolling windows. <strong>Proceed only if out-of-sample is within 50% of in-sample.</strong></p>

          <h4>Week 11‚Äì12: Paper Trading</h4>
          <p>Minimum 2‚Äì4 weeks. Verify orders execute, risk management works, bot handles errors (network drops, API errors).</p>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 3: Live Trading ‚Äî Small (Months 3‚Äì6)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Month 3: Go Live</h4>
          <ol>
            <li>Deploy to VPS (AWS/DigitalOcean)</li>
            <li><strong>Start with 10% of intended capital</strong></li>
            <li>Monitor obsessively for first week</li>
            <li>Set up: Telegram alerts, daily P&L, error alerting, auto-shutdown on drawdown</li>
          </ol>

          <h4>Month 4‚Äì5: Evaluate &amp; Iterate</h4>
          <p>Compare live vs backtest. Identify discrepancies. Adjust parameters. Do NOT increase position sizes yet.</p>

          <h4>Month 6: Decision Point</h4>
          <div class="callout info">
            üí° <strong>Profitable?</strong> ‚Üí Phase 4. <strong>Not profitable?</strong> ‚Üí Back to Phase 2. <strong>Average:</strong> 40‚Äì60% of strategies that pass backtesting fail live. This is normal.
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 4: Scaling (Months 6‚Äì12)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Capital Allocation</h4>
          <ul>
            <li>30‚Äì40% stablecoins (dry powder + safety)</li>
            <li>20‚Äì30% primary strategy</li>
            <li>10‚Äì20% secondary strategy</li>
            <li>10‚Äì20% manual/discretionary</li>
          </ul>

          <h4>Scaling Rules</h4>
          <ul>
            <li>Increase position size by 25% every 4 profitable weeks</li>
            <li>Decrease by 50% after 2 consecutive losing weeks</li>
            <li>Never &gt;30% of total capital in one strategy</li>
          </ul>

          <h4>Multi-Strategy Mix</h4>
          <ul>
            <li><strong>Bull market:</strong> More momentum, reduce grid</li>
            <li><strong>Sideways:</strong> More grid, more mean reversion</li>
            <li><strong>Bear market:</strong> More funding arb, reduce <span class="abbr" data-tooltip="Dollar Cost Averaging">DCA</span></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Phase 5: Long-term (Year 2+)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Continuous Improvement</h4>
          <ul>
            <li>Strategies have 18‚Äì24 month lifespan ‚Äî ALWAYS research new ones</li>
            <li>Re-optimize quarterly (walk-forward)</li>
            <li>Monitor for edge decay (declining Sharpe, increasing drawdowns)</li>
          </ul>

          <h4>Revenue Targets (Realistic)</h4>
          <div class="table-wrapper">
            <table>
              <thead><tr><th>Year</th><th>Target</th></tr></thead>
              <tbody>
                <tr><td>Year 1</td><td>Don't lose money. Break-even is success.</td></tr>
                <tr><td>Year 2</td><td>15‚Äì30% annual returns on active capital</td></tr>
                <tr><td>Year 3+</td><td>20‚Äì50% with compounding + multiple strategies</td></tr>
              </tbody>
            </table>
          </div>
          <p><strong>Capital target:</strong> Get to $20K‚Äì50K deployed capital for meaningful income.</p>

          <div class="callout info">
            üí° <strong>The Meta-Strategy:</strong> The real edge isn't any single strategy. It's the PROCESS: Generate ideas ‚Üí Backtest (VectorBT) ‚Üí Validate (walk-forward) ‚Üí Paper trade (2‚Äì4 weeks) ‚Üí Live small (1‚Äì3 months) ‚Üí Scale what works, kill what doesn't ‚Üí <strong>Repeat forever.</strong>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== APPENDICES ===== -->
  <section class="section" id="appendix">
    <div class="section-header">
      <span class="section-num">A‚ÄìC</span>
      <h2>Appendices</h2>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Appendix A: Essential Resources
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>üìö Books</h4>
          <ul>
            <li>"Advances in Financial Machine Learning" ‚Äî Marcos Lopez de Prado</li>
            <li>"Algorithmic Trading" ‚Äî Ernest Chan</li>
            <li>"Trading and Exchanges" ‚Äî Larry Harris</li>
            <li>"Quantitative Trading" ‚Äî Ernest Chan</li>
          </ul>

          <h4>üë• Communities</h4>
          <ul>
            <li><strong>r/algotrading</strong> ‚Äî Best Reddit community for algo trading</li>
            <li><strong>Hummingbot Discord</strong> ‚Äî Market making community</li>
            <li><strong>Freqtrade Discord</strong> ‚Äî Bot development community</li>
            <li><strong>QuantConnect Forum</strong> ‚Äî Algo trading discussions</li>
          </ul>

          <h4>üìä Data Sources</h4>
          <ul>
            <li><strong>CoinGlass</strong> ‚Äî Funding rates, liquidations, OI</li>
            <li><strong>Glassnode</strong> ‚Äî On-chain analytics</li>
            <li><strong>TradingView</strong> ‚Äî Charting and alerts</li>
            <li><strong>Binance Vision</strong> ‚Äî Free historical data downloads</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Appendix B: Quick Reference ‚Äî What to Build First
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <h4>Recommended Stack: TypeScript + Python Hybrid</h4>
          <pre><code><span class="cm">Strategy Research & Backtesting:</span> Python (VectorBT, Freqtrade)
<span class="cm">Live Bot Core:</span>              TypeScript (you're fast in it)
<span class="cm">DeFi Integration:</span>           TypeScript (ethers.js)
<span class="cm">ML Signals:</span>                 Python (scikit-learn, LightGBM)
<span class="cm">Infrastructure:</span>             AWS Tokyo VPS, Docker
<span class="cm">Monitoring:</span>                 Telegram bot, custom dashboard<span class="code-label">Stack</span></code></pre>

          <h4>First Bot: Funding Rate Arbitrage</h4>
          <ol>
            <li>Monitor funding rates across exchanges (CoinGlass API)</li>
            <li>When rate is abnormally high (&gt;0.05%): Buy spot + Short perp</li>
            <li>Collect funding every 8 hours</li>
            <li>Close when rates normalize</li>
            <li>Expected: 15‚Äì25% APY with minimal directional risk</li>
          </ol>

          <h4>Second Bot: Grid Trading</h4>
          <ol>
            <li>Define price range (e.g., BTC $80K‚Äì$100K)</li>
            <li>Place buy orders at every $500 below current price</li>
            <li>Place sell orders at every $500 above</li>
            <li>Profit from oscillation</li>
          </ol>

          <h4>Third Bot (Advanced): <span class="abbr" data-tooltip="Large Language Model">LLM</span>-Powered Sentiment + Momentum</h4>
          <ol>
            <li>Scrape Twitter/X using <span class="abbr" data-tooltip="Large Language Model">LLM</span> for sentiment</li>
            <li>Combine with momentum signals (price, volume)</li>
            <li>Only trade when sentiment AND momentum align</li>
            <li>Cutting edge in 2025‚Äì2026</li>
          </ol>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Appendix C: The Brutal Truth (Full)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <ol>
            <li><strong>Most trading bots lose money.</strong> 70% of retail traders who lose manually will lose with bots ‚Äî just faster.</li>
            <li><strong>The bot doesn't create the edge.</strong> It executes YOUR edge. No edge = faster money burning.</li>
            <li><strong>Fees are the silent killer.</strong> 30 trades/day √ó 0.1% = 90% monthly in fees.</li>
            <li><strong>Your competition is serious.</strong> Jump Trading, Wintermute, Citadel ‚Äî billions on infrastructure.</li>
            <li><strong>Where you CAN win:</strong> Small markets, novel signals, flexibility, DeFi complexity.</li>
            <li><strong>The real money in crypto:</strong> Most wealth was created by holding, not trading.</li>
            <li><strong>Budget for losses.</strong> Plan to lose $1K‚Äì2K as tuition.</li>
            <li><strong>Time investment:</strong> 6‚Äì12 months of serious work. Not a weekend project.</li>
            <li><strong>The process IS the product.</strong> The ability to develop, test, and iterate is what makes you profitable over time.</li>
            <li><strong>Start small. Stay small until you PROVE profitability.</strong> Then scale gradually.</li>
          </ol>
        </div>
      </div>
    </div>
  </section>

  <!-- ============================================================ -->
  <!-- ========== MODULE A: COMPLETE PYTHON TRADING BOT ============ -->
  <!-- ============================================================ -->
  <div class="mega-section-header" id="mod-a">
    <span class="section-num">MODULE A</span>
    <h2>üêç Complete Python Trading Bot Tutorial</h2>
    <p>From zero to a working, deployed trading bot. Every line of code included. No pseudocode. Production-ready.</p>
  </div>

  <!-- A1: ENVIRONMENT SETUP -->
  <section class="section" id="a1">
    <div class="section-header">
      <span class="section-num">A.1</span>
      <h2>Environment Setup</h2>
    </div>
    <div>
      <span class="difficulty-badge beginner">üü¢ Beginner</span>
      <span class="time-badge">‚è± 1‚Äì2 hours</span>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Python Virtual Environment &amp; Package Management
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>Start by creating an isolated Python environment. This prevents dependency conflicts and keeps your system clean.</p>

          <div class="code-block"><pre><code><span class="cm"># Install Python 3.11+ (recommended for trading bots)</span>
<span class="cm"># On macOS:</span>
brew install python@3.11

<span class="cm"># Create project directory</span>
mkdir -p ~/trading-bot &amp;&amp; cd ~/trading-bot

<span class="cm"># Create virtual environment</span>
python3.11 -m venv venv
source venv/bin/activate  <span class="cm"># Linux/macOS</span>
<span class="cm"># venv\Scripts\activate   # Windows</span>

<span class="cm"># Upgrade pip</span>
pip install --upgrade pip setuptools wheel

<span class="cm"># Install all required packages</span>
pip install ccxt==4.4.35 \
    ccxt[async]==4.4.35 \
    pandas==2.2.3 \
    numpy==1.26.4 \
    ta==0.11.0 \
    python-dotenv==1.0.1 \
    aiohttp==3.11.11 \
    orjson==3.10.12 \
    SQLAlchemy==2.0.36 \
    aiosqlite==0.20.0 \
    python-telegram-bot==21.9 \
    vectorbt==0.26.2 \
    matplotlib==3.9.3 \
    schedule==1.2.2 \
    loguru==0.7.3 \
    pydantic==2.10.3 \
    websockets==14.1

<span class="cm"># Save requirements</span>
pip freeze &gt; requirements.txt<span class="code-label">bash</span></code></pre></div>

          <h4>Project Structure</h4>
          <div class="file-tree">
<span class="dir">trading-bot/</span>
‚îú‚îÄ‚îÄ <span class="dir">config/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">settings.py</span>         <span class="comment"># Configuration management</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">.env</span>                <span class="comment"># API keys (NEVER commit this)</span>
‚îú‚îÄ‚îÄ <span class="dir">core/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">exchange.py</span>         <span class="comment"># Exchange connection &amp; wrapper</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">data_manager.py</span>     <span class="comment"># Data collection &amp; storage</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">order_manager.py</span>    <span class="comment"># Order execution engine</span>
‚îú‚îÄ‚îÄ <span class="dir">strategies/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">base_strategy.py</span>    <span class="comment"># Abstract base class</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">grid_bot.py</span>         <span class="comment"># Grid trading strategy</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">dca_bot.py</span>          <span class="comment"># DCA strategy</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">mean_reversion.py</span>   <span class="comment"># Mean reversion</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">momentum.py</span>         <span class="comment"># Trend following</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">funding_arb.py</span>      <span class="comment"># Funding rate arbitrage</span>
‚îú‚îÄ‚îÄ <span class="dir">risk/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">position_sizer.py</span>   <span class="comment"># Position sizing calculator</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">risk_manager.py</span>     <span class="comment"># Drawdown &amp; circuit breakers</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">pnl_tracker.py</span>      <span class="comment"># P&amp;L tracking</span>
‚îú‚îÄ‚îÄ <span class="dir">backtest/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">engine.py</span>           <span class="comment"># Custom backtesting engine</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">analyzer.py</span>         <span class="comment"># Performance metrics</span>
‚îú‚îÄ‚îÄ <span class="dir">notifications/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">telegram_bot.py</span>     <span class="comment"># Telegram notifications</span>
‚îú‚îÄ‚îÄ <span class="dir">data/</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">trades.db</span>           <span class="comment"># SQLite database</span>
‚îú‚îÄ‚îÄ <span class="dir">logs/</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">bot.log</span>             <span class="comment"># Log files</span>
‚îú‚îÄ‚îÄ <span class="file">main.py</span>                 <span class="comment"># Entry point</span>
‚îú‚îÄ‚îÄ <span class="file">requirements.txt</span>
‚îú‚îÄ‚îÄ <span class="file">Dockerfile</span>
‚îú‚îÄ‚îÄ <span class="file">docker-compose.yml</span>
‚îî‚îÄ‚îÄ <span class="file">.gitignore</span>
          </div>

          <h4>Configuration Management</h4>
          <div class="code-block"><pre><code><span class="cm"># config/.env ‚Äî NEVER commit this file!</span>
EXCHANGE=binance
API_KEY=your_api_key_here
API_SECRET=your_api_secret_here
TELEGRAM_TOKEN=your_telegram_bot_token
TELEGRAM_CHAT_ID=your_chat_id
DB_PATH=data/trades.db
LOG_LEVEL=INFO
TRADING_MODE=paper  <span class="cm"># paper or live</span>
DEFAULT_SYMBOL=BTC/USDT
MAX_RISK_PER_TRADE=0.01  <span class="cm"># 1%</span>
MAX_DAILY_LOSS=0.03  <span class="cm"># 3%</span><span class="code-label">.env</span></code></pre></div>

          <div class="code-block"><pre><code><span class="cm"># config/settings.py</span>
<span class="kw">import</span> os
<span class="kw">from</span> pathlib <span class="kw">import</span> Path
<span class="kw">from</span> dotenv <span class="kw">import</span> load_dotenv
<span class="kw">from</span> pydantic <span class="kw">import</span> BaseModel, Field
<span class="kw">from</span> typing <span class="kw">import</span> Optional

<span class="cm"># Load environment variables</span>
load_dotenv(Path(__file__).parent / <span class="str">'.env'</span>)


<span class="kw">class</span> <span class="cls">ExchangeConfig</span>(BaseModel):
    name: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'EXCHANGE'</span>, <span class="str">'binance'</span>))
    api_key: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'API_KEY'</span>, <span class="str">''</span>))
    api_secret: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'API_SECRET'</span>, <span class="str">''</span>))
    sandbox: <span class="cls">bool</span> = <span class="num">False</span>
    rate_limit: <span class="cls">bool</span> = <span class="num">True</span>


<span class="kw">class</span> <span class="cls">RiskConfig</span>(BaseModel):
    max_risk_per_trade: <span class="cls">float</span> = Field(
        default_factory=<span class="kw">lambda</span>: <span class="cls">float</span>(os.getenv(<span class="str">'MAX_RISK_PER_TRADE'</span>, <span class="str">'0.01'</span>))
    )
    max_daily_loss: <span class="cls">float</span> = Field(
        default_factory=<span class="kw">lambda</span>: <span class="cls">float</span>(os.getenv(<span class="str">'MAX_DAILY_LOSS'</span>, <span class="str">'0.03'</span>))
    )
    max_total_drawdown: <span class="cls">float</span> = <span class="num">0.10</span>
    max_position_pct: <span class="cls">float</span> = <span class="num">0.20</span>
    max_trades_per_day: <span class="cls">int</span> = <span class="num">10</span>
    max_consecutive_losses: <span class="cls">int</span> = <span class="num">3</span>


<span class="kw">class</span> <span class="cls">TelegramConfig</span>(BaseModel):
    token: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'TELEGRAM_TOKEN'</span>, <span class="str">''</span>))
    chat_id: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'TELEGRAM_CHAT_ID'</span>, <span class="str">''</span>))


<span class="kw">class</span> <span class="cls">Settings</span>(BaseModel):
    exchange: ExchangeConfig = Field(default_factory=ExchangeConfig)
    risk: RiskConfig = Field(default_factory=RiskConfig)
    telegram: TelegramConfig = Field(default_factory=TelegramConfig)
    db_path: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'DB_PATH'</span>, <span class="str">'data/trades.db'</span>))
    log_level: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'LOG_LEVEL'</span>, <span class="str">'INFO'</span>))
    trading_mode: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'TRADING_MODE'</span>, <span class="str">'paper'</span>))
    default_symbol: <span class="cls">str</span> = Field(default_factory=<span class="kw">lambda</span>: os.getenv(<span class="str">'DEFAULT_SYMBOL'</span>, <span class="str">'BTC/USDT'</span>))


<span class="cm"># Singleton instance</span>
settings = Settings()<span class="code-label">Python</span></code></pre></div>

          <div class="callout success">
            ‚úÖ <strong>Why Pydantic?</strong> It validates your config at startup. Typos in env vars get caught immediately instead of crashing at 3 AM during a trade. Always use typed configuration.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- A2: EXCHANGE CONNECTION -->
  <section class="section" id="a2">
    <div class="section-header">
      <span class="section-num">A.2</span>
      <h2>Exchange Connection</h2>
    </div>
    <div>
      <span class="difficulty-badge beginner">üü¢ Beginner</span>
      <span class="time-badge">‚è± 2‚Äì3 hours</span>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Full CCXT Exchange Wrapper with Error Handling
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="code-block"><pre><code><span class="cm"># core/exchange.py ‚Äî Production-ready exchange wrapper</span>
<span class="kw">import</span> ccxt
<span class="kw">import</span> ccxt.async_support <span class="kw">as</span> ccxt_async
<span class="kw">import</span> asyncio
<span class="kw">import</span> time
<span class="kw">from</span> typing <span class="kw">import</span> Optional, Dict, List, Any
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> config.settings <span class="kw">import</span> settings


<span class="kw">class</span> <span class="cls">ExchangeManager</span>:
    <span class="str">"""Production-ready exchange connection with retry logic,
    rate limiting, and error handling."""</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.exchange: Optional[ccxt.Exchange] = <span class="num">None</span>
        self.async_exchange: Optional[ccxt_async.Exchange] = <span class="num">None</span>
        self._last_request_time = <span class="num">0</span>
        self._min_request_interval = <span class="num">0.1</span>  <span class="cm"># 100ms between requests</span>

    <span class="kw">def</span> <span class="fn">connect</span>(self) -&gt; ccxt.Exchange:
        <span class="str">"""Initialize synchronous exchange connection."""</span>
        exchange_class = <span class="fn">getattr</span>(ccxt, settings.exchange.name)
        self.exchange = exchange_class({
            <span class="str">'apiKey'</span>: settings.exchange.api_key,
            <span class="str">'secret'</span>: settings.exchange.api_secret,
            <span class="str">'enableRateLimit'</span>: settings.exchange.rate_limit,
            <span class="str">'options'</span>: {
                <span class="str">'defaultType'</span>: <span class="str">'spot'</span>,
                <span class="str">'adjustForTimeDifference'</span>: <span class="num">True</span>,
            },
            <span class="str">'timeout'</span>: <span class="num">30000</span>,  <span class="cm"># 30 second timeout</span>
        })

        <span class="cm"># Enable sandbox mode for testing</span>
        <span class="kw">if</span> settings.exchange.sandbox:
            self.exchange.set_sandbox_mode(<span class="num">True</span>)
            logger.info(<span class="str">"üèñÔ∏è Sandbox mode enabled"</span>)

        <span class="cm"># Load markets</span>
        self.exchange.load_markets()
        logger.info(
            <span class="str">f"‚úÖ Connected to {settings.exchange.name} | "</span>
            <span class="str">f"{len(self.exchange.symbols)} markets loaded"</span>
        )
        <span class="kw">return</span> self.exchange

    <span class="kw">async def</span> <span class="fn">connect_async</span>(self) -&gt; ccxt_async.Exchange:
        <span class="str">"""Initialize async exchange connection (for WebSocket)."""</span>
        exchange_class = <span class="fn">getattr</span>(ccxt_async, settings.exchange.name)
        self.async_exchange = exchange_class({
            <span class="str">'apiKey'</span>: settings.exchange.api_key,
            <span class="str">'secret'</span>: settings.exchange.api_secret,
            <span class="str">'enableRateLimit'</span>: <span class="num">True</span>,
            <span class="str">'options'</span>: {<span class="str">'defaultType'</span>: <span class="str">'spot'</span>},
        })
        <span class="kw">await</span> self.async_exchange.load_markets()
        <span class="kw">return</span> self.async_exchange

    <span class="kw">def</span> <span class="fn">_rate_limit</span>(self):
        <span class="str">"""Manual rate limiting on top of CCXT's built-in."""</span>
        now = time.time()
        elapsed = now - self._last_request_time
        <span class="kw">if</span> elapsed &lt; self._min_request_interval:
            time.sleep(self._min_request_interval - elapsed)
        self._last_request_time = time.time()

    <span class="kw">def</span> <span class="fn">retry</span>(self, func, *args, max_retries=<span class="num">3</span>, **kwargs) -&gt; Any:
        <span class="str">"""Execute with retry logic for transient errors."""</span>
        <span class="kw">for</span> attempt <span class="kw">in</span> <span class="fn">range</span>(max_retries):
            <span class="kw">try</span>:
                self._rate_limit()
                <span class="kw">return</span> func(*args, **kwargs)
            <span class="kw">except</span> ccxt.RateLimitExceeded <span class="kw">as</span> e:
                wait = <span class="num">2</span> ** attempt
                logger.warning(<span class="str">f"Rate limited, waiting {wait}s..."</span>)
                time.sleep(wait)
            <span class="kw">except</span> ccxt.NetworkError <span class="kw">as</span> e:
                wait = <span class="num">2</span> ** attempt
                logger.warning(<span class="str">f"Network error: {e}, retry {attempt+1}/{max_retries}"</span>)
                time.sleep(wait)
            <span class="kw">except</span> ccxt.ExchangeNotAvailable <span class="kw">as</span> e:
                wait = <span class="num">5</span> * (attempt + <span class="num">1</span>)
                logger.error(<span class="str">f"Exchange unavailable, waiting {wait}s..."</span>)
                time.sleep(wait)
            <span class="kw">except</span> ccxt.InvalidOrder <span class="kw">as</span> e:
                logger.error(<span class="str">f"Invalid order: {e}"</span>)
                <span class="kw">raise</span>  <span class="cm"># Don't retry invalid orders</span>
            <span class="kw">except</span> ccxt.InsufficientFunds <span class="kw">as</span> e:
                logger.error(<span class="str">f"Insufficient funds: {e}"</span>)
                <span class="kw">raise</span>
        <span class="kw">raise</span> Exception(<span class="str">f"Failed after {max_retries} retries"</span>)

    <span class="cm"># ---- Convenience Methods ----</span>

    <span class="kw">def</span> <span class="fn">get_ticker</span>(self, symbol: <span class="cls">str</span>) -&gt; Dict:
        <span class="kw">return</span> self.retry(self.exchange.fetch_ticker, symbol)

    <span class="kw">def</span> <span class="fn">get_balance</span>(self) -&gt; Dict:
        <span class="kw">return</span> self.retry(self.exchange.fetch_balance)

    <span class="kw">def</span> <span class="fn">get_ohlcv</span>(self, symbol: <span class="cls">str</span>, timeframe=<span class="str">'1h'</span>,
                  limit=<span class="num">500</span>, since=<span class="num">None</span>) -&gt; List:
        <span class="kw">return</span> self.retry(
            self.exchange.fetch_ohlcv,
            symbol, timeframe, since, limit
        )

    <span class="kw">def</span> <span class="fn">place_limit_buy</span>(self, symbol: <span class="cls">str</span>, amount: <span class="cls">float</span>,
                        price: <span class="cls">float</span>) -&gt; Dict:
        logger.info(<span class="str">f"üìà BUY {amount} {symbol} @ {price}"</span>)
        <span class="kw">if</span> settings.trading_mode == <span class="str">'paper'</span>:
            logger.info(<span class="str">"üìù Paper trade ‚Äî not executed"</span>)
            <span class="kw">return</span> {<span class="str">'id'</span>: <span class="str">'paper'</span>, <span class="str">'status'</span>: <span class="str">'simulated'</span>}
        <span class="kw">return</span> self.retry(
            self.exchange.create_limit_buy_order,
            symbol, amount, price
        )

    <span class="kw">def</span> <span class="fn">place_limit_sell</span>(self, symbol: <span class="cls">str</span>, amount: <span class="cls">float</span>,
                         price: <span class="cls">float</span>) -&gt; Dict:
        logger.info(<span class="str">f"üìâ SELL {amount} {symbol} @ {price}"</span>)
        <span class="kw">if</span> settings.trading_mode == <span class="str">'paper'</span>:
            <span class="kw">return</span> {<span class="str">'id'</span>: <span class="str">'paper'</span>, <span class="str">'status'</span>: <span class="str">'simulated'</span>}
        <span class="kw">return</span> self.retry(
            self.exchange.create_limit_sell_order,
            symbol, amount, price
        )

    <span class="kw">def</span> <span class="fn">place_market_buy</span>(self, symbol: <span class="cls">str</span>, amount: <span class="cls">float</span>) -&gt; Dict:
        logger.info(<span class="str">f"üìà MARKET BUY {amount} {symbol}"</span>)
        <span class="kw">if</span> settings.trading_mode == <span class="str">'paper'</span>:
            <span class="kw">return</span> {<span class="str">'id'</span>: <span class="str">'paper'</span>, <span class="str">'status'</span>: <span class="str">'simulated'</span>}
        <span class="kw">return</span> self.retry(
            self.exchange.create_market_buy_order,
            symbol, amount
        )

    <span class="kw">def</span> <span class="fn">cancel_order</span>(self, order_id: <span class="cls">str</span>, symbol: <span class="cls">str</span>) -&gt; Dict:
        <span class="kw">return</span> self.retry(
            self.exchange.cancel_order, order_id, symbol
        )

    <span class="kw">def</span> <span class="fn">get_open_orders</span>(self, symbol: <span class="cls">str</span> = <span class="num">None</span>) -&gt; List:
        <span class="kw">return</span> self.retry(self.exchange.fetch_open_orders, symbol)

    <span class="kw">async def</span> <span class="fn">close</span>(self):
        <span class="kw">if</span> self.async_exchange:
            <span class="kw">await</span> self.async_exchange.close()


<span class="cm"># Global instance</span>
exchange_manager = ExchangeManager()<span class="code-label">Python</span></code></pre></div>

          <div class="callout info">
            üí° <strong>Key design decisions:</strong> (1) Retry logic handles transient network errors automatically. (2) Paper trading mode lets you test without risking money. (3) Rate limiting prevents API bans. (4) Logging every order for audit trail.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- A3: DATA COLLECTION -->
  <section class="section" id="a3">
    <div class="section-header">
      <span class="section-num">A.3</span>
      <h2>Data Collection &amp; Storage</h2>
    </div>
    <div>
      <span class="difficulty-badge intermediate">üü° Intermediate</span>
      <span class="time-badge">‚è± 3‚Äì4 hours</span>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Historical OHLCV Data Fetcher + SQLite Storage
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="code-block"><pre><code><span class="cm"># core/data_manager.py ‚Äî Data collection &amp; storage</span>
<span class="kw">import</span> ccxt
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> sqlite3
<span class="kw">import</span> time
<span class="kw">from</span> datetime <span class="kw">import</span> datetime, timedelta
<span class="kw">from</span> typing <span class="kw">import</span> Optional, List
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> pathlib <span class="kw">import</span> Path


<span class="kw">class</span> <span class="cls">DataManager</span>:
    <span class="str">"""Fetches, stores, and retrieves OHLCV data."""</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, db_path: <span class="cls">str</span> = <span class="str">'data/trades.db'</span>):
        Path(db_path).parent.mkdir(parents=<span class="num">True</span>, exist_ok=<span class="num">True</span>)
        self.db_path = db_path
        self._init_db()

    <span class="kw">def</span> <span class="fn">_init_db</span>(self):
        <span class="str">"""Create tables if they don't exist."""</span>
        <span class="kw">with</span> sqlite3.connect(self.db_path) <span class="kw">as</span> conn:
            conn.execute(<span class="str">'''
                CREATE TABLE IF NOT EXISTS ohlcv (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timeframe TEXT NOT NULL,
                    timestamp INTEGER NOT NULL,
                    open REAL NOT NULL,
                    high REAL NOT NULL,
                    low REAL NOT NULL,
                    close REAL NOT NULL,
                    volume REAL NOT NULL,
                    UNIQUE(symbol, timeframe, timestamp)
                )
            '''</span>)
            conn.execute(<span class="str">'''
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    side TEXT NOT NULL,
                    price REAL NOT NULL,
                    amount REAL NOT NULL,
                    cost REAL NOT NULL,
                    fee REAL DEFAULT 0,
                    strategy TEXT,
                    pnl REAL DEFAULT 0,
                    notes TEXT
                )
            '''</span>)
            conn.execute(<span class="str">'''
                CREATE INDEX IF NOT EXISTS idx_ohlcv_symbol_tf_ts
                ON ohlcv(symbol, timeframe, timestamp)
            '''</span>)

    <span class="kw">def</span> <span class="fn">fetch_historical</span>(self, exchange: ccxt.Exchange,
                          symbol: <span class="cls">str</span>, timeframe: <span class="cls">str</span> = <span class="str">'1h'</span>,
                          days_back: <span class="cls">int</span> = <span class="num">365</span>) -&gt; pd.DataFrame:
        <span class="str">"""Fetch historical OHLCV data with pagination."""</span>
        all_candles = []
        since = exchange.parse8601(
            (datetime.utcnow() - timedelta(days=days_back)).isoformat()
        )
        limit = <span class="num">1000</span>  <span class="cm"># Max per request for most exchanges</span>

        logger.info(
            <span class="str">f"üìä Fetching {days_back} days of {symbol} {timeframe} data..."</span>
        )

        <span class="kw">while True</span>:
            <span class="kw">try</span>:
                candles = exchange.fetch_ohlcv(
                    symbol, timeframe, since, limit
                )
                <span class="kw">if not</span> candles:
                    <span class="kw">break</span>

                all_candles.extend(candles)
                since = candles[-<span class="num">1</span>][<span class="num">0</span>] + <span class="num">1</span>  <span class="cm"># Next ms after last candle</span>

                logger.debug(
                    <span class="str">f"  Fetched {len(candles)} candles, "</span>
                    <span class="str">f"total: {len(all_candles)}"</span>
                )

                <span class="cm"># Respect rate limits</span>
                time.sleep(exchange.rateLimit / <span class="num">1000</span>)

                <span class="kw">if</span> len(candles) &lt; limit:
                    <span class="kw">break</span>  <span class="cm"># No more data</span>

            <span class="kw">except</span> ccxt.NetworkError <span class="kw">as</span> e:
                logger.warning(<span class="str">f"Network error, retrying: {e}"</span>)
                time.sleep(<span class="num">5</span>)
                <span class="kw">continue</span>

        <span class="cm"># Convert to DataFrame</span>
        df = pd.DataFrame(
            all_candles,
            columns=[<span class="str">'timestamp'</span>, <span class="str">'open'</span>, <span class="str">'high'</span>, <span class="str">'low'</span>, <span class="str">'close'</span>, <span class="str">'volume'</span>]
        )
        df[<span class="str">'timestamp'</span>] = pd.to_datetime(df[<span class="str">'timestamp'</span>], unit=<span class="str">'ms'</span>)
        df.set_index(<span class="str">'timestamp'</span>, inplace=<span class="num">True</span>)
        df = df[~df.index.duplicated(keep=<span class="str">'last'</span>)]
        df.sort_index(inplace=<span class="num">True</span>)

        logger.info(
            <span class="str">f"‚úÖ Fetched {len(df)} candles from "</span>
            <span class="str">f"{df.index[0]} to {df.index[-1]}"</span>
        )

        <span class="cm"># Store in SQLite</span>
        self._store_ohlcv(df, symbol, timeframe)

        <span class="kw">return</span> df

    <span class="kw">def</span> <span class="fn">_store_ohlcv</span>(self, df: pd.DataFrame,
                      symbol: <span class="cls">str</span>, timeframe: <span class="cls">str</span>):
        <span class="str">"""Store OHLCV data in SQLite."""</span>
        <span class="kw">with</span> sqlite3.connect(self.db_path) <span class="kw">as</span> conn:
            <span class="kw">for</span> ts, row <span class="kw">in</span> df.iterrows():
                conn.execute(<span class="str">'''
                    INSERT OR REPLACE INTO ohlcv
                    (symbol, timeframe, timestamp, open, high, low, close, volume)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                '''</span>, (symbol, timeframe, <span class="cls">int</span>(ts.timestamp() * <span class="num">1000</span>),
                    row[<span class="str">'open'</span>], row[<span class="str">'high'</span>], row[<span class="str">'low'</span>],
                    row[<span class="str">'close'</span>], row[<span class="str">'volume'</span>]))

        logger.info(<span class="str">f"üíæ Stored {len(df)} candles in database"</span>)

    <span class="kw">def</span> <span class="fn">load_ohlcv</span>(self, symbol: <span class="cls">str</span>, timeframe: <span class="cls">str</span>,
                    start_date: Optional[<span class="cls">str</span>] = <span class="num">None</span>) -&gt; pd.DataFrame:
        <span class="str">"""Load OHLCV data from SQLite."""</span>
        query = <span class="str">"SELECT * FROM ohlcv WHERE symbol=? AND timeframe=?"</span>
        params = [symbol, timeframe]

        <span class="kw">if</span> start_date:
            ts = <span class="cls">int</span>(pd.Timestamp(start_date).timestamp() * <span class="num">1000</span>)
            query += <span class="str">" AND timestamp >= ?"</span>
            params.append(ts)

        query += <span class="str">" ORDER BY timestamp ASC"</span>

        <span class="kw">with</span> sqlite3.connect(self.db_path) <span class="kw">as</span> conn:
            df = pd.read_sql_query(query, conn, params=params)

        <span class="kw">if</span> df.empty:
            <span class="kw">return</span> df

        df[<span class="str">'timestamp'</span>] = pd.to_datetime(df[<span class="str">'timestamp'</span>], unit=<span class="str">'ms'</span>)
        df.set_index(<span class="str">'timestamp'</span>, inplace=<span class="num">True</span>)
        <span class="kw">return</span> df[[<span class="str">'open'</span>, <span class="str">'high'</span>, <span class="str">'low'</span>, <span class="str">'close'</span>, <span class="str">'volume'</span>]]

    <span class="kw">def</span> <span class="fn">log_trade</span>(self, symbol: <span class="cls">str</span>, side: <span class="cls">str</span>, price: <span class="cls">float</span>,
                   amount: <span class="cls">float</span>, strategy: <span class="cls">str</span> = <span class="str">''</span>,
                   pnl: <span class="cls">float</span> = <span class="num">0</span>):
        <span class="str">"""Log a trade to the database."""</span>
        <span class="kw">with</span> sqlite3.connect(self.db_path) <span class="kw">as</span> conn:
            conn.execute(<span class="str">'''
                INSERT INTO trades
                (timestamp, symbol, side, price, amount, cost, strategy, pnl)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            '''</span>, (datetime.utcnow().isoformat(), symbol, side,
                price, amount, price * amount, strategy, pnl))


<span class="cm"># Usage example:</span>
<span class="cm"># dm = DataManager()</span>
<span class="cm"># exchange = ExchangeManager().connect()</span>
<span class="cm"># df = dm.fetch_historical(exchange, 'BTC/USDT', '1h', days_back=730)</span><span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>
  </section>

  <!-- A4: STRATEGY IMPLEMENTATIONS -->
  <section class="section" id="a4">
    <div class="section-header">
      <span class="section-num">A.4</span>
      <h2>Strategy Implementations ‚Äî Full Working Code</h2>
    </div>

    <!-- Base Strategy -->
    <div class="collapsible open">
      <button class="collapsible-toggle">
        Base Strategy Class (All strategies inherit from this)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="code-block"><pre><code><span class="cm"># strategies/base_strategy.py</span>
<span class="kw">from</span> abc <span class="kw">import</span> ABC, abstractmethod
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">from</span> typing <span class="kw">import</span> Optional, Dict, List
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass, field
<span class="kw">from</span> loguru <span class="kw">import</span> logger


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">Signal</span>:
    <span class="str">"""Trading signal from a strategy."""</span>
    action: <span class="cls">str</span>       <span class="cm"># 'buy', 'sell', 'hold'</span>
    symbol: <span class="cls">str</span>
    price: <span class="cls">float</span>
    amount: <span class="cls">float</span> = <span class="num">0.0</span>
    stop_loss: Optional[<span class="cls">float</span>] = <span class="num">None</span>
    take_profit: Optional[<span class="cls">float</span>] = <span class="num">None</span>
    confidence: <span class="cls">float</span> = <span class="num">0.5</span>  <span class="cm"># 0-1</span>
    reason: <span class="cls">str</span> = <span class="str">''</span>
    metadata: Dict = field(default_factory=<span class="cls">dict</span>)


<span class="kw">class</span> <span class="cls">BaseStrategy</span>(ABC):
    <span class="str">"""Abstract base class for all trading strategies."""</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, symbol: <span class="cls">str</span>, params: Dict = <span class="num">None</span>):
        self.symbol = symbol
        self.params = params <span class="kw">or</span> {}
        self.positions: List[Dict] = []
        self.is_active = <span class="num">True</span>
        self.total_pnl = <span class="num">0.0</span>
        self.trade_count = <span class="num">0</span>

    <span class="dec">@abstractmethod</span>
    <span class="kw">def</span> <span class="fn">analyze</span>(self, df: pd.DataFrame) -&gt; Signal:
        <span class="str">"""Analyze market data and return a signal."""</span>
        <span class="kw">pass</span>

    <span class="dec">@abstractmethod</span>
    <span class="kw">def</span> <span class="fn">on_fill</span>(self, order: Dict):
        <span class="str">"""Called when an order is filled."""</span>
        <span class="kw">pass</span>

    <span class="kw">def</span> <span class="fn">should_trade</span>(self) -&gt; <span class="cls">bool</span>:
        <span class="str">"""Check if strategy should be trading."""</span>
        <span class="kw">return</span> self.is_active

    <span class="kw">def</span> <span class="fn">stop</span>(self):
        self.is_active = <span class="num">False</span>
        logger.info(<span class="str">f"‚è∏Ô∏è Strategy stopped for {self.symbol}"</span>)<span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>

    <!-- GRID BOT -->
    <div class="collapsible">
      <button class="collapsible-toggle">
        üî≤ Grid Trading Bot ‚Äî Full Implementation
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div>
            <span class="difficulty-badge intermediate">üü° Intermediate</span>
            <span class="time-badge">‚è± 4‚Äì6 hours to implement</span>
          </div>
          <p>Grid trading places buy and sell orders at fixed intervals around a price range. It profits from price oscillation in sideways markets.</p>

          <div class="code-block"><pre><code><span class="cm"># strategies/grid_bot.py ‚Äî Complete Grid Trading Bot</span>
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Optional
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass, field
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> strategies.base_strategy <span class="kw">import</span> BaseStrategy, Signal


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">GridLevel</span>:
    <span class="str">"""Represents a single grid level."""</span>
    price: <span class="cls">float</span>
    buy_order_id: Optional[<span class="cls">str</span>] = <span class="num">None</span>
    sell_order_id: Optional[<span class="cls">str</span>] = <span class="num">None</span>
    is_filled_buy: <span class="cls">bool</span> = <span class="num">False</span>
    is_filled_sell: <span class="cls">bool</span> = <span class="num">False</span>
    profit: <span class="cls">float</span> = <span class="num">0.0</span>


<span class="kw">class</span> <span class="cls">GridBot</span>(BaseStrategy):
    <span class="str">"""
    Grid Trading Bot
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Places buy/sell orders at fixed price intervals.
    Profits from sideways price oscillation.

    Parameters:
    - upper_price: Top of grid range
    - lower_price: Bottom of grid range
    - num_grids: Number of grid levels (10-50)
    - total_investment: Total capital to use
    - grid_type: 'arithmetic' or 'geometric'
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, symbol: <span class="cls">str</span>, params: Dict):
        <span class="fn">super</span>().__init__(symbol, params)
        self.upper_price = params[<span class="str">'upper_price'</span>]
        self.lower_price = params[<span class="str">'lower_price'</span>]
        self.num_grids = params.get(<span class="str">'num_grids'</span>, <span class="num">20</span>)
        self.total_investment = params[<span class="str">'total_investment'</span>]
        self.grid_type = params.get(<span class="str">'grid_type'</span>, <span class="str">'arithmetic'</span>)
        self.order_size = self.total_investment / self.num_grids
        self.grids: List[GridLevel] = []
        self.realized_profit = <span class="num">0.0</span>
        self._calculate_grid_levels()

    <span class="kw">def</span> <span class="fn">_calculate_grid_levels</span>(self):
        <span class="str">"""Calculate grid price levels."""</span>
        <span class="kw">if</span> self.grid_type == <span class="str">'arithmetic'</span>:
            <span class="cm"># Equal price spacing</span>
            prices = np.linspace(
                self.lower_price, self.upper_price, self.num_grids + <span class="num">1</span>
            )
        <span class="kw">elif</span> self.grid_type == <span class="str">'geometric'</span>:
            <span class="cm"># Equal percentage spacing (better for volatile assets)</span>
            ratio = (self.upper_price / self.lower_price) ** (
                <span class="num">1</span> / self.num_grids
            )
            prices = [
                self.lower_price * (ratio ** i)
                <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(self.num_grids + <span class="num">1</span>)
            ]
        <span class="kw">else</span>:
            <span class="kw">raise</span> ValueError(<span class="str">f"Unknown grid type: {self.grid_type}"</span>)

        self.grids = [GridLevel(price=p) <span class="kw">for</span> p <span class="kw">in</span> prices]

        grid_spacing = (
            (self.upper_price - self.lower_price) / self.num_grids
        )
        logger.info(
            <span class="str">f"üìä Grid configured: {self.num_grids} levels, "</span>
            <span class="str">f"${self.lower_price:.2f}-${self.upper_price:.2f}, "</span>
            <span class="str">f"spacing: ${grid_spacing:.2f} ({self.grid_type})"</span>
        )

    <span class="kw">def</span> <span class="fn">analyze</span>(self, df: pd.DataFrame) -&gt; Signal:
        <span class="str">"""Check if current price triggers any grid orders."""</span>
        current_price = df[<span class="str">'close'</span>].iloc[-<span class="num">1</span>]

        <span class="cm"># Check if price is outside grid range</span>
        <span class="kw">if</span> current_price &gt; self.upper_price:
            <span class="kw">return</span> Signal(
                action=<span class="str">'hold'</span>, symbol=self.symbol,
                price=current_price,
                reason=<span class="str">'Price above grid range'</span>
            )
        <span class="kw">if</span> current_price &lt; self.lower_price:
            <span class="kw">return</span> Signal(
                action=<span class="str">'hold'</span>, symbol=self.symbol,
                price=current_price,
                reason=<span class="str">'Price below grid range'</span>
            )

        <span class="cm"># Find nearest grid level below current price (buy)</span>
        <span class="kw">for</span> grid <span class="kw">in</span> self.grids:
            <span class="kw">if</span> (grid.price &lt;= current_price
                    <span class="kw">and not</span> grid.is_filled_buy):
                amount = self.order_size / current_price
                <span class="kw">return</span> Signal(
                    action=<span class="str">'buy'</span>,
                    symbol=self.symbol,
                    price=grid.price,
                    amount=amount,
                    reason=<span class="str">f'Grid buy at {grid.price:.2f}'</span>,
                    metadata={<span class="str">'grid_price'</span>: grid.price}
                )

        <span class="cm"># Find nearest grid level above for sell</span>
        <span class="kw">for</span> grid <span class="kw">in</span> <span class="fn">reversed</span>(self.grids):
            <span class="kw">if</span> (grid.price &gt;= current_price
                    <span class="kw">and</span> grid.is_filled_buy
                    <span class="kw">and not</span> grid.is_filled_sell):
                amount = self.order_size / grid.price
                profit = (current_price - grid.price) * amount
                <span class="kw">return</span> Signal(
                    action=<span class="str">'sell'</span>,
                    symbol=self.symbol,
                    price=current_price,
                    amount=amount,
                    reason=<span class="str">f'Grid sell, profit: ${profit:.2f}'</span>,
                    metadata={<span class="str">'grid_price'</span>: grid.price}
                )

        <span class="kw">return</span> Signal(
            action=<span class="str">'hold'</span>, symbol=self.symbol,
            price=current_price, reason=<span class="str">'No grid trigger'</span>
        )

    <span class="kw">def</span> <span class="fn">on_fill</span>(self, order: Dict):
        <span class="str">"""Update grid state when an order fills."""</span>
        grid_price = order.get(<span class="str">'metadata'</span>, {}).get(<span class="str">'grid_price'</span>)
        <span class="kw">if not</span> grid_price:
            <span class="kw">return</span>

        <span class="kw">for</span> grid <span class="kw">in</span> self.grids:
            <span class="kw">if</span> <span class="fn">abs</span>(grid.price - grid_price) &lt; <span class="num">0.01</span>:
                <span class="kw">if</span> order[<span class="str">'side'</span>] == <span class="str">'buy'</span>:
                    grid.is_filled_buy = <span class="num">True</span>
                    grid.buy_order_id = order.get(<span class="str">'id'</span>)
                <span class="kw">elif</span> order[<span class="str">'side'</span>] == <span class="str">'sell'</span>:
                    grid.is_filled_sell = <span class="num">True</span>
                    profit = (order[<span class="str">'price'</span>] - grid.price) * order[<span class="str">'amount'</span>]
                    grid.profit = profit
                    self.realized_profit += profit
                    <span class="cm"># Reset grid for next cycle</span>
                    grid.is_filled_buy = <span class="num">False</span>
                    grid.is_filled_sell = <span class="num">False</span>
                    logger.info(
                        <span class="str">f"üí∞ Grid profit: ${profit:.2f} | "</span>
                        <span class="str">f"Total: ${self.realized_profit:.2f}"</span>
                    )
                <span class="kw">break</span>

    <span class="kw">def</span> <span class="fn">get_stats</span>(self) -&gt; Dict:
        <span class="str">"""Return grid bot statistics."""</span>
        filled = <span class="fn">sum</span>(<span class="num">1</span> <span class="kw">for</span> g <span class="kw">in</span> self.grids <span class="kw">if</span> g.is_filled_buy)
        <span class="kw">return</span> {
            <span class="str">'total_grids'</span>: self.num_grids,
            <span class="str">'filled_grids'</span>: filled,
            <span class="str">'realized_profit'</span>: self.realized_profit,
            <span class="str">'roi_pct'</span>: (self.realized_profit / self.total_investment) * <span class="num">100</span>,
        }


<span class="cm"># Usage:</span>
<span class="cm"># bot = GridBot('BTC/USDT', {</span>
<span class="cm">#     'upper_price': 100000,</span>
<span class="cm">#     'lower_price': 80000,</span>
<span class="cm">#     'num_grids': 20,</span>
<span class="cm">#     'total_investment': 10000,</span>
<span class="cm">#     'grid_type': 'geometric'</span>
<span class="cm"># })</span><span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>

    <!-- DCA BOT -->
    <div class="collapsible">
      <button class="collapsible-toggle">
        üìâ DCA Bot ‚Äî Full Implementation
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div>
            <span class="difficulty-badge intermediate">üü° Intermediate</span>
            <span class="time-badge">‚è± 3‚Äì5 hours to implement</span>
          </div>

          <div class="code-block"><pre><code><span class="cm"># strategies/dca_bot.py ‚Äî Dollar Cost Averaging Bot with Safety Orders</span>
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Optional
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> strategies.base_strategy <span class="kw">import</span> BaseStrategy, Signal


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">DCADeal</span>:
    <span class="str">"""Represents a single DCA deal (base order + safety orders)."""</span>
    entry_price: <span class="cls">float</span>
    total_amount: <span class="cls">float</span> = <span class="num">0.0</span>
    total_cost: <span class="cls">float</span> = <span class="num">0.0</span>
    safety_order_count: <span class="cls">int</span> = <span class="num">0</span>
    is_active: <span class="cls">bool</span> = <span class="num">True</span>

    <span class="dec">@property</span>
    <span class="kw">def</span> <span class="fn">average_price</span>(self) -&gt; <span class="cls">float</span>:
        <span class="kw">return</span> self.total_cost / self.total_amount <span class="kw">if</span> self.total_amount &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>


<span class="kw">class</span> <span class="cls">DCABot</span>(BaseStrategy):
    <span class="str">"""
    DCA Bot with Safety Orders
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Automatically buys dips with increasing order sizes.

    Parameters:
    - base_order_size: Initial buy amount in USDT
    - safety_order_size: First safety order size
    - max_safety_orders: Maximum number of safety orders
    - price_deviation: % drop to trigger each safety order
    - safety_order_volume_scale: Multiplier for each subsequent SO
    - safety_order_step_scale: Multiplier for price deviation
    - take_profit_pct: Target profit percentage
    - use_martingale: Whether to increase SO sizes (True/False)
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, symbol: <span class="cls">str</span>, params: Dict):
        <span class="fn">super</span>().__init__(symbol, params)
        self.base_order_size = params.get(<span class="str">'base_order_size'</span>, <span class="num">100</span>)
        self.safety_order_size = params.get(<span class="str">'safety_order_size'</span>, <span class="num">200</span>)
        self.max_safety_orders = params.get(<span class="str">'max_safety_orders'</span>, <span class="num">5</span>)
        self.price_deviation = params.get(<span class="str">'price_deviation'</span>, <span class="num">0.02</span>)
        self.so_volume_scale = params.get(<span class="str">'safety_order_volume_scale'</span>, <span class="num">1.5</span>)
        self.so_step_scale = params.get(<span class="str">'safety_order_step_scale'</span>, <span class="num">1.2</span>)
        self.take_profit_pct = params.get(<span class="str">'take_profit_pct'</span>, <span class="num">0.015</span>)
        self.use_martingale = params.get(<span class="str">'use_martingale'</span>, <span class="num">True</span>)
        self.max_active_deals = params.get(<span class="str">'max_active_deals'</span>, <span class="num">1</span>)

        self.active_deal: Optional[DCADeal] = <span class="num">None</span>
        self.completed_deals = <span class="num">0</span>
        self.total_profit = <span class="num">0.0</span>

        <span class="cm"># Pre-calculate safety order levels</span>
        self._safety_levels = self._calc_safety_levels()
        self._log_config()

    <span class="kw">def</span> <span class="fn">_calc_safety_levels</span>(self) -&gt; List[Dict]:
        <span class="str">"""Pre-calculate safety order sizes and trigger prices."""</span>
        levels = []
        cumulative_deviation = <span class="num">0</span>
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(self.max_safety_orders):
            deviation = self.price_deviation * (self.so_step_scale ** i)
            cumulative_deviation += deviation

            <span class="kw">if</span> self.use_martingale:
                size = self.safety_order_size * (self.so_volume_scale ** i)
            <span class="kw">else</span>:
                size = self.safety_order_size

            levels.append({
                <span class="str">'order_num'</span>: i + <span class="num">1</span>,
                <span class="str">'deviation'</span>: cumulative_deviation,
                <span class="str">'size_usdt'</span>: <span class="fn">round</span>(size, <span class="num">2</span>),
            })
        <span class="kw">return</span> levels

    <span class="kw">def</span> <span class="fn">_log_config</span>(self):
        total_required = self.base_order_size + <span class="fn">sum</span>(
            l[<span class="str">'size_usdt'</span>] <span class="kw">for</span> l <span class="kw">in</span> self._safety_levels
        )
        logger.info(
            <span class="str">f"üìä DCA Bot configured: {self.symbol}\n"</span>
            <span class="str">f"  Base order: ${self.base_order_size}\n"</span>
            <span class="str">f"  Safety orders: {self.max_safety_orders}\n"</span>
            <span class="str">f"  Take profit: {self.take_profit_pct*100}%\n"</span>
            <span class="str">f"  Total capital needed: ${total_required:.2f}"</span>
        )

    <span class="kw">def</span> <span class="fn">analyze</span>(self, df: pd.DataFrame) -&gt; Signal:
        <span class="str">"""Analyze and return trading signal."""</span>
        current_price = df[<span class="str">'close'</span>].iloc[-<span class="num">1</span>]

        <span class="cm"># No active deal ‚Äî start one</span>
        <span class="kw">if</span> self.active_deal <span class="kw">is None</span>:
            amount = self.base_order_size / current_price
            <span class="kw">return</span> Signal(
                action=<span class="str">'buy'</span>, symbol=self.symbol,
                price=current_price, amount=amount,
                reason=<span class="str">'DCA base order'</span>,
                metadata={<span class="str">'order_type'</span>: <span class="str">'base'</span>}
            )

        <span class="cm"># Check take profit</span>
        avg_price = self.active_deal.average_price
        profit_pct = (current_price - avg_price) / avg_price

        <span class="kw">if</span> profit_pct &gt;= self.take_profit_pct:
            <span class="kw">return</span> Signal(
                action=<span class="str">'sell'</span>, symbol=self.symbol,
                price=current_price,
                amount=self.active_deal.total_amount,
                reason=<span class="str">f'Take profit at {profit_pct*100:.2f}%'</span>,
                metadata={<span class="str">'order_type'</span>: <span class="str">'take_profit'</span>}
            )

        <span class="cm"># Check safety orders</span>
        so_count = self.active_deal.safety_order_count
        <span class="kw">if</span> so_count &lt; self.max_safety_orders:
            level = self._safety_levels[so_count]
            trigger_price = self.active_deal.entry_price * (
                <span class="num">1</span> - level[<span class="str">'deviation'</span>]
            )

            <span class="kw">if</span> current_price &lt;= trigger_price:
                amount = level[<span class="str">'size_usdt'</span>] / current_price
                <span class="kw">return</span> Signal(
                    action=<span class="str">'buy'</span>, symbol=self.symbol,
                    price=current_price, amount=amount,
                    reason=(
                        <span class="str">f"Safety order #{so_count+1} at "</span>
                        <span class="str">f"{level['deviation']*100:.1f}% deviation"</span>
                    ),
                    metadata={
                        <span class="str">'order_type'</span>: <span class="str">'safety'</span>,
                        <span class="str">'so_number'</span>: so_count + <span class="num">1</span>
                    }
                )

        <span class="kw">return</span> Signal(
            action=<span class="str">'hold'</span>, symbol=self.symbol,
            price=current_price, reason=<span class="str">'Waiting'</span>
        )

    <span class="kw">def</span> <span class="fn">on_fill</span>(self, order: Dict):
        <span class="str">"""Process filled order."""</span>
        order_type = order.get(<span class="str">'metadata'</span>, {}).get(<span class="str">'order_type'</span>)

        <span class="kw">if</span> order_type == <span class="str">'base'</span>:
            self.active_deal = DCADeal(
                entry_price=order[<span class="str">'price'</span>],
                total_amount=order[<span class="str">'amount'</span>],
                total_cost=order[<span class="str">'price'</span>] * order[<span class="str">'amount'</span>],
            )
            logger.info(<span class="str">f"üü¢ DCA deal started at ${order['price']:.2f}"</span>)

        <span class="kw">elif</span> order_type == <span class="str">'safety'</span> <span class="kw">and</span> self.active_deal:
            cost = order[<span class="str">'price'</span>] * order[<span class="str">'amount'</span>]
            self.active_deal.total_amount += order[<span class="str">'amount'</span>]
            self.active_deal.total_cost += cost
            self.active_deal.safety_order_count += <span class="num">1</span>
            logger.info(
                <span class="str">f"üîµ Safety order #{self.active_deal.safety_order_count} | "</span>
                <span class="str">f"Avg: ${self.active_deal.average_price:.2f}"</span>
            )

        <span class="kw">elif</span> order_type == <span class="str">'take_profit'</span> <span class="kw">and</span> self.active_deal:
            revenue = order[<span class="str">'price'</span>] * order[<span class="str">'amount'</span>]
            profit = revenue - self.active_deal.total_cost
            self.total_profit += profit
            self.completed_deals += <span class="num">1</span>
            logger.info(
                <span class="str">f"üí∞ Deal closed! Profit: ${profit:.2f} | "</span>
                <span class="str">f"Total: ${self.total_profit:.2f} | "</span>
                <span class="str">f"Deals: {self.completed_deals}"</span>
            )
            self.active_deal = <span class="num">None</span>  <span class="cm"># Ready for next deal</span><span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>

    <!-- MEAN REVERSION -->
    <div class="collapsible">
      <button class="collapsible-toggle">
        üìä Mean Reversion Bot (Bollinger Bands + RSI)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div>
            <span class="difficulty-badge intermediate">üü° Intermediate</span>
            <span class="time-badge">‚è± 3‚Äì4 hours to implement</span>
          </div>

          <div class="code-block"><pre><code><span class="cm"># strategies/mean_reversion.py</span>
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> ta
<span class="kw">from</span> typing <span class="kw">import</span> Dict, Optional
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> strategies.base_strategy <span class="kw">import</span> BaseStrategy, Signal


<span class="kw">class</span> <span class="cls">MeanReversionBot</span>(BaseStrategy):
    <span class="str">"""
    Mean Reversion using Bollinger Bands + RSI
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Buy when price touches lower BB and RSI &lt; 30.
    Sell when price touches upper BB and RSI &gt; 70.
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, symbol: <span class="cls">str</span>, params: Dict = <span class="num">None</span>):
        <span class="fn">super</span>().__init__(symbol, params <span class="kw">or</span> {})
        self.bb_period = self.params.get(<span class="str">'bb_period'</span>, <span class="num">20</span>)
        self.bb_std = self.params.get(<span class="str">'bb_std'</span>, <span class="num">2.0</span>)
        self.rsi_period = self.params.get(<span class="str">'rsi_period'</span>, <span class="num">14</span>)
        self.rsi_oversold = self.params.get(<span class="str">'rsi_oversold'</span>, <span class="num">30</span>)
        self.rsi_overbought = self.params.get(<span class="str">'rsi_overbought'</span>, <span class="num">70</span>)
        self.position_size_pct = self.params.get(<span class="str">'position_size_pct'</span>, <span class="num">0.1</span>)
        self.stop_loss_pct = self.params.get(<span class="str">'stop_loss_pct'</span>, <span class="num">0.03</span>)
        self.in_position = <span class="num">False</span>
        self.entry_price = <span class="num">0.0</span>

    <span class="kw">def</span> <span class="fn">_add_indicators</span>(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        <span class="str">"""Add Bollinger Bands and RSI indicators."""</span>
        bb = ta.volatility.BollingerBands(
            df[<span class="str">'close'</span>], window=self.bb_period, window_dev=self.bb_std
        )
        df[<span class="str">'bb_upper'</span>] = bb.bollinger_hband()
        df[<span class="str">'bb_middle'</span>] = bb.bollinger_mavg()
        df[<span class="str">'bb_lower'</span>] = bb.bollinger_lband()
        df[<span class="str">'bb_width'</span>] = bb.bollinger_wband()
        df[<span class="str">'rsi'</span>] = ta.momentum.RSIIndicator(
            df[<span class="str">'close'</span>], window=self.rsi_period
        ).rsi()
        <span class="kw">return</span> df

    <span class="kw">def</span> <span class="fn">analyze</span>(self, df: pd.DataFrame) -&gt; Signal:
        df = self._add_indicators(df.copy())
        latest = df.iloc[-<span class="num">1</span>]
        price = latest[<span class="str">'close'</span>]
        rsi = latest[<span class="str">'rsi'</span>]

        <span class="cm"># BUY signal: Price below lower BB + RSI oversold</span>
        <span class="kw">if</span> (<span class="kw">not</span> self.in_position
                <span class="kw">and</span> price &lt;= latest[<span class="str">'bb_lower'</span>]
                <span class="kw">and</span> rsi &lt; self.rsi_oversold):
            stop_loss = price * (<span class="num">1</span> - self.stop_loss_pct)
            take_profit = latest[<span class="str">'bb_middle'</span>]  <span class="cm"># Target = middle band</span>
            <span class="kw">return</span> Signal(
                action=<span class="str">'buy'</span>, symbol=self.symbol,
                price=price, confidence=<span class="num">0.7</span>,
                stop_loss=stop_loss, take_profit=take_profit,
                reason=<span class="str">f'BB lower touch + RSI={rsi:.0f}'</span>
            )

        <span class="cm"># SELL signal: Price above upper BB + RSI overbought</span>
        <span class="kw">if</span> (self.in_position
                <span class="kw">and</span> (price &gt;= latest[<span class="str">'bb_upper'</span>]
                     <span class="kw">or</span> rsi &gt; self.rsi_overbought)):
            pnl_pct = (price - self.entry_price) / self.entry_price
            <span class="kw">return</span> Signal(
                action=<span class="str">'sell'</span>, symbol=self.symbol,
                price=price,
                reason=<span class="str">f'Mean reversion exit, PnL: {pnl_pct*100:.1f}%'</span>
            )

        <span class="cm"># Stop loss check</span>
        <span class="kw">if</span> (self.in_position
                <span class="kw">and</span> price &lt; self.entry_price * (<span class="num">1</span> - self.stop_loss_pct)):
            <span class="kw">return</span> Signal(
                action=<span class="str">'sell'</span>, symbol=self.symbol,
                price=price, reason=<span class="str">'Stop loss triggered'</span>
            )

        <span class="kw">return</span> Signal(action=<span class="str">'hold'</span>, symbol=self.symbol, price=price)

    <span class="kw">def</span> <span class="fn">on_fill</span>(self, order: Dict):
        <span class="kw">if</span> order.get(<span class="str">'side'</span>) == <span class="str">'buy'</span>:
            self.in_position = <span class="num">True</span>
            self.entry_price = order[<span class="str">'price'</span>]
        <span class="kw">elif</span> order.get(<span class="str">'side'</span>) == <span class="str">'sell'</span>:
            self.in_position = <span class="num">False</span>
            self.entry_price = <span class="num">0.0</span><span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>

    <!-- MOMENTUM BOT -->
    <div class="collapsible">
      <button class="collapsible-toggle">
        üöÄ Momentum / Trend Following Bot (EMA + ADX)
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div>
            <span class="difficulty-badge intermediate">üü° Intermediate</span>
            <span class="time-badge">‚è± 3‚Äì4 hours to implement</span>
          </div>

          <div class="code-block"><pre><code><span class="cm"># strategies/momentum.py</span>
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> ta
<span class="kw">from</span> typing <span class="kw">import</span> Dict
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> strategies.base_strategy <span class="kw">import</span> BaseStrategy, Signal


<span class="kw">class</span> <span class="cls">MomentumBot</span>(BaseStrategy):
    <span class="str">"""
    Trend Following with EMA Crossover + ADX Filter
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Entry: Fast EMA crosses above Slow EMA + ADX &gt; 25
    Exit: Fast EMA crosses below Slow EMA OR trailing stop
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, symbol: <span class="cls">str</span>, params: Dict = <span class="num">None</span>):
        <span class="fn">super</span>().__init__(symbol, params <span class="kw">or</span> {})
        self.fast_ema = self.params.get(<span class="str">'fast_ema'</span>, <span class="num">12</span>)
        self.slow_ema = self.params.get(<span class="str">'slow_ema'</span>, <span class="num">26</span>)
        self.adx_period = self.params.get(<span class="str">'adx_period'</span>, <span class="num">14</span>)
        self.adx_threshold = self.params.get(<span class="str">'adx_threshold'</span>, <span class="num">25</span>)
        self.trailing_stop_pct = self.params.get(<span class="str">'trailing_stop_pct'</span>, <span class="num">0.03</span>)
        self.atr_multiplier = self.params.get(<span class="str">'atr_multiplier'</span>, <span class="num">2.0</span>)

        self.in_position = <span class="num">False</span>
        self.entry_price = <span class="num">0.0</span>
        self.highest_since_entry = <span class="num">0.0</span>
        self.position_side = <span class="num">None</span>  <span class="cm"># 'long' or 'short'</span>

    <span class="kw">def</span> <span class="fn">_add_indicators</span>(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        df[<span class="str">'ema_fast'</span>] = ta.trend.EMAIndicator(
            df[<span class="str">'close'</span>], window=self.fast_ema
        ).ema_indicator()
        df[<span class="str">'ema_slow'</span>] = ta.trend.EMAIndicator(
            df[<span class="str">'close'</span>], window=self.slow_ema
        ).ema_indicator()

        adx_indicator = ta.trend.ADXIndicator(
            df[<span class="str">'high'</span>], df[<span class="str">'low'</span>], df[<span class="str">'close'</span>],
            window=self.adx_period
        )
        df[<span class="str">'adx'</span>] = adx_indicator.adx()
        df[<span class="str">'di_pos'</span>] = adx_indicator.adx_pos()
        df[<span class="str">'di_neg'</span>] = adx_indicator.adx_neg()

        df[<span class="str">'atr'</span>] = ta.volatility.AverageTrueRange(
            df[<span class="str">'high'</span>], df[<span class="str">'low'</span>], df[<span class="str">'close'</span>], window=<span class="num">14</span>
        ).average_true_range()

        <span class="cm"># EMA crossover signals</span>
        df[<span class="str">'ema_cross_up'</span>] = (
            (df[<span class="str">'ema_fast'</span>] &gt; df[<span class="str">'ema_slow'</span>])
            &amp; (df[<span class="str">'ema_fast'</span>].shift(<span class="num">1</span>) &lt;= df[<span class="str">'ema_slow'</span>].shift(<span class="num">1</span>))
        )
        df[<span class="str">'ema_cross_down'</span>] = (
            (df[<span class="str">'ema_fast'</span>] &lt; df[<span class="str">'ema_slow'</span>])
            &amp; (df[<span class="str">'ema_fast'</span>].shift(<span class="num">1</span>) &gt;= df[<span class="str">'ema_slow'</span>].shift(<span class="num">1</span>))
        )
        <span class="kw">return</span> df

    <span class="kw">def</span> <span class="fn">analyze</span>(self, df: pd.DataFrame) -&gt; Signal:
        df = self._add_indicators(df.copy())
        latest = df.iloc[-<span class="num">1</span>]
        price = latest[<span class="str">'close'</span>]
        adx = latest[<span class="str">'adx'</span>]
        atr = latest[<span class="str">'atr'</span>]

        <span class="cm"># ENTRY: EMA cross up + strong trend (ADX &gt; threshold)</span>
        <span class="kw">if</span> (<span class="kw">not</span> self.in_position
                <span class="kw">and</span> latest[<span class="str">'ema_cross_up'</span>]
                <span class="kw">and</span> adx &gt; self.adx_threshold):
            stop_loss = price - (atr * self.atr_multiplier)
            take_profit = price + (atr * self.atr_multiplier * <span class="num">3</span>)
            <span class="kw">return</span> Signal(
                action=<span class="str">'buy'</span>, symbol=self.symbol,
                price=price, confidence=min(adx / <span class="num">50</span>, <span class="num">1.0</span>),
                stop_loss=stop_loss, take_profit=take_profit,
                reason=<span class="str">f'EMA cross up, ADX={adx:.0f}, ATR={atr:.2f}'</span>
            )

        <span class="cm"># EXIT: EMA cross down OR trailing stop</span>
        <span class="kw">if</span> self.in_position:
            self.highest_since_entry = <span class="fn">max</span>(
                self.highest_since_entry, price
            )
            trailing_stop = self.highest_since_entry * (
                <span class="num">1</span> - self.trailing_stop_pct
            )

            <span class="kw">if</span> latest[<span class="str">'ema_cross_down'</span>] <span class="kw">or</span> price &lt; trailing_stop:
                pnl = (price - self.entry_price) / self.entry_price
                reason = (
                    <span class="str">'EMA cross down'</span> <span class="kw">if</span> latest[<span class="str">'ema_cross_down'</span>]
                    <span class="kw">else</span> <span class="str">f'Trailing stop (from ${self.highest_since_entry:.2f})'</span>
                )
                <span class="kw">return</span> Signal(
                    action=<span class="str">'sell'</span>, symbol=self.symbol,
                    price=price,
                    reason=<span class="str">f'{reason}, PnL: {pnl*100:.1f}%'</span>
                )

        <span class="kw">return</span> Signal(action=<span class="str">'hold'</span>, symbol=self.symbol, price=price)

    <span class="kw">def</span> <span class="fn">on_fill</span>(self, order: Dict):
        <span class="kw">if</span> order.get(<span class="str">'side'</span>) == <span class="str">'buy'</span>:
            self.in_position = <span class="num">True</span>
            self.entry_price = order[<span class="str">'price'</span>]
            self.highest_since_entry = order[<span class="str">'price'</span>]
        <span class="kw">elif</span> order.get(<span class="str">'side'</span>) == <span class="str">'sell'</span>:
            self.in_position = <span class="num">False</span><span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>

    <!-- FUNDING RATE ARB -->
    <div class="collapsible">
      <button class="collapsible-toggle">
        üí∞ Funding Rate Arbitrage Bot ‚Äî Full Implementation
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div>
            <span class="difficulty-badge advanced">üî¥ Advanced</span>
            <span class="time-badge">‚è± 6‚Äì10 hours to implement</span>
          </div>
          <p>Delta-neutral strategy: Long spot + Short perpetual futures. Collect funding payments every 8 hours. The most reliable strategy for consistent returns (15‚Äì30% APY).</p>

          <div class="code-block"><pre><code><span class="cm"># strategies/funding_arb.py ‚Äî Funding Rate Arbitrage Bot</span>
<span class="kw">import</span> ccxt
<span class="kw">import</span> time
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Optional
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass
<span class="kw">from</span> loguru <span class="kw">import</span> logger


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">ArbPosition</span>:
    symbol: <span class="cls">str</span>
    spot_amount: <span class="cls">float</span>
    futures_amount: <span class="cls">float</span>
    entry_spot_price: <span class="cls">float</span>
    entry_futures_price: <span class="cls">float</span>
    total_funding_collected: <span class="cls">float</span> = <span class="num">0.0</span>
    opened_at: <span class="cls">str</span> = <span class="str">''</span>


<span class="kw">class</span> <span class="cls">FundingArbBot</span>:
    <span class="str">"""
    Funding Rate Arbitrage Bot
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    1. Monitor funding rates across symbols
    2. When rate is high (&gt;0.01%): Buy spot + Short perp
    3. Collect funding every 8 hours
    4. Close when rate turns negative or below threshold
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, exchange: ccxt.Exchange, params: Dict = <span class="num">None</span>):
        self.exchange = exchange
        params = params <span class="kw">or</span> {}
        self.min_funding_rate = params.get(<span class="str">'min_funding_rate'</span>, <span class="num">0.0001</span>)
        self.close_threshold = params.get(<span class="str">'close_threshold'</span>, <span class="num">-0.0001</span>)
        self.position_size_usdt = params.get(<span class="str">'position_size_usdt'</span>, <span class="num">5000</span>)
        self.max_positions = params.get(<span class="str">'max_positions'</span>, <span class="num">3</span>)
        self.symbols = params.get(<span class="str">'symbols'</span>, [
            <span class="str">'BTC/USDT'</span>, <span class="str">'ETH/USDT'</span>, <span class="str">'SOL/USDT'</span>,
            <span class="str">'BNB/USDT'</span>, <span class="str">'DOGE/USDT'</span>
        ])
        self.positions: List[ArbPosition] = []
        self.total_funding_earned = <span class="num">0.0</span>

    <span class="kw">def</span> <span class="fn">get_funding_rates</span>(self) -&gt; Dict[<span class="cls">str</span>, <span class="cls">float</span>]:
        <span class="str">"""Fetch current funding rates for monitored symbols."""</span>
        rates = {}
        <span class="kw">for</span> symbol <span class="kw">in</span> self.symbols:
            <span class="kw">try</span>:
                <span class="cm"># Switch to futures market temporarily</span>
                self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'future'</span>
                funding = self.exchange.fetch_funding_rate(symbol)
                rate = funding.get(<span class="str">'fundingRate'</span>, <span class="num">0</span>)
                rates[symbol] = rate

                <span class="kw">if</span> rate &gt; self.min_funding_rate:
                    apy = rate * <span class="num">3</span> * <span class="num">365</span> * <span class="num">100</span>  <span class="cm"># 3x/day √ó 365 days</span>
                    logger.info(
                        <span class="str">f"üìä {symbol}: {rate*100:.4f}% ({apy:.1f}% APY)"</span>
                    )
            <span class="kw">except</span> Exception <span class="kw">as</span> e:
                logger.warning(<span class="str">f"Error fetching {symbol} funding: {e}"</span>)
            <span class="kw">finally</span>:
                self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'spot'</span>

        <span class="kw">return</span> rates

    <span class="kw">def</span> <span class="fn">open_arb_position</span>(self, symbol: <span class="cls">str</span>):
        <span class="str">"""Open a delta-neutral position: long spot + short perp."""</span>
        <span class="kw">if</span> <span class="fn">len</span>(self.positions) &gt;= self.max_positions:
            logger.warning(<span class="str">"Max positions reached"</span>)
            <span class="kw">return</span>

        <span class="kw">try</span>:
            <span class="cm"># Get current prices</span>
            ticker = self.exchange.fetch_ticker(symbol)
            price = ticker[<span class="str">'last'</span>]
            amount = self.position_size_usdt / price

            <span class="cm"># 1. Buy spot</span>
            self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'spot'</span>
            spot_order = self.exchange.create_market_buy_order(
                symbol, amount
            )
            logger.info(<span class="str">f"üìà Bought {amount:.6f} {symbol} spot"</span>)

            <span class="cm"># 2. Short perpetual futures</span>
            self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'future'</span>
            futures_order = self.exchange.create_market_sell_order(
                symbol, amount
            )
            logger.info(<span class="str">f"üìâ Shorted {amount:.6f} {symbol} perp"</span>)

            <span class="cm"># Record position</span>
            position = ArbPosition(
                symbol=symbol,
                spot_amount=amount,
                futures_amount=amount,
                entry_spot_price=spot_order.get(<span class="str">'average'</span>, price),
                entry_futures_price=futures_order.get(<span class="str">'average'</span>, price),
                opened_at=pd.Timestamp.now().isoformat()
            )
            self.positions.append(position)
            logger.info(
                <span class="str">f"‚úÖ Arb position opened: {symbol} | "</span>
                <span class="str">f"Size: ${self.position_size_usdt}"</span>
            )

        <span class="kw">except</span> Exception <span class="kw">as</span> e:
            logger.error(<span class="str">f"Failed to open arb position: {e}"</span>)
        <span class="kw">finally</span>:
            self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'spot'</span>

    <span class="kw">def</span> <span class="fn">close_arb_position</span>(self, position: ArbPosition):
        <span class="str">"""Close both legs of the arb position."""</span>
        <span class="kw">try</span>:
            <span class="cm"># 1. Sell spot</span>
            self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'spot'</span>
            self.exchange.create_market_sell_order(
                position.symbol, position.spot_amount
            )

            <span class="cm"># 2. Close futures short (buy to cover)</span>
            self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'future'</span>
            self.exchange.create_market_buy_order(
                position.symbol, position.futures_amount
            )

            self.total_funding_earned += position.total_funding_collected
            self.positions.remove(position)
            logger.info(
                <span class="str">f"üî¥ Closed arb: {position.symbol} | "</span>
                <span class="str">f"Funding earned: ${position.total_funding_collected:.2f}"</span>
            )

        <span class="kw">except</span> Exception <span class="kw">as</span> e:
            logger.error(<span class="str">f"Failed to close arb position: {e}"</span>)
        <span class="kw">finally</span>:
            self.exchange.options[<span class="str">'defaultType'</span>] = <span class="str">'spot'</span>

    <span class="kw">def</span> <span class="fn">run_cycle</span>(self):
        <span class="str">"""Main bot cycle ‚Äî run every few minutes."""</span>
        rates = self.get_funding_rates()

        <span class="cm"># Check for new opportunities</span>
        <span class="kw">for</span> symbol, rate <span class="kw">in</span> <span class="fn">sorted</span>(
            rates.items(), key=<span class="kw">lambda</span> x: x[<span class="num">1</span>], reverse=<span class="num">True</span>
        ):
            active_symbols = [p.symbol <span class="kw">for</span> p <span class="kw">in</span> self.positions]
            <span class="kw">if</span> (rate &gt; self.min_funding_rate
                    <span class="kw">and</span> symbol <span class="kw">not in</span> active_symbols):
                self.open_arb_position(symbol)

        <span class="cm"># Check existing positions for exit</span>
        <span class="kw">for</span> pos <span class="kw">in</span> self.positions[:]:
            current_rate = rates.get(pos.symbol, <span class="num">0</span>)
            <span class="kw">if</span> current_rate &lt; self.close_threshold:
                logger.info(
                    <span class="str">f"‚ö†Ô∏è Funding flipped negative for {pos.symbol}"</span>
                )
                self.close_arb_position(pos)

    <span class="kw">def</span> <span class="fn">get_stats</span>(self) -&gt; Dict:
        <span class="kw">return</span> {
            <span class="str">'active_positions'</span>: <span class="fn">len</span>(self.positions),
            <span class="str">'total_funding_earned'</span>: self.total_funding_earned,
            <span class="str">'positions'</span>: [
                {<span class="str">'symbol'</span>: p.symbol, <span class="str">'funding'</span>: p.total_funding_collected}
                <span class="kw">for</span> p <span class="kw">in</span> self.positions
            ]
        }<span class="code-label">Python</span></code></pre></div>

          <div class="callout warning">
            ‚ö†Ô∏è <strong>Important:</strong> This strategy requires funds on both spot AND futures accounts. Split your capital 50/50. Monitor margin levels closely ‚Äî a sharp price move can liquidate the futures side even though you're delta-neutral if margin is insufficient.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- A5: RISK MANAGEMENT MODULE -->
  <section class="section" id="a5">
    <div class="section-header">
      <span class="section-num">A.5</span>
      <h2>Risk Management Module</h2>
    </div>
    <div>
      <span class="difficulty-badge intermediate">üü° Intermediate</span>
      <span class="time-badge">‚è± 4‚Äì5 hours</span>
    </div>

    <div class="collapsible open">
      <button class="collapsible-toggle">
        Complete Risk Manager with Circuit Breakers
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="code-block"><pre><code><span class="cm"># risk/risk_manager.py ‚Äî Complete risk management module</span>
<span class="kw">import</span> time
<span class="kw">from</span> datetime <span class="kw">import</span> datetime, date
<span class="kw">from</span> typing <span class="kw">import</span> Dict, Optional
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass, field
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">from</span> config.settings <span class="kw">import</span> settings


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">DailyStats</span>:
    date: <span class="cls">str</span> = <span class="str">''</span>
    starting_balance: <span class="cls">float</span> = <span class="num">0.0</span>
    current_balance: <span class="cls">float</span> = <span class="num">0.0</span>
    realized_pnl: <span class="cls">float</span> = <span class="num">0.0</span>
    trades_today: <span class="cls">int</span> = <span class="num">0</span>
    wins: <span class="cls">int</span> = <span class="num">0</span>
    losses: <span class="cls">int</span> = <span class="num">0</span>
    consecutive_losses: <span class="cls">int</span> = <span class="num">0</span>
    max_drawdown_today: <span class="cls">float</span> = <span class="num">0.0</span>

    <span class="dec">@property</span>
    <span class="kw">def</span> <span class="fn">daily_pnl_pct</span>(self) -&gt; <span class="cls">float</span>:
        <span class="kw">if</span> self.starting_balance == <span class="num">0</span>:
            <span class="kw">return</span> <span class="num">0</span>
        <span class="kw">return</span> (
            (self.current_balance - self.starting_balance)
            / self.starting_balance
        )


<span class="kw">class</span> <span class="cls">RiskManager</span>:
    <span class="str">"""
    Production risk management with:
    - Position sizing (fixed fractional)
    - Daily loss limits
    - Drawdown monitoring
    - Circuit breakers
    - Consecutive loss tracking
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, initial_balance: <span class="cls">float</span>):
        self.initial_balance = initial_balance
        self.peak_balance = initial_balance
        self.current_balance = initial_balance
        self.daily_stats = DailyStats(
            date=date.today().isoformat(),
            starting_balance=initial_balance,
            current_balance=initial_balance
        )
        self.is_halted = <span class="num">False</span>
        self.halt_reason = <span class="str">''</span>

    <span class="kw">def</span> <span class="fn">calculate_position_size</span>(
        self,
        entry_price: <span class="cls">float</span>,
        stop_loss_price: <span class="cls">float</span>,
        risk_pct: Optional[<span class="cls">float</span>] = <span class="num">None</span>
    ) -&gt; <span class="cls">float</span>:
        <span class="str">"""Calculate position size based on risk percentage."""</span>
        risk = risk_pct <span class="kw">or</span> settings.risk.max_risk_per_trade
        risk_amount = self.current_balance * risk

        <span class="cm"># Distance to stop loss</span>
        sl_distance = <span class="fn">abs</span>(entry_price - stop_loss_price)
        <span class="kw">if</span> sl_distance == <span class="num">0</span>:
            logger.error(<span class="str">"Stop loss = entry price!"</span>)
            <span class="kw">return</span> <span class="num">0</span>

        sl_pct = sl_distance / entry_price
        position_size = risk_amount / sl_distance

        <span class="cm"># Enforce max position size</span>
        max_position = self.current_balance * settings.risk.max_position_pct
        position_value = position_size * entry_price
        <span class="kw">if</span> position_value &gt; max_position:
            position_size = max_position / entry_price
            logger.warning(
                <span class="str">f"Position capped at {settings.risk.max_position_pct*100}%"</span>
            )

        logger.debug(
            <span class="str">f"Position size: {position_size:.6f} | "</span>
            <span class="str">f"Risk: ${risk_amount:.2f} ({risk*100}%) | "</span>
            <span class="str">f"SL: {sl_pct*100:.1f}%"</span>
        )
        <span class="kw">return</span> position_size

    <span class="kw">def</span> <span class="fn">can_trade</span>(self) -&gt; <span class="cls">tuple</span>[<span class="cls">bool</span>, <span class="cls">str</span>]:
        <span class="str">"""Check all risk conditions before allowing a trade."""</span>
        <span class="cm"># Reset daily stats if new day</span>
        today = date.today().isoformat()
        <span class="kw">if</span> self.daily_stats.date != today:
            self.daily_stats = DailyStats(
                date=today,
                starting_balance=self.current_balance,
                current_balance=self.current_balance
            )
            self.is_halted = <span class="num">False</span>

        <span class="kw">if</span> self.is_halted:
            <span class="kw">return</span> <span class="num">False</span>, <span class="str">f"HALTED: {self.halt_reason}"</span>

        <span class="cm"># Check daily loss limit</span>
        <span class="kw">if</span> self.daily_stats.daily_pnl_pct &lt;= -settings.risk.max_daily_loss:
            self._halt(<span class="str">f"Daily loss limit hit: "</span>
                       <span class="str">f"{self.daily_stats.daily_pnl_pct*100:.1f}%"</span>)
            <span class="kw">return</span> <span class="num">False</span>, self.halt_reason

        <span class="cm"># Check total drawdown</span>
        drawdown = (self.peak_balance - self.current_balance) / self.peak_balance
        <span class="kw">if</span> drawdown &gt;= settings.risk.max_total_drawdown:
            self._halt(<span class="str">f"Max drawdown hit: {drawdown*100:.1f}%"</span>)
            <span class="kw">return</span> <span class="num">False</span>, self.halt_reason

        <span class="cm"># Check max trades per day</span>
        <span class="kw">if</span> self.daily_stats.trades_today &gt;= settings.risk.max_trades_per_day:
            <span class="kw">return</span> <span class="num">False</span>, <span class="str">"Max daily trades reached"</span>

        <span class="cm"># Check consecutive losses</span>
        <span class="kw">if</span> (self.daily_stats.consecutive_losses
                &gt;= settings.risk.max_consecutive_losses):
            self._halt(
                <span class="str">f"{self.daily_stats.consecutive_losses} "</span>
                <span class="str">f"consecutive losses"</span>
            )
            <span class="kw">return</span> <span class="num">False</span>, self.halt_reason

        <span class="kw">return</span> <span class="num">True</span>, <span class="str">"OK"</span>

    <span class="kw">def</span> <span class="fn">record_trade</span>(self, pnl: <span class="cls">float</span>):
        <span class="str">"""Record a completed trade."""</span>
        self.current_balance += pnl
        self.daily_stats.current_balance = self.current_balance
        self.daily_stats.realized_pnl += pnl
        self.daily_stats.trades_today += <span class="num">1</span>

        <span class="kw">if</span> pnl &gt;= <span class="num">0</span>:
            self.daily_stats.wins += <span class="num">1</span>
            self.daily_stats.consecutive_losses = <span class="num">0</span>
        <span class="kw">else</span>:
            self.daily_stats.losses += <span class="num">1</span>
            self.daily_stats.consecutive_losses += <span class="num">1</span>

        <span class="cm"># Update peak balance</span>
        <span class="kw">if</span> self.current_balance &gt; self.peak_balance:
            self.peak_balance = self.current_balance

        <span class="cm"># Track max daily drawdown</span>
        daily_dd = <span class="fn">abs</span>(<span class="fn">min</span>(<span class="num">0</span>, self.daily_stats.daily_pnl_pct))
        self.daily_stats.max_drawdown_today = <span class="fn">max</span>(
            self.daily_stats.max_drawdown_today, daily_dd
        )

    <span class="kw">def</span> <span class="fn">_halt</span>(self, reason: <span class="cls">str</span>):
        <span class="str">"""Emergency halt all trading."""</span>
        self.is_halted = <span class="num">True</span>
        self.halt_reason = reason
        logger.error(<span class="str">f"üö® CIRCUIT BREAKER: {reason}"</span>)

    <span class="kw">def</span> <span class="fn">get_report</span>(self) -&gt; Dict:
        <span class="str">"""Generate risk report."""</span>
        drawdown = (
            (self.peak_balance - self.current_balance) / self.peak_balance
            <span class="kw">if</span> self.peak_balance &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>
        )
        <span class="kw">return</span> {
            <span class="str">'balance'</span>: <span class="fn">round</span>(self.current_balance, <span class="num">2</span>),
            <span class="str">'peak'</span>: <span class="fn">round</span>(self.peak_balance, <span class="num">2</span>),
            <span class="str">'drawdown_pct'</span>: <span class="fn">round</span>(drawdown * <span class="num">100</span>, <span class="num">2</span>),
            <span class="str">'daily_pnl'</span>: <span class="fn">round</span>(self.daily_stats.realized_pnl, <span class="num">2</span>),
            <span class="str">'daily_pnl_pct'</span>: <span class="fn">round</span>(self.daily_stats.daily_pnl_pct * <span class="num">100</span>, <span class="num">2</span>),
            <span class="str">'trades_today'</span>: self.daily_stats.trades_today,
            <span class="str">'win_rate'</span>: (
                self.daily_stats.wins / self.daily_stats.trades_today * <span class="num">100</span>
                <span class="kw">if</span> self.daily_stats.trades_today &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>
            ),
            <span class="str">'halted'</span>: self.is_halted,
            <span class="str">'halt_reason'</span>: self.halt_reason,
        }<span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>
  </section>

  <!-- A6: BACKTESTING FRAMEWORK -->
  <section class="section" id="a6">
    <div class="section-header">
      <span class="section-num">A.6</span>
      <h2>Backtesting Framework</h2>
    </div>
    <div>
      <span class="difficulty-badge intermediate">üü° Intermediate</span>
      <span class="time-badge">‚è± 5‚Äì8 hours</span>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        Custom Backtesting Engine
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="code-block"><pre><code><span class="cm"># backtest/engine.py ‚Äî Simple but effective backtesting engine</span>
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Callable
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass, field
<span class="kw">from</span> loguru <span class="kw">import</span> logger


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">BacktestResult</span>:
    total_return: <span class="cls">float</span> = <span class="num">0.0</span>
    sharpe_ratio: <span class="cls">float</span> = <span class="num">0.0</span>
    max_drawdown: <span class="cls">float</span> = <span class="num">0.0</span>
    win_rate: <span class="cls">float</span> = <span class="num">0.0</span>
    profit_factor: <span class="cls">float</span> = <span class="num">0.0</span>
    total_trades: <span class="cls">int</span> = <span class="num">0</span>
    avg_trade_pnl: <span class="cls">float</span> = <span class="num">0.0</span>
    max_consecutive_losses: <span class="cls">int</span> = <span class="num">0</span>
    equity_curve: List[<span class="cls">float</span>] = field(default_factory=<span class="cls">list</span>)
    trades: List[Dict] = field(default_factory=<span class="cls">list</span>)


<span class="kw">class</span> <span class="cls">BacktestEngine</span>:
    <span class="str">"""
    Event-driven backtesting engine.
    Handles: position tracking, fees, slippage, P&amp;L calculation.
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, initial_capital: <span class="cls">float</span> = <span class="num">10000</span>,
                 fee_rate: <span class="cls">float</span> = <span class="num">0.001</span>,
                 slippage_pct: <span class="cls">float</span> = <span class="num">0.0005</span>):
        self.initial_capital = initial_capital
        self.fee_rate = fee_rate
        self.slippage_pct = slippage_pct

    <span class="kw">def</span> <span class="fn">run</span>(self, df: pd.DataFrame,
            strategy_fn: Callable[[pd.DataFrame, <span class="cls">int</span>], Dict]
    ) -&gt; BacktestResult:
        <span class="str">"""
        Run backtest.

        strategy_fn(df, index) should return:
        {'action': 'buy'/'sell'/'hold', 'amount': float}
        """</span>
        capital = self.initial_capital
        position = <span class="num">0.0</span>
        entry_price = <span class="num">0.0</span>
        equity_curve = [capital]
        trades = []
        peak = capital

        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="num">50</span>, <span class="fn">len</span>(df)):  <span class="cm"># Skip warmup period</span>
            signal = strategy_fn(df, i)
            price = df[<span class="str">'close'</span>].iloc[i]

            <span class="kw">if</span> signal[<span class="str">'action'</span>] == <span class="str">'buy'</span> <span class="kw">and</span> position == <span class="num">0</span>:
                <span class="cm"># Apply slippage (worse price for buyer)</span>
                exec_price = price * (<span class="num">1</span> + self.slippage_pct)
                amount = (capital * <span class="num">0.95</span>) / exec_price  <span class="cm"># 95% of capital</span>
                fee = amount * exec_price * self.fee_rate
                position = amount
                entry_price = exec_price
                capital -= fee

            <span class="kw">elif</span> signal[<span class="str">'action'</span>] == <span class="str">'sell'</span> <span class="kw">and</span> position &gt; <span class="num">0</span>:
                exec_price = price * (<span class="num">1</span> - self.slippage_pct)
                revenue = position * exec_price
                fee = revenue * self.fee_rate
                pnl = revenue - (position * entry_price) - fee
                capital += revenue - fee
                trades.append({
                    <span class="str">'entry_price'</span>: entry_price,
                    <span class="str">'exit_price'</span>: exec_price,
                    <span class="str">'pnl'</span>: pnl,
                    <span class="str">'pnl_pct'</span>: pnl / (position * entry_price),
                })
                position = <span class="num">0.0</span>
                entry_price = <span class="num">0.0</span>

            <span class="cm"># Update equity</span>
            equity = capital + (position * price)
            equity_curve.append(equity)
            peak = <span class="fn">max</span>(peak, equity)

        <span class="cm"># Calculate metrics</span>
        equity_series = pd.Series(equity_curve)
        returns = equity_series.pct_change().dropna()
        drawdowns = (equity_series - equity_series.cummax()) / equity_series.cummax()

        winning = [t <span class="kw">for</span> t <span class="kw">in</span> trades <span class="kw">if</span> t[<span class="str">'pnl'</span>] &gt; <span class="num">0</span>]
        losing = [t <span class="kw">for</span> t <span class="kw">in</span> trades <span class="kw">if</span> t[<span class="str">'pnl'</span>] &lt;= <span class="num">0</span>]

        gross_profit = <span class="fn">sum</span>(t[<span class="str">'pnl'</span>] <span class="kw">for</span> t <span class="kw">in</span> winning) <span class="kw">if</span> winning <span class="kw">else</span> <span class="num">0</span>
        gross_loss = <span class="fn">abs</span>(<span class="fn">sum</span>(t[<span class="str">'pnl'</span>] <span class="kw">for</span> t <span class="kw">in</span> losing)) <span class="kw">if</span> losing <span class="kw">else</span> <span class="num">1</span>

        <span class="cm"># Max consecutive losses</span>
        max_consec = <span class="num">0</span>
        current_consec = <span class="num">0</span>
        <span class="kw">for</span> t <span class="kw">in</span> trades:
            <span class="kw">if</span> t[<span class="str">'pnl'</span>] &lt;= <span class="num">0</span>:
                current_consec += <span class="num">1</span>
                max_consec = <span class="fn">max</span>(max_consec, current_consec)
            <span class="kw">else</span>:
                current_consec = <span class="num">0</span>

        <span class="kw">return</span> BacktestResult(
            total_return=(equity_curve[-<span class="num">1</span>] - self.initial_capital) / self.initial_capital,
            sharpe_ratio=(
                returns.mean() / returns.std() * np.sqrt(<span class="num">252</span>)
                <span class="kw">if</span> returns.std() &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>
            ),
            max_drawdown=drawdowns.min(),
            win_rate=<span class="fn">len</span>(winning) / <span class="fn">len</span>(trades) <span class="kw">if</span> trades <span class="kw">else</span> <span class="num">0</span>,
            profit_factor=gross_profit / gross_loss <span class="kw">if</span> gross_loss &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>,
            total_trades=<span class="fn">len</span>(trades),
            avg_trade_pnl=np.mean([t[<span class="str">'pnl'</span>] <span class="kw">for</span> t <span class="kw">in</span> trades]) <span class="kw">if</span> trades <span class="kw">else</span> <span class="num">0</span>,
            max_consecutive_losses=max_consec,
            equity_curve=equity_curve,
            trades=trades,
        )

    <span class="kw">def</span> <span class="fn">print_report</span>(self, result: BacktestResult):
        <span class="str">"""Print a formatted backtest report."""</span>
        logger.info(<span class="str">f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       BACKTEST REPORT                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Total Return:    {result.total_return*100:>8.2f}%          ‚ïë
‚ïë  Sharpe Ratio:    {result.sharpe_ratio:>8.2f}           ‚ïë
‚ïë  Max Drawdown:    {result.max_drawdown*100:>8.2f}%          ‚ïë
‚ïë  Win Rate:        {result.win_rate*100:>8.1f}%          ‚ïë
‚ïë  Profit Factor:   {result.profit_factor:>8.2f}           ‚ïë
‚ïë  Total Trades:    {result.total_trades:>8d}            ‚ïë
‚ïë  Avg Trade PnL:  ${result.avg_trade_pnl:>8.2f}           ‚ïë
‚ïë  Max Consec Loss: {result.max_consecutive_losses:>8d}            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """</span>)<span class="code-label">Python</span></code></pre></div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        VectorBT Backtesting with Walk-Forward Analysis
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>VectorBT is the fastest Python backtesting library ‚Äî it uses NumPy vectorization to run millions of backtests in seconds. Here's a complete walk-forward analysis pipeline.</p>

          <div class="code-block"><pre><code><span class="cm"># backtest/vectorbt_walkforward.py ‚Äî VectorBT Walk-Forward Analysis</span>
<span class="cm"># pip install vectorbt pandas numpy</span>
<span class="kw">import</span> vectorbt <span class="kw">as</span> vbt
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Tuple
<span class="kw">from</span> loguru <span class="kw">import</span> logger


<span class="kw">class</span> <span class="cls">VectorBTWalkForward</span>:
    <span class="str">"""
    Walk-Forward Analysis with VectorBT
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    1. Split data into in-sample (IS) and out-of-sample (OOS) windows
    2. Optimize parameters on IS data
    3. Validate on OOS data
    4. Roll forward and repeat
    5. Aggregate OOS results for realistic performance estimate
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(
        self,
        data: pd.DataFrame,
        is_ratio: <span class="cls">float</span> = <span class="num">0.7</span>,
        n_splits: <span class="cls">int</span> = <span class="num">5</span>,
        fee_rate: <span class="cls">float</span> = <span class="num">0.001</span>,
    ):
        self.data = data
        self.is_ratio = is_ratio
        self.n_splits = n_splits
        self.fee_rate = fee_rate
        self.results: List[Dict] = []

    <span class="kw">def</span> <span class="fn">_generate_windows</span>(self) -&gt; List[Tuple[pd.DataFrame, pd.DataFrame]]:
        <span class="str">"""Generate IS/OOS window pairs."""</span>
        total_len = <span class="fn">len</span>(self.data)
        window_size = total_len // self.n_splits
        is_size = <span class="fn">int</span>(window_size * self.is_ratio)
        oos_size = window_size - is_size

        windows = []
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(self.n_splits):
            start = i * oos_size  <span class="cm"># Anchored walk-forward</span>
            is_end = start + is_size
            oos_end = is_end + oos_size

            <span class="kw">if</span> oos_end &gt; total_len:
                <span class="kw">break</span>

            is_data = self.data.iloc[start:is_end]
            oos_data = self.data.iloc[is_end:oos_end]
            windows.append((is_data, oos_data))
            logger.info(
                <span class="str">f"Window {i+1}: IS={is_data.index[0].date()}-&gt;"</span>
                <span class="str">f"{is_data.index[-1].date()}, "</span>
                <span class="str">f"OOS={oos_data.index[0].date()}-&gt;"</span>
                <span class="str">f"{oos_data.index[-1].date()}"</span>
            )
        <span class="kw">return</span> windows

    <span class="kw">def</span> <span class="fn">_optimize_sma_crossover</span>(
        self, prices: pd.Series
    ) -&gt; Tuple[<span class="cls">int</span>, <span class="cls">int</span>]:
        <span class="str">"""Find best SMA fast/slow combo on in-sample data."""</span>
        fast_windows = np.arange(<span class="num">5</span>, <span class="num">50</span>, <span class="num">5</span>)
        slow_windows = np.arange(<span class="num">20</span>, <span class="num">200</span>, <span class="num">10</span>)

        <span class="cm"># VectorBT runs ALL combinations in parallel ‚Äî blazing fast</span>
        fast_ma, slow_ma = vbt.MA.run_combs(
            prices,
            window=fast_windows,
            r=<span class="num">2</span>,   <span class="cm"># pairwise combos</span>
            short_names=[<span class="str">'fast'</span>, <span class="str">'slow'</span>]
        )

        <span class="cm"># Generate entry/exit signals</span>
        entries = fast_ma.ma_crossed_above(slow_ma)
        exits = fast_ma.ma_crossed_below(slow_ma)

        <span class="cm"># Run portfolio simulation</span>
        pf = vbt.Portfolio.from_signals(
            prices,
            entries=entries,
            exits=exits,
            fees=self.fee_rate,
            freq=<span class="str">'1h'</span>,
        )

        <span class="cm"># Find best by Sharpe ratio</span>
        sharpe = pf.sharpe_ratio()
        best_idx = sharpe.idxmax()

        <span class="kw">if</span> <span class="fn">isinstance</span>(best_idx, <span class="cls">tuple</span>):
            best_fast = best_idx[<span class="num">0</span>]
            best_slow = best_idx[<span class="num">1</span>]
        <span class="kw">else</span>:
            best_fast, best_slow = <span class="num">10</span>, <span class="num">50</span>  <span class="cm"># fallback</span>

        logger.info(
            <span class="str">f"  Best IS params: fast={best_fast}, slow={best_slow}, "</span>
            <span class="str">f"Sharpe={sharpe[best_idx]:.2f}"</span>
        )
        <span class="kw">return</span> <span class="fn">int</span>(best_fast), <span class="fn">int</span>(best_slow)

    <span class="kw">def</span> <span class="fn">_backtest_window</span>(
        self, prices: pd.Series, fast: <span class="cls">int</span>, slow: <span class="cls">int</span>
    ) -&gt; Dict:
        <span class="str">"""Run single backtest with given parameters."""</span>
        fast_ma = vbt.MA.run(prices, window=fast)
        slow_ma = vbt.MA.run(prices, window=slow)

        entries = fast_ma.ma_crossed_above(slow_ma)
        exits = fast_ma.ma_crossed_below(slow_ma)

        pf = vbt.Portfolio.from_signals(
            prices, entries=entries, exits=exits,
            fees=self.fee_rate, freq=<span class="str">'1h'</span>,
        )

        <span class="kw">return</span> {
            <span class="str">'total_return'</span>: pf.total_return(),
            <span class="str">'sharpe_ratio'</span>: pf.sharpe_ratio(),
            <span class="str">'max_drawdown'</span>: pf.max_drawdown(),
            <span class="str">'total_trades'</span>: pf.stats(<span class="str">'total_trades'</span>),
            <span class="str">'win_rate'</span>: pf.stats(<span class="str">'win_rate'</span>),
            <span class="str">'profit_factor'</span>: pf.stats(<span class="str">'profit_factor'</span>),
        }

    <span class="kw">def</span> <span class="fn">run</span>(self) -&gt; Dict:
        <span class="str">"""Execute full walk-forward analysis."""</span>
        windows = self._generate_windows()
        prices = self.data[<span class="str">'close'</span>]

        is_results = []
        oos_results = []

        <span class="kw">for</span> i, (is_data, oos_data) <span class="kw">in</span> <span class="fn">enumerate</span>(windows):
            logger.info(<span class="str">f"\n{'='*50}"</span>)
            logger.info(<span class="str">f"Walk-Forward Window {i+1}/{len(windows)}"</span>)

            <span class="cm"># Step 1: Optimize on IS data</span>
            best_fast, best_slow = self._optimize_sma_crossover(
                is_data[<span class="str">'close'</span>]
            )

            <span class="cm"># Step 2: Backtest on IS data (for comparison)</span>
            is_result = self._backtest_window(
                is_data[<span class="str">'close'</span>], best_fast, best_slow
            )
            is_results.append(is_result)

            <span class="cm"># Step 3: Validate on OOS data (the real test)</span>
            oos_result = self._backtest_window(
                oos_data[<span class="str">'close'</span>], best_fast, best_slow
            )
            oos_result[<span class="str">'fast_window'</span>] = best_fast
            oos_result[<span class="str">'slow_window'</span>] = best_slow
            oos_results.append(oos_result)

            logger.info(
                <span class="str">f"  IS Return: {is_result['total_return']*100:.2f}% | "</span>
                <span class="str">f"OOS Return: {oos_result['total_return']*100:.2f}%"</span>
            )

        self.results = oos_results

        <span class="cm"># Aggregate OOS results</span>
        avg_return = np.mean([r[<span class="str">'total_return'</span>] <span class="kw">for</span> r <span class="kw">in</span> oos_results])
        avg_sharpe = np.mean([r[<span class="str">'sharpe_ratio'</span>] <span class="kw">for</span> r <span class="kw">in</span> oos_results])
        avg_dd = np.mean([r[<span class="str">'max_drawdown'</span>] <span class="kw">for</span> r <span class="kw">in</span> oos_results])

        <span class="cm"># Degradation ratio: OOS / IS performance</span>
        is_avg_return = np.mean([r[<span class="str">'total_return'</span>] <span class="kw">for</span> r <span class="kw">in</span> is_results])
        degradation = (
            avg_return / is_avg_return
            <span class="kw">if</span> is_avg_return != <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>
        )

        summary = {
            <span class="str">'oos_avg_return'</span>: avg_return,
            <span class="str">'oos_avg_sharpe'</span>: avg_sharpe,
            <span class="str">'oos_avg_max_dd'</span>: avg_dd,
            <span class="str">'is_avg_return'</span>: is_avg_return,
            <span class="str">'degradation_ratio'</span>: degradation,
            <span class="str">'is_valid'</span>: degradation &gt; <span class="num">0.5</span>,  <span class="cm"># OOS should be &gt;50% of IS</span>
            <span class="str">'windows'</span>: oos_results,
        }

        logger.info(<span class="str">f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë     WALK-FORWARD ANALYSIS RESULTS        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  OOS Avg Return:   {avg_return*100:>8.2f}%             ‚ïë
‚ïë  OOS Avg Sharpe:   {avg_sharpe:>8.2f}              ‚ïë
‚ïë  OOS Avg Max DD:   {avg_dd*100:>8.2f}%             ‚ïë
‚ïë  IS Avg Return:    {is_avg_return*100:>8.2f}%             ‚ïë
‚ïë  Degradation:      {degradation*100:>8.1f}%             ‚ïë
‚ïë  Valid Strategy:    {'‚úÖ YES' if degradation > 0.5 else '‚ùå NO':>8s}              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """</span>)

        <span class="kw">return</span> summary


<span class="cm"># ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cm"># USAGE EXAMPLE</span>
<span class="cm"># ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">if</span> __name__ == <span class="str">'__main__'</span>:
    <span class="cm"># 1. Download data</span>
    btc = vbt.YFData.download(
        <span class="str">'BTC-USD'</span>,
        start=<span class="str">'2023-01-01'</span>,
        end=<span class="str">'2025-12-31'</span>,
        interval=<span class="str">'1h'</span>,
    ).get()

    <span class="cm"># 2. Run walk-forward analysis</span>
    wfa = VectorBTWalkForward(
        data=btc,
        is_ratio=<span class="num">0.7</span>,
        n_splits=<span class="num">5</span>,
        fee_rate=<span class="num">0.001</span>,
    )
    results = wfa.run()

    <span class="cm"># 3. Quick single-param optimization</span>
    prices = btc[<span class="str">'Close'</span>]
    windows = np.arange(<span class="num">10</span>, <span class="num">100</span>, <span class="num">5</span>)

    fast_ma = vbt.MA.run(prices, window=windows)
    slow_ma = vbt.MA.run(prices, window=windows * <span class="num">3</span>)

    entries = fast_ma.ma_crossed_above(slow_ma)
    exits = fast_ma.ma_crossed_below(slow_ma)

    pf = vbt.Portfolio.from_signals(
        prices, entries=entries, exits=exits,
        fees=<span class="num">0.001</span>, freq=<span class="str">'1h'</span>,
    )

    <span class="cm"># 4. Plot results</span>
    pf.total_return().vbt.plot().show()
    pf.sharpe_ratio().vbt.plot().show()

    <span class="cm"># 5. Best params</span>
    best = pf.sharpe_ratio().idxmax()
    <span class="fn">print</span>(<span class="str">f"Best window: {best}, Sharpe: {pf.sharpe_ratio()[best]:.2f}"</span>)
    <span class="fn">print</span>(<span class="str">f"Return: {pf.total_return()[best]*100:.2f}%"</span>)
    <span class="fn">print</span>(<span class="str">f"Max DD: {pf.max_drawdown()[best]*100:.2f}%"</span>)

    <span class="cm"># 6. Show detailed stats for best combo</span>
    <span class="fn">print</span>(pf[best].stats())<span class="code-label">Python</span></code></pre></div>

          <div class="callout info">
            üí° <strong>Walk-Forward Rule of Thumb:</strong> If your OOS performance is less than 50% of IS performance, the strategy is likely overfit. A degradation ratio of 0.6‚Äì0.8 indicates a robust strategy. Above 0.8 is excellent.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ============================================================ -->
  <!-- ========== A.7: TELEGRAM NOTIFICATION BOT =================== -->
  <!-- ============================================================ -->
  <section class="section" id="a7">
    <div class="section-header">
      <span class="section-num">A.7</span>
      <h2>Telegram Notification Bot</h2>
    </div>
    <div>
      <span class="difficulty-badge beginner">üü¢ Beginner</span>
      <span class="time-badge">‚è± 2‚Äì3 hours</span>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üì± Complete Telegram Bot for Trade Alerts &amp; Monitoring
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>Every serious trading bot needs a notification system. This Telegram bot sends trade alerts, daily P&amp;L summaries, error notifications, and responds to commands for checking status.</p>

          <div class="code-block"><pre><code><span class="cm"># notifications/telegram_bot.py ‚Äî Complete Telegram Trading Notifier</span>
<span class="cm"># pip install python-telegram-bot==20.7 aiohttp</span>
<span class="kw">import</span> asyncio
<span class="kw">import</span> logging
<span class="kw">from</span> datetime <span class="kw">import</span> datetime, timedelta
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Optional
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass, field
<span class="kw">from</span> telegram <span class="kw">import</span> Update, Bot
<span class="kw">from</span> telegram.ext <span class="kw">import</span> (
    Application, CommandHandler, ContextTypes
)
<span class="kw">from</span> loguru <span class="kw">import</span> logger


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">TradeRecord</span>:
    <span class="str">"""Single trade record for P&amp;L tracking."""</span>
    symbol: <span class="cls">str</span>
    side: <span class="cls">str</span>           <span class="cm"># 'buy' or 'sell'</span>
    price: <span class="cls">float</span>
    amount: <span class="cls">float</span>
    pnl: <span class="cls">float</span> = <span class="num">0.0</span>
    timestamp: <span class="cls">str</span> = <span class="str">''</span>
    strategy: <span class="cls">str</span> = <span class="str">''</span>


<span class="kw">class</span> <span class="cls">TradingTelegramBot</span>:
    <span class="str">"""
    Telegram Bot for Trading Notifications
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Features:
    - Trade entry/exit alerts with emoji formatting
    - Daily P&amp;L summary (auto-sent at configurable time)
    - Error/warning notifications
    - /status command for live bot status
    - /pnl command for today's P&amp;L
    - /positions command for open positions
    - /stop command to halt trading (emergency)
    - Rate limiting to avoid Telegram API bans
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(
        self,
        token: <span class="cls">str</span>,
        chat_id: <span class="cls">str</span>,
        bot_name: <span class="cls">str</span> = <span class="str">'Trading Bot'</span>,
    ):
        self.token = token
        self.chat_id = chat_id
        self.bot_name = bot_name
        self.bot = Bot(token=token)
        self.app: Optional[Application] = <span class="num">None</span>

        <span class="cm"># Trade tracking</span>
        self.today_trades: List[TradeRecord] = []
        self.today_pnl: <span class="cls">float</span> = <span class="num">0.0</span>

        <span class="cm"># Rate limiting</span>
        self._last_message_time: <span class="cls">float</span> = <span class="num">0</span>
        self._min_interval: <span class="cls">float</span> = <span class="num">1.0</span>  <span class="cm"># seconds between messages</span>
        self._daily_message_count: <span class="cls">int</span> = <span class="num">0</span>
        self._max_daily_messages: <span class="cls">int</span> = <span class="num">200</span>

        <span class="cm"># Callback for emergency stop</span>
        self.on_emergency_stop = <span class="num">None</span>

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_send</span>(self, text: <span class="cls">str</span>, parse_mode: <span class="cls">str</span> = <span class="str">'HTML'</span>):
        <span class="str">"""Send message with rate limiting."""</span>
        <span class="kw">import</span> time
        now = time.time()
        elapsed = now - self._last_message_time
        <span class="kw">if</span> elapsed &lt; self._min_interval:
            <span class="kw">await</span> asyncio.sleep(self._min_interval - elapsed)

        <span class="kw">if</span> self._daily_message_count &gt;= self._max_daily_messages:
            logger.warning(<span class="str">"Daily message limit reached"</span>)
            <span class="kw">return</span>

        <span class="kw">try</span>:
            <span class="kw">await</span> self.bot.send_message(
                chat_id=self.chat_id,
                text=text,
                parse_mode=parse_mode,
            )
            self._last_message_time = time.time()
            self._daily_message_count += <span class="num">1</span>
        <span class="kw">except</span> Exception <span class="kw">as</span> e:
            logger.error(<span class="str">f"Telegram send error: {e}"</span>)

    <span class="cm"># ‚îÄ‚îÄ‚îÄ NOTIFICATION METHODS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">notify_trade_entry</span>(
        self, symbol: <span class="cls">str</span>, side: <span class="cls">str</span>, price: <span class="cls">float</span>,
        amount: <span class="cls">float</span>, strategy: <span class="cls">str</span> = <span class="str">''</span>,
        stop_loss: <span class="cls">float</span> = <span class="num">0</span>, take_profit: <span class="cls">float</span> = <span class="num">0</span>,
    ):
        <span class="str">"""Send trade entry notification."""</span>
        emoji = <span class="str">'üü¢'</span> <span class="kw">if</span> side == <span class="str">'buy'</span> <span class="kw">else</span> <span class="str">'üî¥'</span>
        action = <span class="str">'LONG'</span> <span class="kw">if</span> side == <span class="str">'buy'</span> <span class="kw">else</span> <span class="str">'SHORT'</span>
        value = price * amount

        text = (
            <span class="str">f"{emoji} &lt;b&gt;{action} {symbol}&lt;/b&gt;\n"</span>
            <span class="str">f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
            <span class="str">f"üí∞ Price: ${price:,.2f}\n"</span>
            <span class="str">f"üì¶ Amount: {amount:.6f}\n"</span>
            <span class="str">f"üíµ Value: ${value:,.2f}\n"</span>
        )
        <span class="kw">if</span> stop_loss:
            text += <span class="str">f"üõë Stop Loss: ${stop_loss:,.2f}\n"</span>
        <span class="kw">if</span> take_profit:
            text += <span class="str">f"üéØ Take Profit: ${take_profit:,.2f}\n"</span>
        <span class="kw">if</span> strategy:
            text += <span class="str">f"ü§ñ Strategy: {strategy}\n"</span>
        text += <span class="str">f"üïê {datetime.now().strftime('%H:%M:%S')}"</span>

        <span class="kw">await</span> self._send(text)

        <span class="cm"># Track the trade</span>
        self.today_trades.append(TradeRecord(
            symbol=symbol, side=side, price=price,
            amount=amount, strategy=strategy,
            timestamp=datetime.now().isoformat(),
        ))

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">notify_trade_exit</span>(
        self, symbol: <span class="cls">str</span>, side: <span class="cls">str</span>, entry_price: <span class="cls">float</span>,
        exit_price: <span class="cls">float</span>, amount: <span class="cls">float</span>, pnl: <span class="cls">float</span>,
        strategy: <span class="cls">str</span> = <span class="str">''</span>,
    ):
        <span class="str">"""Send trade exit notification with P&amp;L."""</span>
        pnl_pct = ((exit_price - entry_price) / entry_price) * <span class="num">100</span>
        emoji = <span class="str">'‚úÖ'</span> <span class="kw">if</span> pnl &gt; <span class="num">0</span> <span class="kw">else</span> <span class="str">'‚ùå'</span>
        pnl_emoji = <span class="str">'üìà'</span> <span class="kw">if</span> pnl &gt; <span class="num">0</span> <span class="kw">else</span> <span class="str">'üìâ'</span>

        text = (
            <span class="str">f"{emoji} &lt;b&gt;CLOSED {symbol}&lt;/b&gt;\n"</span>
            <span class="str">f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
            <span class="str">f"üì• Entry: ${entry_price:,.2f}\n"</span>
            <span class="str">f"üì§ Exit: ${exit_price:,.2f}\n"</span>
            <span class="str">f"{pnl_emoji} P&amp;L: ${pnl:,.2f} ({pnl_pct:+.2f}%)\n"</span>
        )
        <span class="kw">if</span> strategy:
            text += <span class="str">f"ü§ñ Strategy: {strategy}\n"</span>
        text += <span class="str">f"üïê {datetime.now().strftime('%H:%M:%S')}"</span>

        <span class="kw">await</span> self._send(text)
        self.today_pnl += pnl

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">send_daily_summary</span>(
        self, balance: <span class="cls">float</span>, positions: List[Dict] = <span class="num">None</span>,
    ):
        <span class="str">"""Send end-of-day P&amp;L summary."""</span>
        wins = [t <span class="kw">for</span> t <span class="kw">in</span> self.today_trades <span class="kw">if</span> t.pnl &gt; <span class="num">0</span>]
        losses = [t <span class="kw">for</span> t <span class="kw">in</span> self.today_trades <span class="kw">if</span> t.pnl &lt; <span class="num">0</span>]
        total_trades = <span class="fn">len</span>(self.today_trades)
        win_rate = <span class="fn">len</span>(wins) / total_trades * <span class="num">100</span> <span class="kw">if</span> total_trades &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>

        pnl_emoji = <span class="str">'üìà'</span> <span class="kw">if</span> self.today_pnl &gt;= <span class="num">0</span> <span class="kw">else</span> <span class="str">'üìâ'</span>
        text = (
            <span class="str">f"üìä &lt;b&gt;DAILY SUMMARY&lt;/b&gt;\n"</span>
            <span class="str">f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
            <span class="str">f"üìÖ {datetime.now().strftime('%Y-%m-%d')}\n\n"</span>
            <span class="str">f"{pnl_emoji} &lt;b&gt;P&amp;L: ${self.today_pnl:,.2f}&lt;/b&gt;\n"</span>
            <span class="str">f"üîÑ Trades: {total_trades}\n"</span>
            <span class="str">f"‚úÖ Wins: {len(wins)} | ‚ùå Losses: {len(losses)}\n"</span>
            <span class="str">f"üéØ Win Rate: {win_rate:.1f}%\n"</span>
            <span class="str">f"üí∞ Balance: ${balance:,.2f}\n"</span>
        )

        <span class="kw">if</span> positions:
            text += <span class="str">f"\nüìã &lt;b&gt;Open Positions:&lt;/b&gt;\n"</span>
            <span class="kw">for</span> pos <span class="kw">in</span> positions:
                text += (
                    <span class="str">f"  ‚Ä¢ {pos['symbol']}: {pos['side']} "</span>
                    <span class="str">f"${pos.get('unrealized_pnl', 0):+,.2f}\n"</span>
                )

        <span class="kw">await</span> self._send(text)

        <span class="cm"># Reset daily counters</span>
        self.today_trades = []
        self.today_pnl = <span class="num">0.0</span>
        self._daily_message_count = <span class="num">0</span>

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">notify_error</span>(self, error: <span class="cls">str</span>, critical: <span class="cls">bool</span> = <span class="num">False</span>):
        <span class="str">"""Send error notification."""</span>
        emoji = <span class="str">'üö®'</span> <span class="kw">if</span> critical <span class="kw">else</span> <span class="str">'‚ö†Ô∏è'</span>
        level = <span class="str">'CRITICAL'</span> <span class="kw">if</span> critical <span class="kw">else</span> <span class="str">'WARNING'</span>
        text = (
            <span class="str">f"{emoji} &lt;b&gt;{level}&lt;/b&gt;\n"</span>
            <span class="str">f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
            <span class="str">f"{error}\n"</span>
            <span class="str">f"üïê {datetime.now().strftime('%H:%M:%S')}"</span>
        )
        <span class="kw">await</span> self._send(text)

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">notify_circuit_breaker</span>(self, reason: <span class="cls">str</span>):
        <span class="str">"""Send circuit breaker triggered alert."""</span>
        text = (
            <span class="str">f"üõë &lt;b&gt;CIRCUIT BREAKER TRIGGERED&lt;/b&gt;\n"</span>
            <span class="str">f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
            <span class="str">f"‚ö° Reason: {reason}\n"</span>
            <span class="str">f"ü§ñ All trading HALTED\n"</span>
            <span class="str">f"üïê {datetime.now().strftime('%H:%M:%S')}\n\n"</span>
            <span class="str">f"Use /resume to restart trading"</span>
        )
        <span class="kw">await</span> self._send(text)

    <span class="cm"># ‚îÄ‚îÄ‚îÄ COMMAND HANDLERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>

    <span class="kw">def</span> <span class="fn">setup_commands</span>(self, get_status_fn=<span class="num">None</span>, get_positions_fn=<span class="num">None</span>):
        <span class="str">"""Set up interactive bot commands."""</span>
        self.app = Application.builder().token(self.token).build()
        self._get_status = get_status_fn
        self._get_positions = get_positions_fn

        self.app.add_handler(CommandHandler(<span class="str">'status'</span>, self._cmd_status))
        self.app.add_handler(CommandHandler(<span class="str">'pnl'</span>, self._cmd_pnl))
        self.app.add_handler(CommandHandler(<span class="str">'positions'</span>, self._cmd_positions))
        self.app.add_handler(CommandHandler(<span class="str">'stop'</span>, self._cmd_stop))
        self.app.add_handler(CommandHandler(<span class="str">'help'</span>, self._cmd_help))

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_cmd_status</span>(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        <span class="kw">if</span> <span class="fn">str</span>(update.effective_chat.id) != self.chat_id:
            <span class="kw">return</span>  <span class="cm"># Security: only respond to authorized chat</span>

        status = self._get_status() <span class="kw">if</span> self._get_status <span class="kw">else</span> {}
        text = (
            <span class="str">f"ü§ñ &lt;b&gt;{self.bot_name} Status&lt;/b&gt;\n"</span>
            <span class="str">f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
            <span class="str">f"üìä Running: {'‚úÖ' if status.get('running') else '‚ùå'}\n"</span>
            <span class="str">f"üí∞ Balance: ${status.get('balance', 0):,.2f}\n"</span>
            <span class="str">f"üìà Today P&amp;L: ${self.today_pnl:,.2f}\n"</span>
            <span class="str">f"üîÑ Today Trades: {len(self.today_trades)}\n"</span>
            <span class="str">f"‚è∞ Uptime: {status.get('uptime', 'N/A')}"</span>
        )
        <span class="kw">await</span> update.message.reply_text(text, parse_mode=<span class="str">'HTML'</span>)

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_cmd_pnl</span>(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        <span class="kw">if</span> <span class="fn">str</span>(update.effective_chat.id) != self.chat_id:
            <span class="kw">return</span>
        <span class="kw">await</span> update.message.reply_text(
            <span class="str">f"üìä Today's P&amp;L: ${self.today_pnl:,.2f}\n"</span>
            <span class="str">f"üîÑ Trades: {len(self.today_trades)}"</span>,
            parse_mode=<span class="str">'HTML'</span>,
        )

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_cmd_positions</span>(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        <span class="kw">if</span> <span class="fn">str</span>(update.effective_chat.id) != self.chat_id:
            <span class="kw">return</span>
        positions = self._get_positions() <span class="kw">if</span> self._get_positions <span class="kw">else</span> []
        <span class="kw">if not</span> positions:
            <span class="kw">await</span> update.message.reply_text(<span class="str">"üìã No open positions"</span>)
            <span class="kw">return</span>
        text = <span class="str">"üìã &lt;b&gt;Open Positions&lt;/b&gt;\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"</span>
        <span class="kw">for</span> p <span class="kw">in</span> positions:
            text += <span class="str">f"‚Ä¢ {p['symbol']} {p['side']} ${p.get('pnl',0):+,.2f}\n"</span>
        <span class="kw">await</span> update.message.reply_text(text, parse_mode=<span class="str">'HTML'</span>)

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_cmd_stop</span>(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        <span class="kw">if</span> <span class="fn">str</span>(update.effective_chat.id) != self.chat_id:
            <span class="kw">return</span>
        <span class="kw">if</span> self.on_emergency_stop:
            self.on_emergency_stop()
        <span class="kw">await</span> update.message.reply_text(
            <span class="str">"üõë &lt;b&gt;EMERGENCY STOP&lt;/b&gt; ‚Äî All trading halted"</span>,
            parse_mode=<span class="str">'HTML'</span>,
        )

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_cmd_help</span>(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        <span class="kw">await</span> update.message.reply_text(
            <span class="str">"ü§ñ &lt;b&gt;Trading Bot Commands&lt;/b&gt;\n"</span>
            <span class="str">"/status ‚Äî Bot status &amp; balance\n"</span>
            <span class="str">"/pnl ‚Äî Today's P&amp;L\n"</span>
            <span class="str">"/positions ‚Äî Open positions\n"</span>
            <span class="str">"/stop ‚Äî Emergency stop all trading\n"</span>
            <span class="str">"/help ‚Äî Show this message"</span>,
            parse_mode=<span class="str">'HTML'</span>,
        )


<span class="cm"># ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cm"># USAGE EXAMPLE ‚Äî Integration with trading bot</span>
<span class="cm"># ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">async</span> <span class="kw">def</span> <span class="fn">main</span>():
    <span class="cm"># Initialize</span>
    notifier = TradingTelegramBot(
        token=<span class="str">'YOUR_BOT_TOKEN'</span>,
        chat_id=<span class="str">'YOUR_CHAT_ID'</span>,
        bot_name=<span class="str">'Grid Bot v1'</span>,
    )

    <span class="cm"># Send trade alert</span>
    <span class="kw">await</span> notifier.notify_trade_entry(
        symbol=<span class="str">'BTC/USDT'</span>, side=<span class="str">'buy'</span>,
        price=<span class="num">95000.0</span>, amount=<span class="num">0.01</span>,
        strategy=<span class="str">'Grid Bot'</span>,
        stop_loss=<span class="num">93000.0</span>, take_profit=<span class="num">97000.0</span>,
    )

    <span class="cm"># Send exit alert</span>
    <span class="kw">await</span> notifier.notify_trade_exit(
        symbol=<span class="str">'BTC/USDT'</span>, side=<span class="str">'sell'</span>,
        entry_price=<span class="num">95000.0</span>, exit_price=<span class="num">97000.0</span>,
        amount=<span class="num">0.01</span>, pnl=<span class="num">20.0</span>, strategy=<span class="str">'Grid Bot'</span>,
    )

    <span class="cm"># Daily summary</span>
    <span class="kw">await</span> notifier.send_daily_summary(
        balance=<span class="num">10500.0</span>,
        positions=[{<span class="str">'symbol'</span>: <span class="str">'ETH/USDT'</span>, <span class="str">'side'</span>: <span class="str">'long'</span>, <span class="str">'unrealized_pnl'</span>: <span class="num">45.20</span>}],
    )


<span class="kw">if</span> __name__ == <span class="str">'__main__'</span>:
    asyncio.run(main())<span class="code-label">Python</span></code></pre></div>

          <div class="callout success">
            ‚úÖ <strong>Setup Steps:</strong> 1) Message @BotFather on Telegram ‚Üí /newbot ‚Üí get token. 2) Start a chat with your bot. 3) Get your chat ID by messaging @userinfobot. 4) Set the token and chat_id in your config.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ============================================================ -->
  <!-- ========== A.8: DEPLOYMENT GUIDE ============================ -->
  <!-- ============================================================ -->
  <section class="section" id="a8">
    <div class="section-header">
      <span class="section-num">A.8</span>
      <h2>Deployment Guide ‚Äî Docker, VPS &amp; Monitoring</h2>
    </div>
    <div>
      <span class="difficulty-badge intermediate">üü° Intermediate</span>
      <span class="time-badge">‚è± 3‚Äì5 hours</span>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üê≥ Dockerfile &amp; Docker Compose Setup
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>Docker containers ensure your bot runs identically everywhere ‚Äî local dev, staging, and production VPS.</p>

          <div class="code-block"><pre><code><span class="cm"># Dockerfile ‚Äî Multi-stage build for small image</span>
FROM python:3.12-slim AS builder

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

FROM python:3.12-slim

<span class="cm"># Security: non-root user</span>
RUN useradd --create-home botuser
USER botuser
WORKDIR /home/botuser/app

<span class="cm"># Copy installed packages from builder</span>
COPY --from=builder /root/.local /home/botuser/.local
ENV PATH=/home/botuser/.local/bin:$PATH

<span class="cm"># Copy application code</span>
COPY --chown=botuser:botuser . .

<span class="cm"># Health check</span>
HEALTHCHECK --interval=60s --timeout=10s --retries=3 \
  CMD python -c "import requests; requests.get('http://localhost:8080/health')" || exit 1

CMD ["python", "main.py"]<span class="code-label">Dockerfile</span></code></pre></div>

          <div class="code-block"><pre><code><span class="cm"># docker-compose.yml ‚Äî Full production stack</span>
version: '3.8'

services:
  trading-bot:
    build: .
    container_name: trading-bot
    restart: unless-stopped
    env_file: .env
    volumes:
      - ./data:/home/botuser/app/data      <span class="cm"># Persist trade data</span>
      - ./logs:/home/botuser/app/logs      <span class="cm"># Persist logs</span>
    networks:
      - bot-network
    healthcheck:
      test: ["CMD", "python", "-c", "print('ok')"]
      interval: 60s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'

  redis:
    image: redis:7-alpine
    container_name: bot-redis
    restart: unless-stopped
    volumes:
      - redis-data:/data
    networks:
      - bot-network

  prometheus:
    image: prom/prometheus:latest
    container_name: bot-prometheus
    restart: unless-stopped
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    networks:
      - bot-network

  grafana:
    image: grafana/grafana:latest
    container_name: bot-grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    volumes:
      - grafana-data:/var/lib/grafana
    networks:
      - bot-network

volumes:
  redis-data:
  grafana-data:

networks:
  bot-network:
    driver: bridge<span class="code-label">YAML</span></code></pre></div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üñ•Ô∏è VPS Setup &amp; Systemd Service
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>For low-latency trading, deploy to a VPS near your exchange's servers. AWS Tokyo (ap-northeast-1) is ideal for Binance/Bybit.</p>

          <div class="code-block"><pre><code><span class="cm">#!/bin/bash</span>
<span class="cm"># setup_vps.sh ‚Äî Complete VPS setup script for Ubuntu 22.04+</span>
<span class="cm"># Run as root on a fresh VPS</span>

<span class="kw">set</span> -euo pipefail

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Updating system ‚ïê‚ïê‚ïê"</span>
apt update &amp;&amp; apt upgrade -y

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Installing dependencies ‚ïê‚ïê‚ïê"</span>
apt install -y \
    python3.12 python3.12-venv python3-pip \
    docker.io docker-compose-v2 \
    git curl wget htop tmux \
    ufw fail2ban

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Configuring firewall ‚ïê‚ïê‚ïê"</span>
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh
ufw allow 3000/tcp   <span class="cm"># Grafana</span>
ufw --force enable

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Configuring fail2ban ‚ïê‚ïê‚ïê"</span>
systemctl enable fail2ban
systemctl start fail2ban

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Creating bot user ‚ïê‚ïê‚ïê"</span>
useradd -m -s /bin/bash botrunner
usermod -aG docker botrunner

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Setting up swap (2GB) ‚ïê‚ïê‚ïê"</span>
fallocate -l 2G /swapfile
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
<span class="fn">echo</span> <span class="str">'/swapfile none swap sw 0 0'</span> &gt;&gt; /etc/fstab

<span class="fn">echo</span> <span class="str">"‚ïê‚ïê‚ïê Setting timezone ‚ïê‚ïê‚ïê"</span>
timedatectl set-timezone UTC

<span class="fn">echo</span> <span class="str">"‚úÖ VPS setup complete. Login as 'botrunner' to deploy."</span><span class="code-label">Bash</span></code></pre></div>

          <div class="code-block"><pre><code><span class="cm"># /etc/systemd/system/trading-bot.service</span>
<span class="cm"># Systemd service for auto-restart and boot persistence</span>

[Unit]
Description=Crypto Trading Bot
After=network-online.target docker.service
Wants=network-online.target

[Service]
Type=simple
User=botrunner
Group=botrunner
WorkingDirectory=/home/botrunner/trading-bot
ExecStart=/home/botrunner/trading-bot/venv/bin/python main.py
Restart=always
RestartSec=30
StartLimitInterval=300
StartLimitBurst=5

<span class="cm"># Environment</span>
EnvironmentFile=/home/botrunner/trading-bot/.env

<span class="cm"># Logging</span>
StandardOutput=append:/home/botrunner/trading-bot/logs/bot.log
StandardError=append:/home/botrunner/trading-bot/logs/bot-error.log

<span class="cm"># Security hardening</span>
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=/home/botrunner/trading-bot/data /home/botrunner/trading-bot/logs

<span class="cm"># Resource limits</span>
MemoryMax=1G
CPUQuota=50%

[Install]
WantedBy=multi-user.target<span class="code-label">Systemd</span></code></pre></div>

          <div class="code-block"><pre><code><span class="cm"># Enable and manage the service</span>
sudo systemctl daemon-reload
sudo systemctl enable trading-bot
sudo systemctl start trading-bot

<span class="cm"># Check status</span>
sudo systemctl status trading-bot

<span class="cm"># View logs</span>
sudo journalctl -u trading-bot -f

<span class="cm"># Restart after code update</span>
cd /home/botrunner/trading-bot
git pull origin main
sudo systemctl restart trading-bot<span class="code-label">Bash</span></code></pre></div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üìä Health Check &amp; Monitoring Server
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>A lightweight HTTP server that exposes health checks and Prometheus metrics for your trading bot.</p>

          <div class="code-block"><pre><code><span class="cm"># monitoring/health_server.py ‚Äî Health check + metrics endpoint</span>
<span class="cm"># pip install aiohttp prometheus-client</span>
<span class="kw">import</span> asyncio
<span class="kw">import</span> time
<span class="kw">from</span> aiohttp <span class="kw">import</span> web
<span class="kw">from</span> prometheus_client <span class="kw">import</span> (
    Counter, Gauge, Histogram, generate_latest, CONTENT_TYPE_LATEST
)
<span class="kw">from</span> loguru <span class="kw">import</span> logger


<span class="cm"># ‚îÄ‚îÄ‚îÄ Prometheus Metrics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
TRADES_TOTAL = Counter(
    <span class="str">'trading_bot_trades_total'</span>,
    <span class="str">'Total trades executed'</span>,
    [<span class="str">'symbol'</span>, <span class="str">'side'</span>, <span class="str">'strategy'</span>],
)
PNL_TOTAL = Gauge(
    <span class="str">'trading_bot_pnl_total'</span>,
    <span class="str">'Total realized P&amp;L in USD'</span>,
)
BALANCE = Gauge(
    <span class="str">'trading_bot_balance_usd'</span>,
    <span class="str">'Current account balance in USD'</span>,
)
OPEN_POSITIONS = Gauge(
    <span class="str">'trading_bot_open_positions'</span>,
    <span class="str">'Number of open positions'</span>,
)
DRAWDOWN = Gauge(
    <span class="str">'trading_bot_drawdown_pct'</span>,
    <span class="str">'Current drawdown percentage'</span>,
)
TRADE_LATENCY = Histogram(
    <span class="str">'trading_bot_trade_latency_seconds'</span>,
    <span class="str">'Time to execute a trade'</span>,
    buckets=[<span class="num">0.1</span>, <span class="num">0.5</span>, <span class="num">1.0</span>, <span class="num">2.0</span>, <span class="num">5.0</span>, <span class="num">10.0</span>],
)
ERRORS = Counter(
    <span class="str">'trading_bot_errors_total'</span>,
    <span class="str">'Total errors'</span>,
    [<span class="str">'type'</span>],
)
HEARTBEAT = Gauge(
    <span class="str">'trading_bot_last_heartbeat'</span>,
    <span class="str">'Timestamp of last heartbeat'</span>,
)


<span class="kw">class</span> <span class="cls">HealthServer</span>:
    <span class="str">"""HTTP server for health checks and Prometheus metrics."""</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, port: <span class="cls">int</span> = <span class="num">8080</span>):
        self.port = port
        self.start_time = time.time()
        self.is_healthy = <span class="num">True</span>
        self.status_details = {}
        self.app = web.Application()
        self.app.router.add_get(<span class="str">'/health'</span>, self._health_handler)
        self.app.router.add_get(<span class="str">'/metrics'</span>, self._metrics_handler)
        self.app.router.add_get(<span class="str">'/status'</span>, self._status_handler)

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_health_handler</span>(self, request):
        HEARTBEAT.set(time.time())
        <span class="kw">if</span> self.is_healthy:
            <span class="kw">return</span> web.json_response({
                <span class="str">'status'</span>: <span class="str">'healthy'</span>,
                <span class="str">'uptime_seconds'</span>: <span class="fn">int</span>(time.time() - self.start_time),
            })
        <span class="kw">return</span> web.json_response(
            {<span class="str">'status'</span>: <span class="str">'unhealthy'</span>}, status=<span class="num">503</span>
        )

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_metrics_handler</span>(self, request):
        <span class="kw">return</span> web.Response(
            body=generate_latest(),
            content_type=CONTENT_TYPE_LATEST,
        )

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">_status_handler</span>(self, request):
        <span class="kw">return</span> web.json_response({
            <span class="str">'status'</span>: <span class="str">'running'</span> <span class="kw">if</span> self.is_healthy <span class="kw">else</span> <span class="str">'stopped'</span>,
            <span class="str">'uptime'</span>: <span class="fn">int</span>(time.time() - self.start_time),
            **self.status_details,
        })

    <span class="kw">async</span> <span class="kw">def</span> <span class="fn">start</span>(self):
        runner = web.AppRunner(self.app)
        <span class="kw">await</span> runner.setup()
        site = web.TCPSite(runner, <span class="str">'0.0.0.0'</span>, self.port)
        <span class="kw">await</span> site.start()
        logger.info(<span class="str">f"üìä Health server running on port {self.port}"</span>)

    <span class="kw">def</span> <span class="fn">record_trade</span>(self, symbol, side, strategy, latency):
        <span class="str">"""Record a trade in metrics."""</span>
        TRADES_TOTAL.labels(
            symbol=symbol, side=side, strategy=strategy
        ).inc()
        TRADE_LATENCY.observe(latency)

    <span class="kw">def</span> <span class="fn">update_balance</span>(self, balance, pnl, positions, drawdown):
        <span class="str">"""Update balance metrics."""</span>
        BALANCE.set(balance)
        PNL_TOTAL.set(pnl)
        OPEN_POSITIONS.set(positions)
        DRAWDOWN.set(drawdown)<span class="code-label">Python</span></code></pre></div>

          <div class="callout info">
            üí° <strong>Prometheus + Grafana:</strong> Point Prometheus at <code>http://trading-bot:8080/metrics</code> in your docker-compose setup. Import Grafana dashboard ID 1860 for a starting template, then customize with your trading metrics.
          </div>
        </div>
      </div>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üìÅ Complete Project Structure
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <div class="file-tree">
<span class="dir">trading-bot/</span>
‚îú‚îÄ‚îÄ <span class="file">main.py</span>                    <span class="comment"># Entry point, orchestrator</span>
‚îú‚îÄ‚îÄ <span class="file">config.py</span>                  <span class="comment"># Configuration management</span>
‚îú‚îÄ‚îÄ <span class="file">.env</span>                       <span class="comment"># API keys (never commit!)</span>
‚îú‚îÄ‚îÄ <span class="file">.env.example</span>               <span class="comment"># Template for .env</span>
‚îú‚îÄ‚îÄ <span class="file">requirements.txt</span>           <span class="comment"># Python dependencies</span>
‚îú‚îÄ‚îÄ <span class="file">Dockerfile</span>                 <span class="comment"># Container definition</span>
‚îú‚îÄ‚îÄ <span class="file">docker-compose.yml</span>         <span class="comment"># Full stack definition</span>
‚îú‚îÄ‚îÄ <span class="dir">strategies/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">base_strategy.py</span>       <span class="comment"># Abstract base class</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">grid_bot.py</span>            <span class="comment"># Grid trading</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">dca_bot.py</span>             <span class="comment"># DCA with safety orders</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">mean_reversion.py</span>      <span class="comment"># Bollinger + RSI</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">momentum.py</span>            <span class="comment"># EMA crossover + ADX</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">funding_arb.py</span>         <span class="comment"># Funding rate arbitrage</span>
‚îú‚îÄ‚îÄ <span class="dir">exchange/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">connector.py</span>           <span class="comment"># CCXT exchange wrapper</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">data_collector.py</span>      <span class="comment"># OHLCV data fetching</span>
‚îú‚îÄ‚îÄ <span class="dir">risk/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">risk_manager.py</span>        <span class="comment"># Position sizing, circuit breakers</span>
‚îú‚îÄ‚îÄ <span class="dir">notifications/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">telegram_bot.py</span>        <span class="comment"># Telegram alerts</span>
‚îú‚îÄ‚îÄ <span class="dir">backtest/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">__init__.py</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">engine.py</span>              <span class="comment"># Custom backtest engine</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">vectorbt_walkforward.py</span> <span class="comment"># VectorBT walk-forward</span>
‚îú‚îÄ‚îÄ <span class="dir">monitoring/</span>
‚îÇ   ‚îú‚îÄ‚îÄ <span class="file">health_server.py</span>       <span class="comment"># HTTP health + Prometheus</span>
‚îÇ   ‚îî‚îÄ‚îÄ <span class="file">prometheus.yml</span>         <span class="comment"># Prometheus config</span>
‚îú‚îÄ‚îÄ <span class="dir">data/</span>                       <span class="comment"># Trade logs, OHLCV cache</span>
‚îî‚îÄ‚îÄ <span class="dir">logs/</span>                       <span class="comment"># Application logs</span>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- ============================================================ -->
  <!-- ============================================================ -->
  <!-- ========== MODULE B: MT5 / MQL5 FOR FTMO =================== -->
  <!-- ============================================================ -->
  <!-- ============================================================ -->
  <div class="mega-section-header" id="mod-b">
    <span class="section-num">MODULE B</span>
    <h2>üìä MetaTrader 5 &amp; MQL5 for FTMO</h2>
    <p>Build prop firm-ready Expert Advisors. London Breakout EA in full MQL5 + Python-to-MT5 bridge for hybrid strategies.</p>
  </div>

  <!-- B1: LONDON BREAKOUT EA -->
  <section class="section" id="b1">
    <div class="section-header">
      <span class="section-num">B.1</span>
      <h2>London Breakout EA ‚Äî Full MQL5 Code</h2>
    </div>
    <div>
      <span class="difficulty-badge advanced">üî¥ Advanced</span>
      <span class="time-badge">‚è± 8‚Äì12 hours</span>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üá¨üáß London Session Breakout Expert Advisor
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>The London Breakout strategy identifies the Asian session's high/low range and trades the breakout when London opens. This is one of the most FTMO-friendly strategies due to its tight risk management and predictable trading hours.</p>

          <div class="callout info">
            üí° <strong>Why London Breakout for FTMO:</strong> Trades only 2-4 times per day, uses fixed stop losses (great for daily loss limits), and has a proven win rate of 55-65% on EURUSD/GBPUSD. The tight trading window means you're not exposed to overnight risk.
          </div>

          <div class="code-block"><pre><code><span class="cm">//+------------------------------------------------------------------+</span>
<span class="cm">//|                                     LondonBreakoutEA.mq5          |</span>
<span class="cm">//|                                     FTMO-Optimized Version        |</span>
<span class="cm">//|                                     Copyright 2026                |</span>
<span class="cm">//+------------------------------------------------------------------+</span>
<span class="kw">#property</span> copyright <span class="str">"Trading Research 2026"</span>
<span class="kw">#property</span> version   <span class="str">"2.00"</span>
<span class="kw">#property</span> strict

<span class="cm">// ‚îÄ‚îÄ‚îÄ INPUT PARAMETERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">input</span> <span class="cls">group</span> <span class="str">"=== Session Times (Server Time UTC+2) ==="</span>
<span class="kw">input</span> <span class="cls">int</span>    AsianStartHour     = <span class="num">0</span>;    <span class="cm">// Asian session start (00:00)</span>
<span class="kw">input</span> <span class="cls">int</span>    AsianEndHour       = <span class="num">7</span>;    <span class="cm">// Asian session end (07:00)</span>
<span class="kw">input</span> <span class="cls">int</span>    LondonStartHour    = <span class="num">8</span>;    <span class="cm">// London open ‚Äî start trading</span>
<span class="kw">input</span> <span class="cls">int</span>    TradeEndHour       = <span class="num">16</span>;   <span class="cm">// Stop opening new trades</span>
<span class="kw">input</span> <span class="cls">int</span>    CloseAllHour       = <span class="num">20</span>;   <span class="cm">// Force close all positions</span>

<span class="kw">input</span> <span class="cls">group</span> <span class="str">"=== Risk Management (FTMO-Compliant) ==="</span>
<span class="kw">input</span> <span class="cls">double</span> RiskPerTrade       = <span class="num">0.5</span>;  <span class="cm">// Risk % per trade (0.5% = conservative)</span>
<span class="kw">input</span> <span class="cls">double</span> MaxDailyLossPct    = <span class="num">4.0</span>;  <span class="cm">// Max daily loss % (FTMO limit = 5%)</span>
<span class="kw">input</span> <span class="cls">double</span> MaxTotalLossPct    = <span class="num">8.0</span>;  <span class="cm">// Max total loss % (FTMO limit = 10%)</span>
<span class="kw">input</span> <span class="cls">int</span>    MaxTradesPerDay    = <span class="num">3</span>;    <span class="cm">// Maximum trades per session</span>

<span class="kw">input</span> <span class="cls">group</span> <span class="str">"=== Trade Parameters ==="</span>
<span class="kw">input</span> <span class="cls">int</span>    BreakoutBuffer     = <span class="num">5</span>;    <span class="cm">// Pips above/below range for entry</span>
<span class="kw">input</span> <span class="cls">double</span> RiskRewardRatio    = <span class="num">2.0</span>;  <span class="cm">// Take profit = SL √ó this</span>
<span class="kw">input</span> <span class="cls">int</span>    MinRangePips       = <span class="num">20</span>;   <span class="cm">// Min Asian range (skip tiny ranges)</span>
<span class="kw">input</span> <span class="cls">int</span>    MaxRangePips       = <span class="num">80</span>;   <span class="cm">// Max Asian range (skip huge ranges)</span>
<span class="kw">input</span> <span class="cls">bool</span>   UseTrailingStop    = <span class="num">true</span>; <span class="cm">// Enable trailing stop</span>
<span class="kw">input</span> <span class="cls">int</span>    TrailingStartPips  = <span class="num">15</span>;   <span class="cm">// Activate trailing after X pips profit</span>
<span class="kw">input</span> <span class="cls">int</span>    TrailingStepPips   = <span class="num">5</span>;    <span class="cm">// Trailing stop step</span>

<span class="kw">input</span> <span class="cls">group</span> <span class="str">"=== Filters ==="</span>
<span class="kw">input</span> <span class="cls">bool</span>   UseATRFilter       = <span class="num">true</span>; <span class="cm">// Filter by ATR (volatility)</span>
<span class="kw">input</span> <span class="cls">int</span>    ATRPeriod          = <span class="num">14</span>;
<span class="kw">input</span> <span class="cls">double</span> ATRMultiplier      = <span class="num">0.5</span>;  <span class="cm">// Min ATR as % of range</span>
<span class="kw">input</span> <span class="cls">bool</span>   AvoidFriday        = <span class="num">true</span>; <span class="cm">// Skip Friday trades</span>
<span class="kw">input</span> <span class="cls">bool</span>   AvoidNFP           = <span class="num">true</span>; <span class="cm">// Skip first Friday of month (NFP)</span>

<span class="kw">input</span> <span class="cls">group</span> <span class="str">"=== System ==="</span>
<span class="kw">input</span> <span class="cls">int</span>    MagicNumber        = <span class="num">202601</span>; <span class="cm">// Unique EA identifier</span>
<span class="kw">input</span> <span class="cls">int</span>    Slippage           = <span class="num">3</span>;       <span class="cm">// Max slippage in points</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ GLOBAL VARIABLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">double</span> g_asianHigh, g_asianLow;
<span class="cls">bool</span>   g_rangeCalculated = <span class="num">false</span>;
<span class="cls">int</span>    g_tradesToday = <span class="num">0</span>;
<span class="cls">double</span> g_dailyStartBalance;
<span class="cls">double</span> g_initialBalance;
<span class="cls">int</span>    g_lastTradeDay = <span class="num">-1</span>;
<span class="cls">int</span>    g_atrHandle;
<span class="cls">double</span> g_point;
<span class="cls">int</span>    g_digits;

<span class="cm">// ‚îÄ‚îÄ‚îÄ INITIALIZATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">int</span> <span class="fn">OnInit</span>()
{
    g_initialBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    g_dailyStartBalance = g_initialBalance;
    g_point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    g_digits = (<span class="cls">int</span>)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);

    <span class="cm">// Initialize ATR indicator</span>
    <span class="kw">if</span>(UseATRFilter)
    {
        g_atrHandle = iATR(_Symbol, PERIOD_H1, ATRPeriod);
        <span class="kw">if</span>(g_atrHandle == INVALID_HANDLE)
        {
            Print(<span class="str">"‚ùå Failed to create ATR indicator"</span>);
            <span class="kw">return</span>(INIT_FAILED);
        }
    }

    Print(<span class="str">"‚úÖ London Breakout EA initialized on "</span>, _Symbol);
    Print(<span class="str">"  Risk per trade: "</span>, RiskPerTrade, <span class="str">"%"</span>);
    Print(<span class="str">"  Max daily loss: "</span>, MaxDailyLossPct, <span class="str">"%"</span>);
    Print(<span class="str">"  R:R Ratio: 1:"</span>, RiskRewardRatio);

    <span class="kw">return</span>(INIT_SUCCEEDED);
}

<span class="cls">void</span> <span class="fn">OnDeinit</span>(<span class="kw">const</span> <span class="cls">int</span> reason)
{
    <span class="kw">if</span>(g_atrHandle != INVALID_HANDLE)
        IndicatorRelease(g_atrHandle);
    Print(<span class="str">"London Breakout EA removed. Reason: "</span>, reason);
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ MAIN TICK FUNCTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">void</span> <span class="fn">OnTick</span>()
{
    MqlDateTime dt;
    TimeCurrent(dt);

    <span class="cm">// Reset daily counters at new day</span>
    <span class="kw">if</span>(dt.day != g_lastTradeDay)
    {
        g_lastTradeDay = dt.day;
        g_tradesToday = <span class="num">0</span>;
        g_rangeCalculated = <span class="num">false</span>;
        g_dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    }

    <span class="cm">// ‚îÄ‚îÄ‚îÄ SAFETY CHECK: FTMO Daily Loss Limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
    <span class="cls">double</span> currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    <span class="cls">double</span> currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    <span class="cls">double</span> dailyLoss = (g_dailyStartBalance - currentEquity)
                      / g_dailyStartBalance * <span class="num">100</span>;
    <span class="cls">double</span> totalLoss = (g_initialBalance - currentEquity)
                      / g_initialBalance * <span class="num">100</span>;

    <span class="kw">if</span>(dailyLoss &gt;= MaxDailyLossPct)
    {
        CloseAllPositions();
        Print(<span class="str">"üõë DAILY LOSS LIMIT HIT: "</span>, dailyLoss, <span class="str">"%"</span>);
        <span class="kw">return</span>;
    }

    <span class="kw">if</span>(totalLoss &gt;= MaxTotalLossPct)
    {
        CloseAllPositions();
        Print(<span class="str">"üõë TOTAL LOSS LIMIT HIT: "</span>, totalLoss, <span class="str">"%"</span>);
        <span class="kw">return</span>;
    }

    <span class="cm">// ‚îÄ‚îÄ‚îÄ STEP 1: Calculate Asian Range ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
    <span class="kw">if</span>(!g_rangeCalculated &amp;&amp; dt.hour == LondonStartHour &amp;&amp; dt.min == <span class="num">0</span>)
    {
        CalculateAsianRange(dt);
    }

    <span class="cm">// ‚îÄ‚îÄ‚îÄ STEP 2: Manage trailing stop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
    <span class="kw">if</span>(UseTrailingStop)
        ManageTrailingStop();

    <span class="cm">// ‚îÄ‚îÄ‚îÄ STEP 3: Force close at end of day ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
    <span class="kw">if</span>(dt.hour &gt;= CloseAllHour)
    {
        CloseAllPositions();
        <span class="kw">return</span>;
    }

    <span class="cm">// ‚îÄ‚îÄ‚îÄ STEP 4: Check for breakout entry ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
    <span class="kw">if</span>(g_rangeCalculated
       &amp;&amp; dt.hour &gt;= LondonStartHour
       &amp;&amp; dt.hour &lt; TradeEndHour
       &amp;&amp; g_tradesToday &lt; MaxTradesPerDay
       &amp;&amp; CountOpenPositions() == <span class="num">0</span>)
    {
        <span class="kw">if</span>(AvoidFriday &amp;&amp; dt.day_of_week == <span class="num">5</span>) <span class="kw">return</span>;
        <span class="kw">if</span>(AvoidNFP &amp;&amp; IsNFPDay(dt)) <span class="kw">return</span>;

        CheckBreakout();
    }
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ CALCULATE ASIAN SESSION RANGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">void</span> <span class="fn">CalculateAsianRange</span>(MqlDateTime &amp;dt)
{
    g_asianHigh = -DBL_MAX;
    g_asianLow  = DBL_MAX;

    <span class="cm">// Scan Asian session candles</span>
    <span class="cls">int</span> bars = Bars(_Symbol, PERIOD_M15);
    <span class="kw">for</span>(<span class="cls">int</span> i = <span class="num">1</span>; i &lt; bars; i++)
    {
        datetime barTime = iTime(_Symbol, PERIOD_M15, i);
        MqlDateTime barDt;
        TimeToStruct(barTime, barDt);

        <span class="cm">// Only today's Asian session</span>
        <span class="kw">if</span>(barDt.day != dt.day) <span class="kw">break</span>;
        <span class="kw">if</span>(barDt.hour &lt; AsianStartHour || barDt.hour &gt;= AsianEndHour)
            <span class="kw">continue</span>;

        <span class="cls">double</span> high = iHigh(_Symbol, PERIOD_M15, i);
        <span class="cls">double</span> low  = iLow(_Symbol, PERIOD_M15, i);

        <span class="kw">if</span>(high &gt; g_asianHigh) g_asianHigh = high;
        <span class="kw">if</span>(low  &lt; g_asianLow)  g_asianLow  = low;
    }

    <span class="cls">double</span> rangePips = (g_asianHigh - g_asianLow) / g_point / <span class="num">10</span>;

    <span class="cm">// Validate range</span>
    <span class="kw">if</span>(rangePips &lt; MinRangePips || rangePips &gt; MaxRangePips)
    {
        Print(<span class="str">"‚è≠Ô∏è Asian range "</span>, rangePips, <span class="str">" pips ‚Äî outside "</span>,
              MinRangePips, <span class="str">"-"</span>, MaxRangePips, <span class="str">" filter. Skipping."</span>);
        g_rangeCalculated = <span class="num">false</span>;
        <span class="kw">return</span>;
    }

    <span class="cm">// ATR filter</span>
    <span class="kw">if</span>(UseATRFilter)
    {
        <span class="cls">double</span> atr[];
        CopyBuffer(g_atrHandle, <span class="num">0</span>, <span class="num">0</span>, <span class="num">1</span>, atr);
        <span class="kw">if</span>(atr[<span class="num">0</span>] &lt; (g_asianHigh - g_asianLow) * ATRMultiplier)
        {
            Print(<span class="str">"‚è≠Ô∏è ATR too low ‚Äî low volatility. Skipping."</span>);
            g_rangeCalculated = <span class="num">false</span>;
            <span class="kw">return</span>;
        }
    }

    g_rangeCalculated = <span class="num">true</span>;
    Print(<span class="str">"üìä Asian Range: High="</span>, g_asianHigh,
          <span class="str">" Low="</span>, g_asianLow, <span class="str">" ("</span>, rangePips, <span class="str">" pips)"</span>);
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ CHECK FOR BREAKOUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">void</span> <span class="fn">CheckBreakout</span>()
{
    <span class="cls">double</span> ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    <span class="cls">double</span> bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    <span class="cls">double</span> buffer = BreakoutBuffer * g_point * <span class="num">10</span>;

    <span class="cm">// LONG breakout: price above Asian high + buffer</span>
    <span class="kw">if</span>(ask &gt; g_asianHigh + buffer)
    {
        <span class="cls">double</span> sl = g_asianLow - buffer;
        <span class="cls">double</span> slDistance = ask - sl;
        <span class="cls">double</span> tp = ask + (slDistance * RiskRewardRatio);
        <span class="cls">double</span> lots = CalculateLotSize(slDistance);

        <span class="kw">if</span>(lots &gt; <span class="num">0</span>)
        {
            OpenTrade(ORDER_TYPE_BUY, ask, sl, tp, lots,
                      <span class="str">"LB Long"</span>);
        }
    }

    <span class="cm">// SHORT breakout: price below Asian low - buffer</span>
    <span class="kw">if</span>(bid &lt; g_asianLow - buffer)
    {
        <span class="cls">double</span> sl = g_asianHigh + buffer;
        <span class="cls">double</span> slDistance = sl - bid;
        <span class="cls">double</span> tp = bid - (slDistance * RiskRewardRatio);
        <span class="cls">double</span> lots = CalculateLotSize(slDistance);

        <span class="kw">if</span>(lots &gt; <span class="num">0</span>)
        {
            OpenTrade(ORDER_TYPE_SELL, bid, sl, tp, lots,
                      <span class="str">"LB Short"</span>);
        }
    }
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ LOT SIZE CALCULATOR (RISK-BASED) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">double</span> <span class="fn">CalculateLotSize</span>(<span class="cls">double</span> slDistance)
{
    <span class="cls">double</span> balance = AccountInfoDouble(ACCOUNT_BALANCE);
    <span class="cls">double</span> riskAmount = balance * (RiskPerTrade / <span class="num">100.0</span>);
    <span class="cls">double</span> tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    <span class="cls">double</span> tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    <span class="cls">double</span> lotStep   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    <span class="cls">double</span> minLot    = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    <span class="cls">double</span> maxLot    = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

    <span class="kw">if</span>(tickValue == <span class="num">0</span> || slDistance == <span class="num">0</span>) <span class="kw">return</span> <span class="num">0</span>;

    <span class="cls">double</span> lots = riskAmount / (slDistance / tickSize * tickValue);
    lots = MathFloor(lots / lotStep) * lotStep;
    lots = MathMax(lots, minLot);
    lots = MathMin(lots, maxLot);

    <span class="kw">return</span>(NormalizeDouble(lots, <span class="num">2</span>));
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ OPEN TRADE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">bool</span> <span class="fn">OpenTrade</span>(<span class="cls">int</span> type, <span class="cls">double</span> price, <span class="cls">double</span> sl,
              <span class="cls">double</span> tp, <span class="cls">double</span> lots, <span class="cls">string</span> comment)
{
    MqlTradeRequest request = {};
    MqlTradeResult  result  = {};

    request.action    = TRADE_ACTION_DEAL;
    request.symbol    = _Symbol;
    request.volume    = lots;
    request.type      = (<span class="cls">ENUM_ORDER_TYPE</span>)type;
    request.price     = price;
    request.sl        = NormalizeDouble(sl, g_digits);
    request.tp        = NormalizeDouble(tp, g_digits);
    request.deviation = Slippage;
    request.magic     = MagicNumber;
    request.comment   = comment;
    request.type_filling = ORDER_FILLING_IOC;

    <span class="kw">if</span>(!OrderSend(request, result))
    {
        Print(<span class="str">"‚ùå Order failed: "</span>, result.retcode,
              <span class="str">" ‚Äî "</span>, result.comment);
        <span class="kw">return</span> <span class="num">false</span>;
    }

    g_tradesToday++;
    <span class="cls">string</span> dir = (type == ORDER_TYPE_BUY) ? <span class="str">"LONG"</span> : <span class="str">"SHORT"</span>;
    Print(<span class="str">"‚úÖ "</span>, dir, <span class="str">" opened: "</span>, lots, <span class="str">" lots @ "</span>, price,
          <span class="str">" SL="</span>, sl, <span class="str">" TP="</span>, tp);
    <span class="kw">return</span> <span class="num">true</span>;
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ TRAILING STOP MANAGEMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">void</span> <span class="fn">ManageTrailingStop</span>()
{
    <span class="kw">for</span>(<span class="cls">int</span> i = PositionsTotal() - <span class="num">1</span>; i &gt;= <span class="num">0</span>; i--)
    {
        <span class="kw">if</span>(!PositionSelectByTicket(PositionGetTicket(i))) <span class="kw">continue</span>;
        <span class="kw">if</span>(PositionGetInteger(POSITION_MAGIC) != MagicNumber) <span class="kw">continue</span>;
        <span class="kw">if</span>(PositionGetString(POSITION_SYMBOL) != _Symbol) <span class="kw">continue</span>;

        <span class="cls">double</span> openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        <span class="cls">double</span> currentSL = PositionGetDouble(POSITION_SL);
        <span class="cls">double</span> trailStart = TrailingStartPips * g_point * <span class="num">10</span>;
        <span class="cls">double</span> trailStep  = TrailingStepPips * g_point * <span class="num">10</span>;

        <span class="kw">if</span>(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
        {
            <span class="cls">double</span> bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            <span class="kw">if</span>(bid - openPrice &gt; trailStart)
            {
                <span class="cls">double</span> newSL = bid - trailStep;
                <span class="kw">if</span>(newSL &gt; currentSL + g_point)
                    ModifySL(PositionGetTicket(i), newSL);
            }
        }
        <span class="kw">else</span>
        {
            <span class="cls">double</span> ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
            <span class="kw">if</span>(openPrice - ask &gt; trailStart)
            {
                <span class="cls">double</span> newSL = ask + trailStep;
                <span class="kw">if</span>(newSL &lt; currentSL - g_point || currentSL == <span class="num">0</span>)
                    ModifySL(PositionGetTicket(i), newSL);
            }
        }
    }
}

<span class="cls">void</span> <span class="fn">ModifySL</span>(<span class="cls">ulong</span> ticket, <span class="cls">double</span> newSL)
{
    MqlTradeRequest request = {};
    MqlTradeResult  result  = {};

    request.action   = TRADE_ACTION_SLTP;
    request.position = ticket;
    request.symbol   = _Symbol;
    request.sl       = NormalizeDouble(newSL, g_digits);
    request.tp       = PositionGetDouble(POSITION_TP);

    <span class="kw">if</span>(OrderSend(request, result))
        Print(<span class="str">"üìè Trailing SL moved to "</span>, newSL);
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ UTILITY FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cls">int</span> <span class="fn">CountOpenPositions</span>()
{
    <span class="cls">int</span> count = <span class="num">0</span>;
    <span class="kw">for</span>(<span class="cls">int</span> i = <span class="num">0</span>; i &lt; PositionsTotal(); i++)
    {
        <span class="kw">if</span>(PositionSelectByTicket(PositionGetTicket(i))
           &amp;&amp; PositionGetInteger(POSITION_MAGIC) == MagicNumber
           &amp;&amp; PositionGetString(POSITION_SYMBOL) == _Symbol)
            count++;
    }
    <span class="kw">return</span> count;
}

<span class="cls">void</span> <span class="fn">CloseAllPositions</span>()
{
    <span class="kw">for</span>(<span class="cls">int</span> i = PositionsTotal() - <span class="num">1</span>; i &gt;= <span class="num">0</span>; i--)
    {
        <span class="cls">ulong</span> ticket = PositionGetTicket(i);
        <span class="kw">if</span>(!PositionSelectByTicket(ticket)) <span class="kw">continue</span>;
        <span class="kw">if</span>(PositionGetInteger(POSITION_MAGIC) != MagicNumber) <span class="kw">continue</span>;
        <span class="kw">if</span>(PositionGetString(POSITION_SYMBOL) != _Symbol) <span class="kw">continue</span>;

        MqlTradeRequest request = {};
        MqlTradeResult  result  = {};

        request.action   = TRADE_ACTION_DEAL;
        request.symbol   = _Symbol;
        request.position = ticket;
        request.volume   = PositionGetDouble(POSITION_VOLUME);
        request.deviation = Slippage;

        <span class="kw">if</span>(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
        {
            request.type  = ORDER_TYPE_SELL;
            request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        }
        <span class="kw">else</span>
        {
            request.type  = ORDER_TYPE_BUY;
            request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        }

        OrderSend(request, result);
    }
}

<span class="cls">bool</span> <span class="fn">IsNFPDay</span>(MqlDateTime &amp;dt)
{
    <span class="cm">// NFP is first Friday of the month</span>
    <span class="kw">if</span>(dt.day_of_week != <span class="num">5</span>) <span class="kw">return</span> <span class="num">false</span>;
    <span class="kw">return</span>(dt.day &lt;= <span class="num">7</span>);
}<span class="code-label">MQL5</span></code></pre></div>

          <div class="callout warning">
            ‚ö†Ô∏è <strong>FTMO Testing:</strong> Before using on a real challenge, backtest this EA with the Strategy Tester in MT5. Use "Every tick based on real ticks" mode. Test on EURUSD, GBPUSD, and USDJPY. Minimum 2 years of data. The default parameters are conservative ‚Äî you may want to optimize RiskRewardRatio and BreakoutBuffer per pair.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- B2: PYTHON TO MT5 -->
  <section class="section" id="b2">
    <div class="section-header">
      <span class="section-num">B.2</span>
      <h2>Python-to-MT5 Bridge ‚Äî Hybrid Trading</h2>
    </div>
    <div>
      <span class="difficulty-badge intermediate">üü° Intermediate</span>
      <span class="time-badge">‚è± 4‚Äì6 hours</span>
    </div>

    <div class="collapsible">
      <button class="collapsible-toggle">
        üêç Full Python-MT5 Integration for Signal-Based Trading
        <span class="chevron">‚ñº</span>
      </button>
      <div class="collapsible-body">
        <div class="collapsible-content">
          <p>Use Python for advanced analysis (ML models, sentiment, data processing) and MT5 for execution. This hybrid approach gives you the best of both worlds ‚Äî Python's rich ecosystem for research and MT5's reliable execution for prop firm accounts.</p>

          <div class="callout info">
            üí° <strong>Requirement:</strong> The <code>MetaTrader5</code> Python package only works on Windows (it communicates with the MT5 terminal via a local pipe). For Mac/Linux, run MT5 in a Windows VM or use a Windows VPS.
          </div>

          <div class="code-block"><pre><code><span class="cm"># mt5_bridge/connector.py ‚Äî Python-to-MT5 Trading Bridge</span>
<span class="cm"># pip install MetaTrader5 pandas numpy ta</span>
<span class="kw">import</span> MetaTrader5 <span class="kw">as</span> mt5
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">from</span> datetime <span class="kw">import</span> datetime, timedelta
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Optional, Tuple
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass
<span class="kw">from</span> loguru <span class="kw">import</span> logger
<span class="kw">import</span> time


<span class="dec">@dataclass</span>
<span class="kw">class</span> <span class="cls">MT5Config</span>:
    <span class="str">"""MT5 connection configuration."""</span>
    login: <span class="cls">int</span>
    password: <span class="cls">str</span>
    server: <span class="cls">str</span>
    path: <span class="cls">str</span> = <span class="str">r"C:\Program Files\MetaTrader 5\terminal64.exe"</span>
    timeout: <span class="cls">int</span> = <span class="num">10000</span>


<span class="kw">class</span> <span class="cls">MT5Bridge</span>:
    <span class="str">"""
    Python-to-MT5 Trading Bridge
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Features:
    - Connection management with auto-reconnect
    - Market data retrieval (OHLCV, ticks)
    - Order execution (market, limit, stop)
    - Position management
    - Risk-based lot sizing for FTMO
    - Account monitoring
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(self, config: MT5Config):
        self.config = config
        self.connected = <span class="num">False</span>
        self.magic_number = <span class="num">202602</span>

    <span class="kw">def</span> <span class="fn">connect</span>(self) -&gt; <span class="cls">bool</span>:
        <span class="str">"""Initialize and connect to MT5 terminal."""</span>
        <span class="kw">if not</span> mt5.initialize(
            path=self.config.path,
            login=self.config.login,
            password=self.config.password,
            server=self.config.server,
            timeout=self.config.timeout,
        ):
            logger.error(<span class="str">f"MT5 init failed: {mt5.last_error()}"</span>)
            <span class="kw">return</span> <span class="num">False</span>

        <span class="cm"># Verify login</span>
        info = mt5.account_info()
        <span class="kw">if</span> info <span class="kw">is None</span>:
            logger.error(<span class="str">"Failed to get account info"</span>)
            <span class="kw">return</span> <span class="num">False</span>

        self.connected = <span class="num">True</span>
        logger.info(
            <span class="str">f"‚úÖ Connected to MT5: {info.server}\n"</span>
            <span class="str">f"  Account: {info.login}\n"</span>
            <span class="str">f"  Balance: ${info.balance:,.2f}\n"</span>
            <span class="str">f"  Leverage: 1:{info.leverage}"</span>
        )
        <span class="kw">return</span> <span class="num">True</span>

    <span class="kw">def</span> <span class="fn">disconnect</span>(self):
        mt5.shutdown()
        self.connected = <span class="num">False</span>
        logger.info(<span class="str">"MT5 disconnected"</span>)

    <span class="kw">def</span> <span class="fn">_ensure_connected</span>(self):
        <span class="kw">if not</span> self.connected:
            <span class="kw">if not</span> self.connect():
                <span class="kw">raise</span> ConnectionError(<span class="str">"Cannot connect to MT5"</span>)

    <span class="cm"># ‚îÄ‚îÄ‚îÄ MARKET DATA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>

    <span class="kw">def</span> <span class="fn">get_ohlcv</span>(
        self, symbol: <span class="cls">str</span>, timeframe: <span class="cls">int</span> = mt5.TIMEFRAME_H1,
        bars: <span class="cls">int</span> = <span class="num">500</span>,
    ) -&gt; pd.DataFrame:
        <span class="str">"""Fetch OHLCV data as a pandas DataFrame."""</span>
        self._ensure_connected()
        rates = mt5.copy_rates_from_pos(symbol, timeframe, <span class="num">0</span>, bars)
        <span class="kw">if</span> rates <span class="kw">is None</span>:
            logger.error(<span class="str">f"Failed to get rates for {symbol}"</span>)
            <span class="kw">return</span> pd.DataFrame()

        df = pd.DataFrame(rates)
        df[<span class="str">'time'</span>] = pd.to_datetime(df[<span class="str">'time'</span>], unit=<span class="str">'s'</span>)
        df.set_index(<span class="str">'time'</span>, inplace=<span class="num">True</span>)
        df.rename(columns={
            <span class="str">'open'</span>: <span class="str">'open'</span>, <span class="str">'high'</span>: <span class="str">'high'</span>,
            <span class="str">'low'</span>: <span class="str">'low'</span>, <span class="str">'close'</span>: <span class="str">'close'</span>,
            <span class="str">'tick_volume'</span>: <span class="str">'volume'</span>,
        }, inplace=<span class="num">True</span>)
        <span class="kw">return</span> df

    <span class="kw">def</span> <span class="fn">get_tick</span>(self, symbol: <span class="cls">str</span>) -&gt; Dict:
        <span class="str">"""Get current bid/ask for a symbol."""</span>
        self._ensure_connected()
        tick = mt5.symbol_info_tick(symbol)
        <span class="kw">if</span> tick <span class="kw">is None</span>:
            <span class="kw">return</span> {}
        <span class="kw">return</span> {
            <span class="str">'bid'</span>: tick.bid, <span class="str">'ask'</span>: tick.ask,
            <span class="str">'last'</span>: tick.last, <span class="str">'time'</span>: tick.time,
        }

    <span class="cm"># ‚îÄ‚îÄ‚îÄ ORDER EXECUTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>

    <span class="kw">def</span> <span class="fn">market_order</span>(
        self, symbol: <span class="cls">str</span>, side: <span class="cls">str</span>, lots: <span class="cls">float</span>,
        sl: <span class="cls">float</span> = <span class="num">0</span>, tp: <span class="cls">float</span> = <span class="num">0</span>,
        comment: <span class="cls">str</span> = <span class="str">''</span>,
    ) -&gt; Optional[Dict]:
        <span class="str">"""Place a market order."""</span>
        self._ensure_connected()
        tick = mt5.symbol_info_tick(symbol)
        <span class="kw">if</span> tick <span class="kw">is None</span>:
            logger.error(<span class="str">f"Cannot get tick for {symbol}"</span>)
            <span class="kw">return</span> <span class="num">None</span>

        order_type = (mt5.ORDER_TYPE_BUY <span class="kw">if</span> side == <span class="str">'buy'</span>
                      <span class="kw">else</span> mt5.ORDER_TYPE_SELL)
        price = tick.ask <span class="kw">if</span> side == <span class="str">'buy'</span> <span class="kw">else</span> tick.bid

        request = {
            <span class="str">'action'</span>: mt5.TRADE_ACTION_DEAL,
            <span class="str">'symbol'</span>: symbol,
            <span class="str">'volume'</span>: lots,
            <span class="str">'type'</span>: order_type,
            <span class="str">'price'</span>: price,
            <span class="str">'sl'</span>: sl,
            <span class="str">'tp'</span>: tp,
            <span class="str">'deviation'</span>: <span class="num">10</span>,
            <span class="str">'magic'</span>: self.magic_number,
            <span class="str">'comment'</span>: comment,
            <span class="str">'type_filling'</span>: mt5.ORDER_FILLING_IOC,
        }

        result = mt5.order_send(request)
        <span class="kw">if</span> result.retcode != mt5.TRADE_RETCODE_DONE:
            logger.error(
                <span class="str">f"Order failed: {result.retcode} ‚Äî {result.comment}"</span>
            )
            <span class="kw">return</span> <span class="num">None</span>

        logger.info(
            <span class="str">f"‚úÖ {side.upper()} {lots} {symbol} @ {result.price}"</span>
        )
        <span class="kw">return</span> {
            <span class="str">'ticket'</span>: result.order,
            <span class="str">'price'</span>: result.price,
            <span class="str">'volume'</span>: result.volume,
        }

    <span class="kw">def</span> <span class="fn">close_position</span>(self, ticket: <span class="cls">int</span>) -&gt; <span class="cls">bool</span>:
        <span class="str">"""Close a position by ticket number."""</span>
        self._ensure_connected()
        position = mt5.positions_get(ticket=ticket)
        <span class="kw">if not</span> position:
            logger.error(<span class="str">f"Position {ticket} not found"</span>)
            <span class="kw">return</span> <span class="num">False</span>

        pos = position[<span class="num">0</span>]
        close_type = (mt5.ORDER_TYPE_SELL
                      <span class="kw">if</span> pos.type == mt5.ORDER_TYPE_BUY
                      <span class="kw">else</span> mt5.ORDER_TYPE_BUY)
        price = (mt5.symbol_info_tick(pos.symbol).bid
                 <span class="kw">if</span> pos.type == mt5.ORDER_TYPE_BUY
                 <span class="kw">else</span> mt5.symbol_info_tick(pos.symbol).ask)

        request = {
            <span class="str">'action'</span>: mt5.TRADE_ACTION_DEAL,
            <span class="str">'symbol'</span>: pos.symbol,
            <span class="str">'volume'</span>: pos.volume,
            <span class="str">'type'</span>: close_type,
            <span class="str">'position'</span>: ticket,
            <span class="str">'price'</span>: price,
            <span class="str">'deviation'</span>: <span class="num">10</span>,
            <span class="str">'magic'</span>: self.magic_number,
            <span class="str">'comment'</span>: <span class="str">'Close position'</span>,
        }

        result = mt5.order_send(request)
        <span class="kw">if</span> result.retcode != mt5.TRADE_RETCODE_DONE:
            logger.error(<span class="str">f"Close failed: {result.comment}"</span>)
            <span class="kw">return</span> <span class="num">False</span>

        logger.info(<span class="str">f"üî¥ Position {ticket} closed"</span>)
        <span class="kw">return</span> <span class="num">True</span>

    <span class="cm"># ‚îÄ‚îÄ‚îÄ RISK MANAGEMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>

    <span class="kwdef</span> <span class="fn">calculate_lot_size</span>(
        self, symbol: <span class="cls">str</span>, sl_pips: <span class="cls">float</span>,
        risk_pct: <span class="cls">float</span> = <span class="num">0.5</span>,
    ) -&gt; <span class="cls">float</span>:
        <span class="str">"""Calculate lot size based on risk percentage and stop loss."""</span>
        self._ensure_connected()
        info = mt5.account_info()
        symbol_info = mt5.symbol_info(symbol)
        <span class="kw">if not</span> info <span class="kw">or not</span> symbol_info:
            <span class="kw">return</span> symbol_info.volume_min <span class="kw">if</span> symbol_info <span class="kw">else</span> <span class="num">0.01</span>

        risk_amount = info.balance * (risk_pct / <span class="num">100</span>)
        tick_value = symbol_info.trade_tick_value
        tick_size = symbol_info.trade_tick_size
        point = symbol_info.point

        sl_distance = sl_pips * point * <span class="num">10</span>
        <span class="kw">if</span> tick_value == <span class="num">0</span> <span class="kw">or</span> sl_distance == <span class="num">0</span>:
            <span class="kw">return</span> symbol_info.volume_min

        lots = risk_amount / (sl_distance / tick_size * tick_value)
        lots = <span class="fn">max</span>(symbol_info.volume_min,
                   <span class="fn">min</span>(lots, symbol_info.volume_max))
        <span class="cm"># Round to volume step</span>
        step = symbol_info.volume_step
        lots = <span class="fn">round</span>(lots / step) * step
        <span class="kw">return</span> <span class="fn">round</span>(lots, <span class="num">2</span>)

    <span class="kw">def</span> <span class="fn">get_account_info</span>(self) -&gt; Dict:
        <span class="str">"""Get current account status for FTMO monitoring."""</span>
        self._ensure_connected()
        info = mt5.account_info()
        <span class="kw">if not</span> info:
            <span class="kw">return</span> {}
        <span class="kw">return</span> {
            <span class="str">'balance'</span>: info.balance,
            <span class="str">'equity'</span>: info.equity,
            <span class="str">'margin'</span>: info.margin,
            <span class="str">'free_margin'</span>: info.margin_free,
            <span class="str">'profit'</span>: info.profit,
            <span class="str">'leverage'</span>: info.leverage,
        }<span class="code-label">Python</span></code></pre></div>

          <div class="callout success">
            ‚úÖ <strong>Hybrid Workflow:</strong> Use Python to generate signals (ML models, sentiment analysis, technical indicators), then send execution commands to MT5. This gives you the best of both worlds ‚Äî Python's data science ecosystem + MT5's reliable order execution on FTMO servers.
          </div>
        </div>
      </div>
    </div>
  </section>

</div><!-- /tab-full -->

</main>

<!-- Back to Top -->
<button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚Üë</button>

<script>
// ===== TAB SWITCHING =====
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });
});

// ===== COLLAPSIBLE SECTIONS =====
document.querySelectorAll('.collapsible-toggle').forEach(toggle => {
  toggle.addEventListener('click', () => {
    const parent = toggle.parentElement;
    parent.classList.toggle('open');
  });
});

// ===== SCROLL PROGRESS =====
window.addEventListener('scroll', () => {
  const scrollTop = window.scrollY;
  const docHeight = document.documentElement.scrollHeight - window.innerHeight;
  const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
  document.getElementById('scrollProgress').style.width = progress + '%';

  // Back to top button
  const btn = document.getElementById('backToTop');
  if (scrollTop > 400) {
    btn.classList.add('visible');
  } else {
    btn.classList.remove('visible');
  }
});

// ===== SMOOTH SCROLL FOR ANCHOR LINKS =====
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
  anchor.addEventListener('click', function(e) {
    e.preventDefault();
    const target = document.querySelector(this.getAttribute('href'));
    if (target) {
      const headerHeight = document.querySelector('.header').offsetHeight;
      const targetPosition = target.getBoundingClientRect().top + window.scrollY - headerHeight - 20;
      window.scrollTo({ top: targetPosition, behavior: 'smooth' });
    }
  });
});
</script>
</body>
</html>